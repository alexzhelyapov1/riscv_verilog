// rtl/core/ex_mem_register.sv
`include "common/defines.svh"
// `include "common/alu_defines.svh" // Not strictly needed here

module ex_mem_register (
    input  logic clk,
    input  logic rst_n,

    // Inputs from Execute Stage
    input  logic       reg_write_e_i,
    input  logic [1:0] result_src_e_i,
    input  logic       mem_write_e_i,
    input  logic [`DATA_WIDTH-1:0] alu_result_e_i,
    input  logic [`DATA_WIDTH-1:0] rs2_data_e_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_e_i,
    input  logic [`DATA_WIDTH-1:0] pc_plus_4_e_i,
// change start
    input  logic [2:0] funct3_e_i,         // Input for pipelined funct3
// change end

    // Outputs to Memory Stage
    output logic       reg_write_m_o,
    output logic [1:0] result_src_m_o,
    output logic       mem_write_m_o,
    output logic [`DATA_WIDTH-1:0] alu_result_m_o,
    output logic [`DATA_WIDTH-1:0] rs2_data_m_o,
    output logic [`REG_ADDR_WIDTH-1:0] rd_addr_m_o,
    output logic [`DATA_WIDTH-1:0] pc_plus_4_m_o,
// change start
    output logic [2:0] funct3_m_o          // Output for pipelined funct3
// change end
);

    localparam CTL_NOP_REG_WRITE  = 1'b0;
    localparam CTL_NOP_MEM_WRITE  = 1'b0;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            reg_write_m_o    <= CTL_NOP_REG_WRITE;
            result_src_m_o   <= 2'b00;
            mem_write_m_o    <= CTL_NOP_MEM_WRITE;
            alu_result_m_o   <= {`DATA_WIDTH{1'b0}};
            rs2_data_m_o     <= {`DATA_WIDTH{1'b0}};
            rd_addr_m_o      <= {`REG_ADDR_WIDTH{1'b0}};
            pc_plus_4_m_o    <= {`DATA_WIDTH{1'b0}};
// change start
            funct3_m_o       <= 3'b000;
// change end
        end else begin
            reg_write_m_o    <= reg_write_e_i;
            result_src_m_o   <= result_src_e_i;
            mem_write_m_o    <= mem_write_e_i;
            alu_result_m_o   <= alu_result_e_i;
            rs2_data_m_o     <= rs2_data_e_i;
            rd_addr_m_o      <= rd_addr_e_i;
            pc_plus_4_m_o    <= pc_plus_4_e_i;
// change start
            funct3_m_o       <= funct3_e_i;
// change end
        end
    end
endmodule