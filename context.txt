--- File: rtl/common/control_signals_defines.svh ---
// rtl/common/control_signals_defines.svh
`ifndef CONTROL_SIGNALS_DEFINES_SVH
`define CONTROL_SIGNALS_DEFINES_SVH

// Selector for ALU Operand A
typedef enum logic [1:0] {
    ALU_A_SRC_RS1,   // Select RS1 data
    ALU_A_SRC_PC,    // Select PC
    ALU_A_SRC_ZERO   // Select constant Zero (for LUI: 0 + Imm)
    // ALU_A_SRC_FWD // Will be handled by forwarding logic, this selects the *original* source
} alu_a_src_sel_e;

// Selector for PC Target Address source in Execute stage
typedef enum logic [0:0] { // Only two main sources for now
    PC_TARGET_SRC_PC_PLUS_IMM, // Target = PC + Immediate (for Branch, JAL)
    PC_TARGET_SRC_ALU_JALR     // Target = (ALU_Result from RS1+Imm) & ~1 (for JALR)
} pc_target_src_sel_e;

`endif // CONTROL_SIGNALS_DEFINES_SVH


--- File: rtl/common/riscv_opcodes.svh ---
// rtl/common/riscv_opcodes.svh
`ifndef RISCV_OPCODES_SVH
`define RISCV_OPCODES_SVH

// Opcodes (bottom 7 bits of instruction)
`define OPCODE_LUI        7'b0110111 // Load Upper Immediate
`define OPCODE_AUIPC      7'b0010111 // Add Upper Immediate to PC
`define OPCODE_JAL        7'b1101111 // Jump and Link
`define OPCODE_JALR       7'b1100111 // Jump and Link Register
`define OPCODE_BRANCH     7'b1100011 // Conditional Branches (BEQ, BNE, etc.)
`define OPCODE_LOAD       7'b0000011 // Loads (LB, LH, LW, LD, LBU, LHU, LWU)
`define OPCODE_STORE      7'b0100011 // Stores (SB, SH, SW, SD)
`define OPCODE_OP_IMM   7'b0010011 // Immediate Arithmetic/Logic (ADDI, SLTI, etc.)
`define OPCODE_OP         7'b0110011 // Register-Register Arithmetic/Logic (ADD, SUB, etc.)
`define OPCODE_MISC_MEM 7'b0001111 // FENCE, FENCE.I
`define OPCODE_SYSTEM     7'b1110011 // ECALL, EBREAK, CSR instructions

// Funct3 codes for OP_IMM, OP, BRANCH, LOAD, STORE, JALR
// For OP_IMM & OP
`define FUNCT3_ADDI       3'b000 // ADDI
`define FUNCT3_ADD_SUB    3'b000 // ADD/SUB (OP)
`define FUNCT3_SLLI       3'b001 // SLLI (OP_IMM)
`define FUNCT3_SLL        3'b001 // SLL (OP)
`define FUNCT3_SLTI       3'b010 // SLTI (OP_IMM)
`define FUNCT3_SLT        3'b010 // SLT (OP)
`define FUNCT3_SLTIU      3'b011 // SLTIU (OP_IMM)
`define FUNCT3_SLTU       3'b011 // SLTU (OP)
`define FUNCT3_XORI       3'b100 // XORI (OP_IMM)
`define FUNCT3_XOR        3'b100 // XOR (OP)
`define FUNCT3_SRLI_SRAI  3'b101 // SRLI/SRAI (OP_IMM) - Distinguish by funct7
`define FUNCT3_SRL_SRA    3'b101 // SRL/SRA (OP)     - Distinguish by funct7
`define FUNCT3_ORI        3'b110 // ORI (OP_IMM)
`define FUNCT3_OR         3'b110 // OR (OP)
`define FUNCT3_ANDI       3'b111 // ANDI (OP_IMM)
`define FUNCT3_AND        3'b111 // AND (OP)

// For BRANCH
`define FUNCT3_BEQ        3'b000
`define FUNCT3_BNE        3'b001
`define FUNCT3_BLT        3'b100
`define FUNCT3_BGE        3'b101
`define FUNCT3_BLTU       3'b110
`define FUNCT3_BGEU       3'b111

// For LOAD
`define FUNCT3_LB         3'b000
`define FUNCT3_LH         3'b001
`define FUNCT3_LW         3'b010
`define FUNCT3_LD         3'b011 // RV64
`define FUNCT3_LBU        3'b100
`define FUNCT3_LHU        3'b101
`define FUNCT3_LWU        3'b110 // RV64

// For STORE
`define FUNCT3_SB         3'b000
`define FUNCT3_SH         3'b001
`define FUNCT3_SW         3'b010
`define FUNCT3_SD         3'b011 // RV64

// For JALR
`define FUNCT3_JALR       3'b000

// Funct7 codes (or relevant bits)
// For ADD/SUB and SRA/SRL distinction in OP and OP_IMM type instructions.
// For R-type (OP) and I-type shifts (OP_IMM), bit 5 of funct7 (instr[30]) is often used.
`define FUNCT7_5_SUB_ALT  1'b1 // For SUB, SRA, SRAI (funct7[5])
`define FUNCT7_5_ADD_MAIN 1'b0 // For ADD, SRL, SRLI (funct7[5])
// `define FUNCT7_SRL        7'b0000000 (SRL, SRLI, SRLW, SRLIW)
// `define FUNCT7_SRA        7'b0100000 (SRA, SRAI, SRAW, SRAIW)
// `define FUNCT7_ADD        7'b0000000
// `define FUNCT7_SUB        7'b0100000

`endif // RISCV_OPCODES_SVH


--- File: rtl/common/defines.svh ---
`ifndef COMMON_DEFINES_SVH
`define COMMON_DEFINES_SVH

`define DATA_WIDTH 64
`define INSTR_WIDTH 32
`define REG_ADDR_WIDTH 5

`endif


--- File: rtl/common/immediate_types.svh ---
// rtl/common/immediate_types.svh
`ifndef IMMEDIATE_TYPES_SVH
`define IMMEDIATE_TYPES_SVH

// Enum for selecting immediate type in immediate_generator
// This allows the control unit to specify exactly which format to use.
typedef enum logic [2:0] {
    IMM_TYPE_NONE, // For R-type or when immediate is not used by ALU operand B or for address calculation
    IMM_TYPE_I,    // I-type (ADDI, LW, JALR)
    IMM_TYPE_S,    // S-type (SW)
    IMM_TYPE_B,    // B-type (Branches)
    IMM_TYPE_U,    // U-type (LUI, AUIPC)
    IMM_TYPE_J,     // J-type (JAL)
    IMM_TYPE_ISHIFT // Новый тип для SLLI, SRLI, SRAI
} immediate_type_e;

`endif // IMMEDIATE_TYPES_SVH


--- File: rtl/common/alu_defines.svh ---
// rtl/common/alu_defines.svh
`ifndef ALU_DEFINES_SVH
`define ALU_DEFINES_SVH

`define ALU_CONTROL_WIDTH 4 // Needs 4 bits for ~10 operations

// Unified ALU Control Signals
// R-Type / I-Type Arithmetic
`define ALU_OP_ADD  4'b0000 // Addition
`define ALU_OP_SUB  4'b0001 // Subtraction
`define ALU_OP_SLL  4'b0010 // Shift Left Logical
`define ALU_OP_SLT  4'b0011 // Set Less Than (Signed)
`define ALU_OP_SLTU 4'b0100 // Set Less Than (Unsigned)
`define ALU_OP_XOR  4'b0101 // XOR
`define ALU_OP_SRL  4'b0110 // Shift Right Logical
`define ALU_OP_SRA  4'b0111 // Shift Right Arithmetic
`define ALU_OP_OR   4'b1000 // OR
`define ALU_OP_AND  4'b1001 // AND

// Potentially other operations for specific instructions if needed, e.g., pass Operand B
// `define ALU_OP_PASS_B 4'b1010 // Pass operand_b directly (e.g., for LUI if srcA is 0)
// For LUI, it's rd = imm. If ALU is used, srcA=0, srcB=imm, op=ADD. So ALU_OP_ADD works.
// For AUIPC, it's rd = pc + imm. srcA=PC, srcB=imm, op=ADD. So ALU_OP_ADD works.

`endif // ALU_DEFINES_SVH


--- File: rtl/core/control_unit.sv ---
// rtl/core/control_unit.sv
`include "common/defines.svh"
`include "common/alu_defines.svh"
`include "common/immediate_types.svh"
`include "common/riscv_opcodes.svh"
`include "common/control_signals_defines.svh" // New include

module control_unit (
    // Inputs from instruction
    input  logic [6:0] op,
    input  logic [2:0] funct3,
    input  logic       funct7_5,

    // Outputs: Control signals
    output logic       reg_write_d_o,
    output logic [1:0] result_src_d_o,
    output logic       mem_write_d_o,
    output logic       jump_d_o,
    output logic       branch_d_o,
    output logic       alu_src_d_o,      // Selects ALU operand B (Reg vs Imm)
    output logic [`ALU_CONTROL_WIDTH-1:0] alu_control_d_o,
    output immediate_type_e imm_type_d_o,
    output logic [2:0] funct3_d_o,             // Pass funct3 for branch logic in EX & mem access type in MEM
    output alu_a_src_sel_e op_a_sel_d_o,        // Selects ALU operand A source
    output pc_target_src_sel_e pc_target_src_sel_d_o // Selects PC target source for EX
);

    // Pass funct3 directly as it's needed in later stages
    assign funct3_d_o = funct3;

    always_comb begin
        // Initialize signals to a known "safe" or default state for each instruction type
        reg_write_d_o   = 1'b0;
        result_src_d_o  = 2'b00; // Default: Result from ALU
        mem_write_d_o   = 1'b0;
        jump_d_o        = 1'b0;
        branch_d_o      = 1'b0;
        alu_src_d_o     = 1'b0; // Default: ALU Operand B from Register File (rs2)
        alu_control_d_o = `ALU_OP_ADD; // Default ALU operation
        imm_type_d_o    = IMM_TYPE_NONE;
        op_a_sel_d_o    = ALU_A_SRC_RS1; // Default
        pc_target_src_sel_d_o = PC_TARGET_SRC_PC_PLUS_IMM; // Default

        case (op)
            `OPCODE_LUI: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b1; // Imm for OpB
                imm_type_d_o    = IMM_TYPE_U;
                op_a_sel_d_o    = ALU_A_SRC_ZERO; // ALU OpA = 0
                alu_control_d_o = `ALU_OP_ADD;    // ALU = 0 + Imm
                result_src_d_o  = 2'b00;
            end
            `OPCODE_AUIPC: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b1; // Imm for OpB
                imm_type_d_o    = IMM_TYPE_U;
                op_a_sel_d_o    = ALU_A_SRC_PC;   // ALU OpA = PC
                alu_control_d_o = `ALU_OP_ADD;    // ALU = PC + Imm
                result_src_d_o  = 2'b00;
            end
            `OPCODE_JAL: begin
                reg_write_d_o   = 1'b1;
                jump_d_o        = 1'b1;
                imm_type_d_o    = IMM_TYPE_J;
                result_src_d_o  = 2'b10;      // rd = PC+4
                pc_target_src_sel_d_o = PC_TARGET_SRC_PC_PLUS_IMM; // Target = PC + ImmJ
                // ALU might be idle or used by a separate adder for PC+Imm.
                // To keep ALU control consistent if it *were* used for target:
                op_a_sel_d_o    = ALU_A_SRC_PC; // If ALU calculated PC+ImmJ
                alu_src_d_o     = 1'b1;
                alu_control_d_o = `ALU_OP_ADD;
            end
            `OPCODE_JALR: begin
                reg_write_d_o   = 1'b1;
                jump_d_o        = 1'b1;
                alu_src_d_o     = 1'b1; // Imm for OpB
                imm_type_d_o    = IMM_TYPE_I;
                op_a_sel_d_o    = ALU_A_SRC_RS1;  // ALU OpA = RS1
                alu_control_d_o = `ALU_OP_ADD;    // ALU = RS1 + Imm (for target calculation)
                result_src_d_o  = 2'b10;      // rd = PC+4
                pc_target_src_sel_d_o = PC_TARGET_SRC_ALU_JALR; // Target from ALU result & ~1
            end
            `OPCODE_BRANCH: begin
                branch_d_o      = 1'b1;
                alu_src_d_o     = 1'b0; // OpB = RS2 for comparison
                op_a_sel_d_o    = ALU_A_SRC_RS1; // OpA = RS1 for comparison
                imm_type_d_o    = IMM_TYPE_B;    // For PC + ImmB target calculation
                reg_write_d_o   = 1'b0;
                pc_target_src_sel_d_o = PC_TARGET_SRC_PC_PLUS_IMM; // Target is PC+ImmB
                case (funct3)
                    `FUNCT3_BEQ:  alu_control_d_o = `ALU_OP_SUB;
                    `FUNCT3_BNE:  alu_control_d_o = `ALU_OP_SUB;
                    `FUNCT3_BLT:  alu_control_d_o = `ALU_OP_SLT;
                    `FUNCT3_BGE:  alu_control_d_o = `ALU_OP_SLT;
                    `FUNCT3_BLTU: alu_control_d_o = `ALU_OP_SLTU;
                    `FUNCT3_BGEU: alu_control_d_o = `ALU_OP_SLTU;
                    default:      alu_control_d_o = `ALU_OP_ADD; // Or some invalid op
                endcase
            end
            `OPCODE_LOAD: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b1; // Imm for OpB (offset)
                imm_type_d_o    = IMM_TYPE_I;
                op_a_sel_d_o    = ALU_A_SRC_RS1;  // OpA = RS1 (base address)
                alu_control_d_o = `ALU_OP_ADD;    // ALU = RS1 + offset (address calculation)
                result_src_d_o  = 2'b01;      // Result from Memory
                mem_write_d_o   = 1'b0;
            end
            `OPCODE_STORE: begin
                alu_src_d_o     = 1'b1; // Imm for OpB (offset)
                imm_type_d_o    = IMM_TYPE_S;
                op_a_sel_d_o    = ALU_A_SRC_RS1;  // OpA = RS1 (base address)
                alu_control_d_o = `ALU_OP_ADD;    // ALU = RS1 + offset (address calculation)
                mem_write_d_o   = 1'b1;
                reg_write_d_o   = 1'b0;
            end
            `OPCODE_OP_IMM: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b1; // Imm for OpB
                imm_type_d_o    = (funct3 == `FUNCT3_SLLI || funct3 == `FUNCT3_SRLI_SRAI) ? IMM_TYPE_ISHIFT : IMM_TYPE_I;
                op_a_sel_d_o    = ALU_A_SRC_RS1;
                result_src_d_o  = 2'b00;
                case (funct3)
                    `FUNCT3_ADDI:  alu_control_d_o = `ALU_OP_ADD;
                    `FUNCT3_SLTI:  alu_control_d_o = `ALU_OP_SLT;
                    `FUNCT3_SLTIU: alu_control_d_o = `ALU_OP_SLTU;
                    `FUNCT3_XORI:  alu_control_d_o = `ALU_OP_XOR;
                    `FUNCT3_ORI:   alu_control_d_o = `ALU_OP_OR;
                    `FUNCT3_ANDI:  alu_control_d_o = `ALU_OP_AND;
                    `FUNCT3_SLLI:  alu_control_d_o = `ALU_OP_SLL;
                    `FUNCT3_SRLI_SRAI: begin
                        if (funct7_5 == `FUNCT7_5_SUB_ALT) alu_control_d_o = `ALU_OP_SRA;
                        else                               alu_control_d_o = `ALU_OP_SRL;
                    end
                    default:       alu_control_d_o = `ALU_OP_ADD;
                endcase
            end
            `OPCODE_OP: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b0; // OpB = RS2
                op_a_sel_d_o    = ALU_A_SRC_RS1; // OpA = RS1
                imm_type_d_o    = IMM_TYPE_NONE;
                result_src_d_o  = 2'b00;
                case (funct3)
                    `FUNCT3_ADD_SUB: begin
                        if (funct7_5 == `FUNCT7_5_SUB_ALT) alu_control_d_o = `ALU_OP_SUB;
                        else                               alu_control_d_o = `ALU_OP_ADD;
                    end
                    `FUNCT3_SLL:   alu_control_d_o = `ALU_OP_SLL;
                    `FUNCT3_SLT:   alu_control_d_o = `ALU_OP_SLT;
                    `FUNCT3_SLTU:  alu_control_d_o = `ALU_OP_SLTU;
                    `FUNCT3_XOR:   alu_control_d_o = `ALU_OP_XOR;
                    `FUNCT3_SRL_SRA: begin
                        if (funct7_5 == `FUNCT7_5_SUB_ALT) alu_control_d_o = `ALU_OP_SRA;
                        else                               alu_control_d_o = `ALU_OP_SRL;
                    end
                    `FUNCT3_OR:    alu_control_d_o = `ALU_OP_OR;
                    `FUNCT3_AND:   alu_control_d_o = `ALU_OP_AND;
                    default:       alu_control_d_o = `ALU_OP_ADD;
                endcase
            end
            default: begin // NOP / Unknown
                // Default assignments from above cover this
            end
        endcase
    end
endmodule


--- File: rtl/core/ex_mem_register ---
// rtl/core/ex_mem_register.sv
`include "common/defines.svh"
// `include "common/alu_defines.svh" // Not strictly needed here

module ex_mem_register (
    input  logic clk,
    input  logic rst_n,

    // Inputs from Execute Stage
    input  logic       reg_write_e_i,
    input  logic [1:0] result_src_e_i,
    input  logic       mem_write_e_i,
    input  logic [`DATA_WIDTH-1:0] alu_result_e_i,
    input  logic [`DATA_WIDTH-1:0] rs2_data_e_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_e_i,
    input  logic [`DATA_WIDTH-1:0] pc_plus_4_e_i,
// change start
    input  logic [2:0] funct3_e_i,         // Input for pipelined funct3
// change end

    // Outputs to Memory Stage
    output logic       reg_write_m_o,
    output logic [1:0] result_src_m_o,
    output logic       mem_write_m_o,
    output logic [`DATA_WIDTH-1:0] alu_result_m_o,
    output logic [`DATA_WIDTH-1:0] rs2_data_m_o,
    output logic [`REG_ADDR_WIDTH-1:0] rd_addr_m_o,
    output logic [`DATA_WIDTH-1:0] pc_plus_4_m_o,
// change start
    output logic [2:0] funct3_m_o          // Output for pipelined funct3
// change end
);

    localparam CTL_NOP_REG_WRITE  = 1'b0;
    localparam CTL_NOP_MEM_WRITE  = 1'b0;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            reg_write_m_o    <= CTL_NOP_REG_WRITE;
            result_src_m_o   <= 2'b00;
            mem_write_m_o    <= CTL_NOP_MEM_WRITE;
            alu_result_m_o   <= {`DATA_WIDTH{1'b0}};
            rs2_data_m_o     <= {`DATA_WIDTH{1'b0}};
            rd_addr_m_o      <= {`REG_ADDR_WIDTH{1'b0}};
            pc_plus_4_m_o    <= {`DATA_WIDTH{1'b0}};
// change start
            funct3_m_o       <= 3'b000;
// change end
        end else begin
            reg_write_m_o    <= reg_write_e_i;
            result_src_m_o   <= result_src_e_i;
            mem_write_m_o    <= mem_write_e_i;
            alu_result_m_o   <= alu_result_e_i;
            rs2_data_m_o     <= rs2_data_e_i;
            rd_addr_m_o      <= rd_addr_e_i;
            pc_plus_4_m_o    <= pc_plus_4_e_i;
// change start
            funct3_m_o       <= funct3_e_i;
// change end
        end
    end
endmodule


--- File: rtl/core/alu.sv ---
// rtl/core/alu.sv
`include "common/defines.svh"
`include "common/alu_defines.svh" // Will use new defines

module alu (
    input  logic [`DATA_WIDTH-1:0]     operand_a,
    input  logic [`DATA_WIDTH-1:0]     operand_b,
    input  logic [`ALU_CONTROL_WIDTH-1:0] alu_control, // Unified control signal
    output logic [`DATA_WIDTH-1:0]     result,
    output logic                       zero_flag
);

    logic [`DATA_WIDTH-1:0] result_comb;
    logic [5:0]             shift_amount; // For RV64, shift by lower 6 bits of operand_b

    assign shift_amount = operand_b[5:0];

    always_comb begin
        result_comb = {`DATA_WIDTH{1'bx}}; // Default to 'x'

        case (alu_control)
            `ALU_OP_ADD:  result_comb = operand_a + operand_b;
            `ALU_OP_SUB:  result_comb = operand_a - operand_b;
            `ALU_OP_SLL:  result_comb = operand_a << shift_amount;
            `ALU_OP_SLT:  result_comb = ($signed(operand_a) < $signed(operand_b)) ? {{`DATA_WIDTH-1{1'b0}}, 1'b1} : {`DATA_WIDTH{1'b0}};
            `ALU_OP_SLTU: result_comb = (operand_a < operand_b) ? {{`DATA_WIDTH-1{1'b0}}, 1'b1} : {`DATA_WIDTH{1'b0}};
            `ALU_OP_XOR:  result_comb = operand_a ^ operand_b;
            `ALU_OP_SRL:  result_comb = operand_a >> shift_amount;
            `ALU_OP_SRA:  result_comb = $signed(operand_a) >>> shift_amount;
            `ALU_OP_OR:   result_comb = operand_a | operand_b;
            `ALU_OP_AND:  result_comb = operand_a & operand_b;
            // `ALU_OP_PASS_B: result_comb = operand_b; // If we had this explicit op
            default:      result_comb = {`DATA_WIDTH{1'bx}}; // Undefined operation
        endcase
    end

    assign result = result_comb;
    assign zero_flag = (result_comb == {`DATA_WIDTH{1'b0}});

endmodule


--- File: rtl/core/memory_stage.sv ---
// rtl/core/memory.sv (Memory Stage Logic)
`include "common/defines.svh"

module memory_stage ( // Changed module name to memory_stage to avoid conflict with data_memory if in same scope
    input  logic clk,
    input  logic rst_n,

    // Inputs from EX/MEM Register
    input  logic       reg_write_m_i,
    input  logic [1:0] result_src_m_i, // 00:ALU, 01:MemRead, 10:PC+4
    input  logic       mem_write_m_i,    // Enable for data memory write
    input  logic [2:0] funct3_m_i,       // For load/store type

    input  logic [`DATA_WIDTH-1:0]     alu_result_m_i, // Address for memory or result from ALU
    input  logic [`DATA_WIDTH-1:0]     rs2_data_m_i,   // Data to store in memory
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_m_i,
    input  logic [`DATA_WIDTH-1:0]     pc_plus_4_m_i,

    // Outputs to MEM/WB Register
    output logic       reg_write_w_o,
    output logic [1:0] result_src_w_o,
    // mem_write is consumed here

    output logic [`DATA_WIDTH-1:0]     read_data_w_o,  // Data read from memory
    output logic [`DATA_WIDTH-1:0]     alu_result_w_o, // ALU result passed through
    output logic [`REG_ADDR_WIDTH-1:0] rd_addr_w_o,
    output logic [`DATA_WIDTH-1:0]     pc_plus_4_w_o
);

    logic [`DATA_WIDTH-1:0] mem_read_data_internal;

    // Data Memory Instance
    data_memory u_data_memory (
        .clk            (clk),
        .rst_n          (rst_n),
        .addr_i         (alu_result_m_i),   // Address is ALU result
        .write_data_i   (rs2_data_m_i),     // Data to write is from rs2
        .mem_write_en_i (mem_write_m_i),    // Write enable
        .funct3_i       (funct3_m_i),       // For store type (SB/SH/SW/SD) and load type
        .read_data_o    (mem_read_data_internal) // Data read
    );

    // Pass through control signals
    assign reg_write_w_o  = reg_write_m_i;
    assign result_src_w_o = result_src_m_i;

    // Pass through data
    assign read_data_w_o  = mem_read_data_internal;
    assign alu_result_w_o = alu_result_m_i;
    assign rd_addr_w_o    = rd_addr_m_i;
    assign pc_plus_4_w_o  = pc_plus_4_m_i;

endmodule


--- File: rtl/core/memory.sv ---



--- File: rtl/core/fetch.sv ---
`include "common/defines.svh"

module fetch (
    input  logic clk,
    input  logic rst_n,

    // Control signals from Hazard Unit / Execute Stage
    input  logic                       stall_f,     // Stall PC and instruction fetch
    input  logic                       pc_src_e,    // Selects PC source (PC+4 or branch/jump target)
    input  logic [`DATA_WIDTH-1:0]     pc_target_e, // Branch/jump target address from EX stage

    // Outputs to IF/ID pipeline register
    output logic [`INSTR_WIDTH-1:0]    instr_f_o,
    output logic [`DATA_WIDTH-1:0]     pc_plus_4_f_o,
    output logic [`DATA_WIDTH-1:0]     pc_f_o          // Current PC fetched
);

    logic [`DATA_WIDTH-1:0] pc_reg;
    logic [`DATA_WIDTH-1:0] pc_next;
    logic [`DATA_WIDTH-1:0] pc_plus_4_temp;

    // Instruction Memory instance
    instruction_memory i_instr_mem (
        .address     (pc_reg),
        .instruction (instr_f_o)
    );

    // Adder for PC + 4
    assign pc_plus_4_temp = pc_reg + 4;

    // MUX for next PC selection
    assign pc_next = pc_src_e ? pc_target_e : pc_plus_4_temp;

    // PC Register
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            pc_reg <= {`DATA_WIDTH{1'b0}}; // Reset PC to 0
        end else if (!stall_f) begin // If not stalled, update PC
            pc_reg <= pc_next;
        end
        // If stalled (stall_f = 1), PC holds its value
    end

    assign pc_plus_4_f_o = pc_plus_4_temp;
    assign pc_f_o        = pc_reg; // Output current PC

endmodule


--- File: rtl/core/mem_wb_register.sv ---
// rtl/core/mem_wb_register.sv
`include "common/defines.svh"

module mem_wb_register (
    input  logic clk,
    input  logic rst_n,

    // Inputs from Memory Stage
    input  logic       reg_write_m_i,    // RegWriteW on diagram
    input  logic [1:0] result_src_m_i,   // ResultSrcW on diagram

    input  logic [`DATA_WIDTH-1:0]     read_data_m_i,  // ReadDataW on diagram
    input  logic [`DATA_WIDTH-1:0]     alu_result_m_i, // ALUResultW (passed from EX/MEM to MEM/WB)
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_m_i,    // RdW on diagram
    input  logic [`DATA_WIDTH-1:0]     pc_plus_4_m_i,  // PCPlus4W on diagram

    // Outputs to Writeback Stage
    output logic       reg_write_wb_o,
    output logic [1:0] result_src_wb_o,

    output logic [`DATA_WIDTH-1:0]     read_data_wb_o,
    output logic [`DATA_WIDTH-1:0]     alu_result_wb_o,
    output logic [`REG_ADDR_WIDTH-1:0] rd_addr_wb_o,
    output logic [`DATA_WIDTH-1:0]     pc_plus_4_wb_o
);

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            reg_write_wb_o  <= 1'b0;
            result_src_wb_o <= 2'b00; // Default to ALUResult path

            read_data_wb_o  <= {`DATA_WIDTH{1'b0}};
            alu_result_wb_o <= {`DATA_WIDTH{1'b0}};
            rd_addr_wb_o    <= {`REG_ADDR_WIDTH{1'b0}};
            pc_plus_4_wb_o  <= {`DATA_WIDTH{1'b0}};
        end else begin
            // No stall/flush inputs to this register in the P&H diagram for simplicity
            // Stalls usually handled before EX, flushes clear earlier stages.
            reg_write_wb_o  <= reg_write_m_i;
            result_src_wb_o <= result_src_m_i;

            read_data_wb_o  <= read_data_m_i;
            alu_result_wb_o <= alu_result_m_i;
            rd_addr_wb_o    <= rd_addr_m_i;
            pc_plus_4_wb_o  <= pc_plus_4_m_i;
        end
    end
endmodule


--- File: rtl/core/id_ex_register.sv ---
// rtl/core/id_ex_register.sv
`include "common/defines.svh"
`include "common/alu_defines.svh"
`include "common/control_signals_defines.svh" // New include

module id_ex_register (
    input  logic clk,
    input  logic rst_n,

    input  logic stall_e,
    input  logic flush_e,

    // Inputs from Decode Stage
    input  logic       reg_write_d_i,
    input  logic [1:0] result_src_d_i,
    input  logic       mem_write_d_i,
    input  logic       jump_d_i,
    input  logic       branch_d_i,
    input  logic       alu_src_d_i,
    input  logic [`ALU_CONTROL_WIDTH-1:0] alu_control_d_i,
    input  logic [2:0] funct3_d_i,
    input  alu_a_src_sel_e op_a_sel_d_i,
    input  pc_target_src_sel_e pc_target_src_sel_d_i,

    input  logic [`DATA_WIDTH-1:0]  pc_d_i,
    input  logic [`DATA_WIDTH-1:0]  pc_plus_4_d_i,
    input  logic [`DATA_WIDTH-1:0]  rs1_data_d_i,
    input  logic [`DATA_WIDTH-1:0]  rs2_data_d_i,
    input  logic [`DATA_WIDTH-1:0]  imm_ext_d_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rs1_addr_d_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rs2_addr_d_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_d_i,

    // Outputs to Execute Stage
    output logic       reg_write_e_o,
    output logic [1:0] result_src_e_o,
    output logic       mem_write_e_o,
    output logic       jump_e_o,
    output logic       branch_e_o,
    output logic       alu_src_e_o,
    output logic [`ALU_CONTROL_WIDTH-1:0] alu_control_e_o,
    output logic [2:0] funct3_e_o,
    output alu_a_src_sel_e op_a_sel_e_o,
    output pc_target_src_sel_e pc_target_src_sel_e_o,

    output logic [`DATA_WIDTH-1:0]  pc_e_o,
    output logic [`DATA_WIDTH-1:0]  pc_plus_4_e_o,
    output logic [`DATA_WIDTH-1:0]  rs1_data_e_o,
    output logic [`DATA_WIDTH-1:0]  rs2_data_e_o,
    output logic [`DATA_WIDTH-1:0]  imm_ext_e_o,
    output logic [`REG_ADDR_WIDTH-1:0] rs1_addr_e_o,
    output logic [`REG_ADDR_WIDTH-1:0] rs2_addr_e_o,
    output logic [`REG_ADDR_WIDTH-1:0] rd_addr_e_o
);

    localparam CTL_NOP_REG_WRITE  = 1'b0;
    localparam CTL_NOP_MEM_WRITE  = 1'b0;
    localparam CTL_NOP_JUMP       = 1'b0;
    localparam CTL_NOP_BRANCH     = 1'b0;
    localparam CTL_NOP_ALU_SRC    = 1'b0;
    localparam CTL_NOP_ALU_CTRL   = `ALU_OP_ADD;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            reg_write_e_o    <= CTL_NOP_REG_WRITE;
            result_src_e_o   <= 2'b00;
            mem_write_e_o    <= CTL_NOP_MEM_WRITE;
            jump_e_o         <= CTL_NOP_JUMP;
            branch_e_o       <= CTL_NOP_BRANCH;
            alu_src_e_o      <= CTL_NOP_ALU_SRC;
            alu_control_e_o  <= CTL_NOP_ALU_CTRL;
            funct3_e_o       <= 3'b000;
            op_a_sel_e_o     <= ALU_A_SRC_RS1;
            pc_target_src_sel_e_o <= PC_TARGET_SRC_PC_PLUS_IMM;

            pc_e_o           <= {`DATA_WIDTH{1'b0}};
            pc_plus_4_e_o    <= {`DATA_WIDTH{1'b0}};
            rs1_data_e_o     <= {`DATA_WIDTH{1'b0}};
            rs2_data_e_o     <= {`DATA_WIDTH{1'b0}};
            imm_ext_e_o      <= {`DATA_WIDTH{1'b0}};
            rs1_addr_e_o     <= {`REG_ADDR_WIDTH{1'b0}};
            rs2_addr_e_o     <= {`REG_ADDR_WIDTH{1'b0}};
            rd_addr_e_o      <= {`REG_ADDR_WIDTH{1'b0}};
        end else if (flush_e) begin
            reg_write_e_o    <= CTL_NOP_REG_WRITE;
            result_src_e_o   <= 2'b00;
            mem_write_e_o    <= CTL_NOP_MEM_WRITE;
            jump_e_o         <= CTL_NOP_JUMP;
            branch_e_o       <= CTL_NOP_BRANCH;
            alu_src_e_o      <= CTL_NOP_ALU_SRC;
            alu_control_e_o  <= CTL_NOP_ALU_CTRL;
            funct3_e_o       <= 3'b000;
            op_a_sel_e_o     <= ALU_A_SRC_RS1;
            pc_target_src_sel_e_o <= PC_TARGET_SRC_PC_PLUS_IMM;

            // Data fields are also NOP'd or zeroed
            pc_e_o           <= {`DATA_WIDTH{1'b0}};
            pc_plus_4_e_o    <= {`DATA_WIDTH{1'b0}};
            rs1_data_e_o     <= {`DATA_WIDTH{1'b0}};
            rs2_data_e_o     <= {`DATA_WIDTH{1'b0}};
            imm_ext_e_o      <= {`DATA_WIDTH{1'b0}};
            rs1_addr_e_o     <= {`REG_ADDR_WIDTH{1'b0}};
            rs2_addr_e_o     <= {`REG_ADDR_WIDTH{1'b0}};
            rd_addr_e_o      <= {`REG_ADDR_WIDTH{1'b0}};
        end else if (!stall_e) begin
            reg_write_e_o    <= reg_write_d_i;
            result_src_e_o   <= result_src_d_i;
            mem_write_e_o    <= mem_write_d_i;
            jump_e_o         <= jump_d_i;
            branch_e_o       <= branch_d_i;
            alu_src_e_o      <= alu_src_d_i;
            alu_control_e_o  <= alu_control_d_i;
            funct3_e_o       <= funct3_d_i;
            op_a_sel_e_o     <= op_a_sel_d_i;
            pc_target_src_sel_e_o <= pc_target_src_sel_d_i;

            pc_e_o           <= pc_d_i;
            pc_plus_4_e_o    <= pc_plus_4_d_i;
            rs1_data_e_o     <= rs1_data_d_i;
            rs2_data_e_o     <= rs2_data_d_i;
            imm_ext_e_o      <= imm_ext_d_i;
            rs1_addr_e_o     <= rs1_addr_d_i;
            rs2_addr_e_o     <= rs2_addr_d_i;
            rd_addr_e_o      <= rd_addr_d_i;
        end
        // If stalled (stall_e = 1) and not flushed, register holds its value
    end
endmodule


--- File: rtl/core/pipeline_control.sv ---



--- File: rtl/core/if_id_register.sv ---
`include "common/defines.svh"

module if_id_register (
    input  logic clk,
    input  logic rst_n,

    // Control signals from Hazard Unit
    input  logic stall_d, // Stall: keeps current values
    input  logic flush_d, // Flush: clears register (outputs NOP-like values)

    // Data inputs from Fetch Stage
    input  logic [`INSTR_WIDTH-1:0] instr_f_i,
    input  logic [`DATA_WIDTH-1:0]  pc_plus_4_f_i,
    input  logic [`DATA_WIDTH-1:0]  pc_f_i,          // Current PC from Fetch

    // Data outputs to Decode Stage
    output logic [`INSTR_WIDTH-1:0] instr_id_o,
    output logic [`DATA_WIDTH-1:0]  pc_plus_4_id_o,
    output logic [`DATA_WIDTH-1:0]  pc_id_o           // Current PC to Decode
);

    // NOP instruction (addi x0, x0, 0) for RISC-V
    localparam NOP_INSTRUCTION = `INSTR_WIDTH'h00000013;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            instr_id_o     <= NOP_INSTRUCTION;
            pc_plus_4_id_o <= {`DATA_WIDTH{1'b0}};
            pc_id_o        <= {`DATA_WIDTH{1'b0}};
        end else if (flush_d) begin
            instr_id_o     <= NOP_INSTRUCTION; // Flush with NOP
            pc_plus_4_id_o <= {`DATA_WIDTH{1'b0}}; // Or a defined "safe" PC+4
            pc_id_o        <= {`DATA_WIDTH{1'b0}}; // Or a defined "safe" PC
        end else if (!stall_d) begin // If not stalled and not flushed, pass inputs
            instr_id_o     <= instr_f_i;
            pc_plus_4_id_o <= pc_plus_4_f_i;
            pc_id_o        <= pc_f_i;
        end
        // If stalled (stall_d = 1) and not flushed, register holds its value
    end

endmodule


--- File: rtl/core/data_memory.sv ---
// rtl/core/data_memory.sv
`include "common/defines.svh"
`include "common/riscv_opcodes.svh" // For FUNCT3 defines (LB, LH, LW, etc.)

module data_memory (
    input  logic clk,
    input  logic rst_n,

    input  logic [`DATA_WIDTH-1:0]     addr_i,        // Address from ALU result
    input  logic [`DATA_WIDTH-1:0]     write_data_i,  // Data from RS2 (for stores)
    input  logic                       mem_write_en_i,  // From MemWriteM control signal
    input  logic [2:0]                 funct3_i,      // To determine load/store type (size and sign)

    output logic [`DATA_WIDTH-1:0]     read_data_o    // Data read from memory (for loads)
);

    // Parameter for memory size (e.g., 2^10 = 1024 words of 64-bit)
    // Addresses are byte addresses.
    localparam MEM_ADDR_BITS = 10; // For 1KB of byte-addressable memory (2^10 bytes)
    localparam MEM_SIZE_BYTES = 1 << MEM_ADDR_BITS;
    localparam MEM_SIZE_WORDS = MEM_SIZE_BYTES / (`DATA_WIDTH/8);

    // Byte-addressable memory array. Each element is a byte.
    logic [7:0] mem [MEM_SIZE_BYTES-1:0];

    // For faster simulation, Verilator might prefer word-oriented memory if operations are word-aligned
    // but byte-addressable is more general for LB/SB etc.

    // Read logic (combinational read based on address)
    // Handles different load types based on funct3
    logic [`DATA_WIDTH-1:0] read_data_aligned;
    always_comb begin
        // Default to 'x' or 0 if address is out of bounds (not explicitly handled here for simplicity)
        read_data_aligned = `DATA_WIDTH'('x);
        if (addr_i < MEM_SIZE_BYTES) begin
            // Read a full 64-bit word aligned to 8 bytes for simplicity first
            // This assumes addr_i is mostly aligned for LW/LD. Unaligned access is complex.
            // For byte/half access, we need to pick correct bytes from the word.
            // Let's read the 8 bytes starting at the (potentially unaligned) address.
            // This is a simplification; real unaligned access is more involved.
            // We'll handle alignment and byte picking for loads.
            // For simplicity, assume addr_i is aligned for word/double-word access.
            // For byte/half, addr_i can be unaligned within the word.

            // Construct the 64-bit value from individual bytes
            // This handles potential unaligned reads across word boundaries if MEM_SIZE_BYTES is large enough
            // and if addr_i + 7 does not exceed MEM_SIZE_BYTES-1.
            // For simplicity, let's assume we read an aligned 64-bit word first, then extract.
            logic [`DATA_WIDTH-1:0] fetched_word;
            logic [2:0] byte_offset_in_word = addr_i[2:0]; // Lower 3 bits for byte offset within a 64-bit word

            // Read the 8 bytes that form the 64-bit chunk containing addr_i
            // This is still a simplification, proper unaligned access over physical memory is hard
            for (int i = 0; i < (`DATA_WIDTH/8); i++) begin
                if ((addr_i + i) < MEM_SIZE_BYTES) begin
                    fetched_word[i*8 +: 8] = mem[addr_i + i];
                end else {
                    fetched_word[i*8 +: 8] = 8'hXX; // Out of bounds byte
                }
            end
            // The above loop is not quite right for constructing the word based on addr_i alignment
            // Let's re-think: fetch the aligned word, then select based on offset and funct3.
            logic [`DATA_WIDTH-1:0] aligned_word_read;
            logic [`DATA_WIDTH-1:0] temp_read_data = `DATA_WIDTH'('x);
            logic [MEM_ADDR_BITS-1:3] word_addr_idx = addr_i[`MEM_ADDR_BITS-1:3]; // Index for 64-bit words if mem was word array

            // More correct byte-wise construction for an aligned read:
            for (int i = 0; i < (`DATA_WIDTH/8); i++) begin
                 // addr_i & ~7 ensures we start at an 8-byte boundary for the read
                if (( (addr_i & ~(`DATA_WIDTH/8 - 1)) + i) < MEM_SIZE_BYTES) begin
                    aligned_word_read[(i*8) +: 8] = mem[(addr_i & ~(`DATA_WIDTH/8 - 1)) + i];
                end else begin
                    aligned_word_read[(i*8) +: 8] = 8'hXX;
                end
            end


            case (funct3_i)
                `FUNCT3_LB: begin // Load Byte (signed)
                    temp_read_data = {{(`DATA_WIDTH-8){aligned_word_read[byte_offset_in_word*8 + 7]}}, aligned_word_read[byte_offset_in_word*8 +: 8]};
                end
                `FUNCT3_LH: begin // Load Half-word (signed)
                    temp_read_data = {{(`DATA_WIDTH-16){aligned_word_read[byte_offset_in_word*8 + 15]}}, aligned_word_read[byte_offset_in_word*8 +: 16]};
                end
                `FUNCT3_LW: begin // Load Word (signed, 32-bit)
                    temp_read_data = {{(`DATA_WIDTH-32){aligned_word_read[byte_offset_in_word*8 + 31]}}, aligned_word_read[byte_offset_in_word*8 +: 32]};
                end
                `FUNCT3_LD: begin // Load Double-word (64-bit)
                    temp_read_data = aligned_word_read; // Assumes addr_i is 8-byte aligned for LD
                end
                `FUNCT3_LBU: begin // Load Byte (unsigned)
                    temp_read_data = {{(`DATA_WIDTH-8){1'b0}}, aligned_word_read[byte_offset_in_word*8 +: 8]};
                end
                `FUNCT3_LHU: begin // Load Half-word (unsigned)
                    temp_read_data = {{(`DATA_WIDTH-16){1'b0}}, aligned_word_read[byte_offset_in_word*8 +: 16]};
                end
                `FUNCT3_LWU: begin // Load Word (unsigned, 32-bit into 64-bit)
                    temp_read_data = {{(`DATA_WIDTH-32){1'b0}}, aligned_word_read[byte_offset_in_word*8 +: 32]};
                end
                default: temp_read_data = `DATA_WIDTH'('x); // Should not happen for load opcodes
            endcase
            read_data_aligned = temp_read_data;
        end
    end
    assign read_data_o = read_data_aligned;

    // Write logic (synchronous write on positive clock edge)
    always_ff @(posedge clk) begin
        if (mem_write_en_i && addr_i < MEM_SIZE_BYTES) begin
            case (funct3_i)
                `FUNCT3_SB: begin // Store Byte
                    if (addr_i < MEM_SIZE_BYTES) mem[addr_i] = write_data_i[7:0];
                end
                `FUNCT3_SH: begin // Store Half-word
                    if ((addr_i + 1) < MEM_SIZE_BYTES) begin // Check bounds for 2 bytes
                        mem[addr_i]   = write_data_i[7:0];
                        mem[addr_i+1] = write_data_i[15:8];
                    end
                end
                `FUNCT3_SW: begin // Store Word (32-bit)
                    if ((addr_i + 3) < MEM_SIZE_BYTES) begin // Check bounds for 4 bytes
                        for (int i = 0; i < 4; i++) begin
                            mem[addr_i+i] = write_data_i[i*8 +: 8];
                        end
                    end
                end
                `FUNCT3_SD: begin // Store Double-word (64-bit)
                    if ((addr_i + 7) < MEM_SIZE_BYTES) begin // Check bounds for 8 bytes
                        for (int i = 0; i < (`DATA_WIDTH/8); i++) begin
                            mem[addr_i+i] = write_data_i[i*8 +: 8];
                        end
                    end
                end
                default: ; // No action for other funct3 values during store
            endcase
        end
    end

    // Optional: Initialize memory on reset (for simulation)
    initial begin
        if (rst_n) begin // Wait for reset to de-assert if this initial block runs at time 0
            for (int i = 0; i < MEM_SIZE_BYTES; i++) begin
                mem[i] = 8'h00;
            end
        end
    end
    // Better reset handling:
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (int i = 0; i < MEM_SIZE_BYTES; i++) begin
                mem[i] <= 8'h00;
            end
        end
    end

endmodule


--- File: rtl/core/execute.sv ---
// rtl/core/execute.sv
`include "common/defines.svh"
`include "common/alu_defines.svh"
`include "common/riscv_opcodes.svh"
`include "common/control_signals_defines.svh"

module execute (
    // Inputs from ID/EX Register
    input  logic       reg_write_e_i,
    input  logic [1:0] result_src_e_i,
    input  logic       mem_write_e_i,
    input  logic       jump_e_i,
    input  logic       branch_e_i,
    input  logic       alu_src_e_i,
    input  logic [`ALU_CONTROL_WIDTH-1:0] alu_control_e_i,
    input  logic [2:0] funct3_e_i,
    input  alu_a_src_sel_e op_a_sel_e_i,
    input  pc_target_src_sel_e pc_target_src_sel_e_i,

    input  logic [`DATA_WIDTH-1:0]  pc_e_i,
    input  logic [`DATA_WIDTH-1:0]  pc_plus_4_e_i,
    input  logic [`DATA_WIDTH-1:0]  rs1_data_e_i,   // Data from RF or earlier forward for Rs1
    input  logic [`DATA_WIDTH-1:0]  rs2_data_e_i,   // Data from RF or earlier forward for Rs2
    input  logic [`DATA_WIDTH-1:0]  imm_ext_e_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_e_i,

// change start
    // Inputs for Forwarding (from later stages, routed by top pipeline module)
    input  logic [`DATA_WIDTH-1:0]     forward_data_mem_i, // Data from EX/MEM output (ALUResultM or ReadDataM if load was in MEM)
                                                         // More accurately, this should be ALUResultM if ResultSrcM is ALU,
                                                         // or ReadDataM if ResultSrcM is Mem.
                                                         // For simplicity in forwarding to ALU, usually ALUResultM is forwarded if RegWriteM is true.
                                                         // If load completes in MEM, ReadDataM is what should be forwarded.
                                                         // Let's assume this is the value that would be written to RdM if RegWriteM is true.
                                                         // This could be ALUResultM or ReadDataW (after Mem read).
                                                         // To be precise: if forwarding from MEM stage for an ALU op: ALUResultM.
                                                         // If forwarding from MEM stage for a Load op: ReadDataM (from MEM/WB input).
                                                         // The P&H diagram often simplifies this to "ALUResultM" path, but it can be ReadDataM.
                                                         // Let's use a generic "data_from_mem_stage_output" for now.
    input  logic [`DATA_WIDTH-1:0]     forward_data_wb_i,  // Data from MEM/WB output (ResultW)

    // Forwarding control signals from Pipeline Control Unit
    input  logic [1:0]                 forward_a_e_i,
    input  logic [1:0]                 forward_b_e_i,
// change end

    // Outputs to EX/MEM Register
    output logic       reg_write_m_o,
    // ... (остальные выходы как были) ...
    output logic [2:0] funct3_m_o,

    // Outputs to Fetch Stage/PC update logic
    output logic       pc_src_e_o,
    output logic [`DATA_WIDTH-1:0] pc_target_addr_e_o
);

    logic [`DATA_WIDTH-1:0] alu_operand_a_mux_out; // Output of MUX for OpA source (PC, RS1, ZERO)
    logic [`DATA_WIDTH-1:0] alu_operand_a;         // Final Operand A after forwarding
    logic [`DATA_WIDTH-1:0] alu_operand_b_mux_out; // Output of MUX for OpB source (RS2, Imm)
    logic [`DATA_WIDTH-1:0] alu_operand_b;         // Final Operand B after forwarding

    logic [`DATA_WIDTH-1:0] alu_result_internal;
    logic                   alu_zero_flag_internal;

    // ALU Operand A Source MUX (before forwarding)
    always_comb begin
        case (op_a_sel_e_i)
            ALU_A_SRC_RS1:  alu_operand_a_mux_out = rs1_data_e_i;
            ALU_A_SRC_PC:   alu_operand_a_mux_out = pc_e_i;
            ALU_A_SRC_ZERO: alu_operand_a_mux_out = `DATA_WIDTH'(0);
            default:        alu_operand_a_mux_out = rs1_data_e_i;
        endcase
    end

    // ALU Operand A Forwarding MUX
// change start
    always_comb begin
        case (forward_a_e_i)
            2'b00:  alu_operand_a = alu_operand_a_mux_out;      // No forward, use data from ID/EX (or selected PC/Zero)
            2'b10:  alu_operand_a = forward_data_mem_i;       // Forward from MEM stage output (EX/MEM.ALUResult or EX/MEM.ReadData if load)
            2'b01:  alu_operand_a = forward_data_wb_i;        // Forward from WB stage output (MEM/WB.ResultW)
            default: alu_operand_a = alu_operand_a_mux_out;   // Should not happen
        endcase
    end
// change end

    // ALU Operand B Source MUX (before forwarding)
    assign alu_operand_b_mux_out = alu_src_e_i ? imm_ext_e_i : rs2_data_e_i;

    // ALU Operand B Forwarding MUX
// change start
    always_comb begin
        case (forward_b_e_i)
            2'b00:  alu_operand_b = alu_operand_b_mux_out;      // No forward, use data from ID/EX (RS2 or Imm)
            2'b10:  alu_operand_b = forward_data_mem_i;       // Forward from MEM stage output
            2'b01:  alu_operand_b = forward_data_wb_i;        // Forward from WB stage output
            default: alu_operand_b = alu_operand_b_mux_out;   // Should not happen
        endcase
        // If alu_src_e_i is 1 (immediate for OpB), forwarding is not applicable to imm_ext_e_i.
        // Forwarding only applies if OpB comes from a register (rs2_data_e_i).
        // The Hazard Unit should set ForwardBE=00 if alu_src_e_i is 1.
        // Or, this MUX logic can be conditional on alu_src_e_i.
        if (alu_src_e_i) begin // If Operand B is immediate, no forwarding for it.
            alu_operand_b = imm_ext_e_i;
        end
        // else alu_operand_b is determined by the case statement above.
    end
// change end

    // ALU Instance (uses final operands after forwarding)
    alu u_alu (
        .operand_a   (alu_operand_a),
        .operand_b   (alu_operand_b),
        .alu_control (alu_control_e_i),
        .result      (alu_result_internal),
        .zero_flag   (alu_zero_flag_internal)
    );

    // ... (PC Target Address MUX, Branch Condition Logic, PCSrcE generation - остаются как были) ...
    // ... (Pass-through signals for EX/MEM register - остаются как были) ...

    // Pass-through signals for EX/MEM register
    assign reg_write_m_o  = reg_write_e_i;
    assign result_src_m_o = result_src_e_i;
    assign mem_write_m_o  = mem_write_e_i;
    assign alu_result_m_o = alu_result_internal;
    assign rs2_data_m_o   = rs2_data_e_i; // Note: This is original rs2_data from ID/EX, NOT forwarded rs2_data.
                                          // This is correct as it's the data to be STORED in memory.
    assign rd_addr_m_o    = rd_addr_e_i;
    assign pc_plus_4_m_o  = pc_plus_4_e_i;
    assign funct3_m_o     = funct3_e_i;

    // PC Target Address MUX
    logic [`DATA_WIDTH-1:0] target_addr_pc_plus_imm;
    logic [`DATA_WIDTH-1:0] target_addr_alu_jalr;

    assign target_addr_pc_plus_imm = pc_e_i + imm_ext_e_i;
    assign target_addr_alu_jalr    = alu_result_internal & ~(`DATA_WIDTH'(1));

    assign pc_target_addr_e_o = (pc_target_src_sel_e_i == PC_TARGET_SRC_ALU_JALR) ?
                                target_addr_alu_jalr : target_addr_pc_plus_imm;

    // Branch Condition Logic
    logic take_branch;
    always_comb begin
        take_branch = 1'b0;
        if (branch_e_i) begin
            case (funct3_e_i)
                `FUNCT3_BEQ:  take_branch = alu_zero_flag_internal;
                `FUNCT3_BNE:  take_branch = ~alu_zero_flag_internal;
                `FUNCT3_BLT:  take_branch = alu_result_internal[0];
                `FUNCT3_BGE:  take_branch = ~alu_result_internal[0];
                `FUNCT3_BLTU: take_branch = alu_result_internal[0];
                `FUNCT3_BGEU: take_branch = ~alu_result_internal[0];
                default:      take_branch = 1'b0;
            endcase
        end
    end

    assign pc_src_e_o = (jump_e_i) || (branch_e_i && take_branch);

endmodule


--- File: rtl/core/decode.sv ---
// rtl/core/decode.sv
`include "common/defines.svh"
`include "common/immediate_types.svh"
`include "common/alu_defines.svh" // For ALU_CONTROL_WIDTH
`include "common/control_signals_defines.svh"

module decode (
    // Inputs from IF/ID Register
    input  logic [`INSTR_WIDTH-1:0] instr_id_i,
    input  logic [`DATA_WIDTH-1:0]  pc_id_i,
    input  logic [`DATA_WIDTH-1:0]  pc_plus_4_id_i,

    // Inputs from Writeback Stage (for register file write)
    input  logic                       rd_write_en_wb_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_wb_i,
    input  logic [`DATA_WIDTH-1:0]     rd_data_wb_i,

    // Clock and Reset
    input  logic clk,
    input  logic rst_n,

    // Outputs to ID/EX Register
    // Control Signals
    output logic       reg_write_d_o,
    output logic [1:0] result_src_d_o,
    output logic       mem_write_d_o,
    output logic       jump_d_o,
    output logic       branch_d_o,
    output logic       alu_src_d_o,
    output logic [`ALU_CONTROL_WIDTH-1:0] alu_control_d_o, // Unified ALU control
    output logic [2:0] funct3_d_o,
    output alu_a_src_sel_e op_a_sel_d_o,
    output pc_target_src_sel_e pc_target_src_sel_d_o,

    // Data
    output logic [`DATA_WIDTH-1:0]  pc_d_o,
    output logic [`DATA_WIDTH-1:0]  pc_plus_4_d_o,
    output logic [`DATA_WIDTH-1:0]  rs1_data_d_o,
    output logic [`DATA_WIDTH-1:0]  rs2_data_d_o,
    output logic [`DATA_WIDTH-1:0]  imm_ext_d_o,

    // Register addresses (for hazard unit)
    output logic [`REG_ADDR_WIDTH-1:0] rs1_addr_d_o,
    output logic [`REG_ADDR_WIDTH-1:0] rs2_addr_d_o,
    output logic [`REG_ADDR_WIDTH-1:0] rd_addr_d_o
);

    // Instruction fields
    logic [6:0] opcode;
    logic [`REG_ADDR_WIDTH-1:0] rs1_addr_instr;
    logic [`REG_ADDR_WIDTH-1:0] rs2_addr_instr;
    logic [`REG_ADDR_WIDTH-1:0] rd_addr_instr;
    logic [2:0] funct3;
    logic       funct7_5;

    // Intermediate signals
    immediate_type_e imm_type_sel_internal;

    // Decompose instruction
    assign opcode         = instr_id_i[6:0];
    assign rd_addr_instr  = instr_id_i[11:7];
    assign funct3         = instr_id_i[14:12];
    assign rs1_addr_instr = instr_id_i[19:15];
    assign rs2_addr_instr = instr_id_i[24:20];
    assign funct7_5       = instr_id_i[30]; // Bit 5 of funct7

    // Control Unit instance
    control_unit u_control_unit (
        .op                (opcode),
        .funct3            (funct3),
        .funct7_5          (funct7_5),

        .reg_write_d_o     (reg_write_d_o),
        .result_src_d_o    (result_src_d_o),
        .mem_write_d_o     (mem_write_d_o),
        .jump_d_o          (jump_d_o),
        .branch_d_o        (branch_d_o),
        .alu_src_d_o       (alu_src_d_o),
        .alu_control_d_o   (alu_control_d_o), // Now unified
        .imm_type_d_o      (imm_type_sel_internal),
        .funct3_d_o        (funct3_d_o), // Connect to new output from CU
        .op_a_sel_d_o      (op_a_sel_d_o),
        .pc_target_src_sel_d_o (pc_target_src_sel_d_o)
    );

    // Register File instance
    register_file u_register_file (
        .clk               (clk),
        .rst_n             (rst_n),
        .rs1_addr_i        (rs1_addr_instr),
        .rs1_data_o        (rs1_data_d_o),
        .rs2_addr_i        (rs2_addr_instr),
        .rs2_data_o        (rs2_data_d_o),
        .rd_write_en_wb_i  (rd_write_en_wb_i),
        .rd_addr_wb_i      (rd_addr_wb_i),
        .rd_data_wb_i      (rd_data_wb_i)
    );

    // Immediate Generator instance
    immediate_generator u_immediate_generator (
        .instr_i           (instr_id_i),
        .imm_type_sel_i    (imm_type_sel_internal),
        .imm_ext_o         (imm_ext_d_o)
    );

    // Pass through PC values
    assign pc_d_o        = pc_id_i;
    assign pc_plus_4_d_o = pc_plus_4_id_i;

    // Pass through register addresses for hazard detection and forwarding
    assign rs1_addr_d_o  = rs1_addr_instr;
    assign rs2_addr_d_o  = rs2_addr_instr;
    assign rd_addr_d_o   = rd_addr_instr;

endmodule


--- File: rtl/core/immediate_generator.sv ---
// rtl/core/immediate_generator.sv
`include "common/defines.svh"
`include "common/immediate_types.svh"

module immediate_generator (
    input  logic [`INSTR_WIDTH-1:0] instr_i,
    input  immediate_type_e         imm_type_sel_i, // Selects the type of immediate to generate
    output logic [`DATA_WIDTH-1:0]  imm_ext_o      // Sign-extended immediate value
);

    logic [`DATA_WIDTH-1:0] imm_i_type;
    logic [`DATA_WIDTH-1:0] imm_s_type;
    logic [`DATA_WIDTH-1:0] imm_b_type;
    logic [`DATA_WIDTH-1:0] imm_u_type;
    logic [`DATA_WIDTH-1:0] imm_j_type;
    logic [`DATA_WIDTH-1:0] imm_ishift_type;

    // I-type immediate: instr[31:20] (12 bits)
    assign imm_i_type = {{(`DATA_WIDTH-12){instr_i[31]}}, instr_i[31:20]};

    // S-type immediate: instr[31:25], instr[11:7] (12 bits)
    assign imm_s_type = {{(`DATA_WIDTH-12){instr_i[31]}}, instr_i[31:25], instr_i[11:7]};

    // B-type immediate: {instr[31], instr[7], instr[30:25], instr[11:8], 1'b0} (13 bits)
    // Sign-extended from original bit 12 (instr[31]) of the conceptual 13-bit immediate.
    assign imm_b_type = {{(`DATA_WIDTH-13){instr_i[31]}}, instr_i[31], instr_i[7], instr_i[30:25], instr_i[11:8], 1'b0};

    // U-type immediate: {instr[31:12], 12'b0} (32 bits)
    // Sign-extended from bit 31 of the effective 32-bit immediate. For RV64, this means sign-extend from bit 31 of the value.
    assign imm_u_type = {{(`DATA_WIDTH-32){instr_i[31]}}, instr_i[31:12], 12'h000};

    // J-type immediate: {instr[31], instr[19:12], instr[20], instr[30:21], 1'b0} (21 bits)
    // Sign-extended from original bit 20 (instr[31]) of the conceptual 21-bit immediate.
    assign imm_j_type = {{(`DATA_WIDTH-21){instr_i[31]}}, instr_i[31], instr_i[19:12], instr_i[20], instr_i[30:21], 1'b0};
    assign imm_ishift_type = `DATA_WIDTH'(instr_i[25:20]);

    always_comb begin
        case (imm_type_sel_i)
            IMM_TYPE_I:    imm_ext_o = imm_i_type;
            IMM_TYPE_S:    imm_ext_o = imm_s_type;
            IMM_TYPE_B:    imm_ext_o = imm_b_type;
            IMM_TYPE_U:    imm_ext_o = imm_u_type;
            IMM_TYPE_J:    imm_ext_o = imm_j_type;
            IMM_TYPE_ISHIFT: imm_ext_o = imm_ishift_type;
            IMM_TYPE_NONE: imm_ext_o = `DATA_WIDTH'(0); // Or 'x if preferred for non-existent immediates
            default:       imm_ext_o = `DATA_WIDTH'('x); // Should not happen with valid enum
        endcase
    end

endmodule


--- File: rtl/core/writeback.sv ---
// rtl/core/writeback.sv
`include "common/defines.svh"

module writeback_stage ( // Renamed to writeback_stage for clarity
    // Inputs from MEM/WB Register
    input  logic [1:0] result_src_wb_i,   // Selects the source for writeback data

    input  logic [`DATA_WIDTH-1:0]     read_data_wb_i,  // Data read from memory
    input  logic [`DATA_WIDTH-1:0]     alu_result_wb_i, // Result from ALU
    input  logic [`DATA_WIDTH-1:0]     pc_plus_4_wb_i,  // PC+4 for JAL/JALR

    // Outputs that go to the Register File's write port
    // (These will be connected to register_file instance in the top pipeline module)
    output logic [`DATA_WIDTH-1:0]     result_w_o       // Data to be written to register file
);

    // MUX to select the data to be written back to the register file
    always_comb begin
        case (result_src_wb_i)
            2'b00:  result_w_o = alu_result_wb_i;    // Result from ALU
            2'b01:  result_w_o = read_data_wb_i;     // Data from memory
            2'b10:  result_w_o = pc_plus_4_wb_i;     // PC+4 for JAL/JALR
            default: result_w_o = `DATA_WIDTH'('x); // Should not happen with valid control
        endcase
    end

    // The following signals are also part of the Writeback "stage" conceptually,
    // but they are passed directly from MEM/WB to the register file in the top module:
    // - reg_write_wb_i (from MEM/WB) -> to register_file.rd_write_en_wb_i
    // - rd_addr_wb_i   (from MEM/WB) -> to register_file.rd_addr_wb_i

endmodule


--- File: rtl/core/register_file.sv ---
// rtl/core/pipeline_control.sv
`include "common/defines.svh"
// `include "common/control_signals_defines.svh" // Если нужны enum для Forward MUX

module pipeline_control (
    // Inputs from IF/ID Stage (register addresses read in Decode)
    input  logic [`REG_ADDR_WIDTH-1:0] rs1_addr_d_i, // Rs1D on diagram
    input  logic [`REG_ADDR_WIDTH-1:0] rs2_addr_d_i, // Rs2D on diagram

    // Inputs from ID/EX Stage (destination register and control signals from Execute)
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_e_i,    // RdE
    input  logic                       reg_write_e_i,  // RegWriteE
    input  logic [1:0]                 result_src_e_i, // ResultSrcE (bit 0 indicates load if =1 for ResultSrc=MemRead)

    // Inputs from EX/MEM Stage
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_m_i,    // RdM
    input  logic                       reg_write_m_i,  // RegWriteM

    // Inputs from MEM/WB Stage (for forwarding, as per diagram)
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_w_i,    // RdW
    input  logic                       reg_write_w_i,  // RegWriteW

    // Input from Execute Stage indicating branch taken or jump
    input  logic                       pc_src_e_i,     // PCSrcE

    // Outputs to control the pipeline
    output logic                       stall_f_o,      // Stall PC and IF/ID input
    output logic                       stall_d_o,      // Stall IF/ID register (keep current values)
    output logic                       flush_d_o,      // Clear IF/ID register
    output logic                       flush_e_o,      // Clear ID/EX register

    output logic [1:0]                 forward_a_e_o,  // Forwarding MUX select for ALU OpA
                                                     // 00: No forward (from ID/EX rs1_data)
                                                     // 01: Forward from EX/MEM (ALUResultM or PCPlus4M if JAL/JALR was in EX)
                                                     // 10: Forward from MEM/WB (ResultW)
    output logic [1:0]                 forward_b_e_o   // Forwarding MUX select for ALU OpB
);

    // Internal signals for hazards
    logic load_use_hazard;

    // ** 1. Load-Use Hazard Detection & Stall Generation **
    // Stall if instruction in Decode uses a register that an instruction in Execute
    // is loading from memory.
    // ResultSrcE[0] is 1 if ResultSrcE is MEM_READ (01) or PC_PLUS_4 (10).
    // We are interested in MEM_READ (01). So ResultSrcE == 2'b01.
    // Let's assume ResultSrcE[0] = 1 implies a memory read for simplicity as per some diagrams,
    // OR more accurately, if (ResultSrcE == 2'b01) which means data from memory.
    // The diagram uses ResultSrcE0 (bit 0 of ResultSrcE).
    // If ResultSrcE = 01 (MemRead), then ResultSrcE[0] = 1.
    // If ResultSrcE = 10 (PC+4), then ResultSrcE[0] = 0. This is not a load.
    // So we need to be more specific: result_src_e_i == 2'b01 indicates a load.
    logic is_load_in_ex;
    assign is_load_in_ex = (result_src_e_i == 2'b01); // Data from memory for writeback

    assign load_use_hazard = is_load_in_ex && reg_write_e_i && (rd_addr_e_i != 0) &&
                             ((rd_addr_e_i == rs1_addr_d_i) || (rd_addr_e_i == rs2_addr_d_i));

    assign stall_f_o = load_use_hazard;
    assign stall_d_o = load_use_hazard; // Stall IF/ID, which means ID stage also stalls.

    // ** 2. Flush Generation **
    // FlushD: Clear IF/ID register if branch taken in EX or if load-use stall bubbles EX.
    // FlushE: Clear ID/EX register if branch taken in EX or if load-use stall.
    // The diagram says: FlushD = PCSrcE
    //                 FlushE = lwStall | PCSrcE
    assign flush_d_o = pc_src_e_i;
    assign flush_e_o = load_use_hazard || pc_src_e_i;


    // ** 3. Forwarding Logic **
    // ForwardAE / ForwardBE
    // Priority:
    // 1. EX/MEM hazard (if RegWriteE and RdE matches Rs1D/Rs2D)
    // 2. MEM/WB hazard (if RegWriteM and RdM matches Rs1D/Rs2D, and not covered by EX/MEM forward)
    // 3. (Diagram also shows WB/?? hazard if RegWriteW and RdW matches)

    // Forward for Operand A (rs1_addr_d_i)
    always_comb begin
        forward_a_e_o = 2'b00; // Default: no forwarding
        // EX/MEM to EX forwarding for OpA
        if (reg_write_e_i && (rd_addr_e_i != 0) && (rd_addr_e_i == rs1_addr_d_i)) begin
            forward_a_e_o = 2'b01; // Forward ALUResultM (or PC+4 if it was JAL/JALR)
        end
        // MEM/WB to EX forwarding for OpA (if not already forwarded from EX/MEM)
        // And if rs1 is not x0
        else if (reg_write_m_i && (rd_addr_m_i != 0) && (rd_addr_m_i == rs1_addr_d_i)) begin
            forward_a_e_o = 2'b10; // Forward ResultW (from MEM/WB, could be ALURes or MemData)
        end
        // MEM/WB stage is one cycle later than EX/MEM stage
        // The diagram P&H 7.61 shows forward from RdW as well, let's add that for completeness of the diagram.
        // This would be for data available at the very end of MEM/WB, to be used by an instruction now in EX.
        // This means data from an instruction that is TWO cycles ahead of the current EX instruction.
        // This is typically handled by the MEM/WB forwarding (my case 2'b10).
        // The diagram's logic:
        // if ((Rs1E == RdM) & RegWriteM) & (Rs1E != 0)) then ForwardAE = 10
        // else if ((Rs1E == RdW) & RegWriteW) & (Rs1E != 0)) then ForwardAE = 01
        // This implies RdM path has priority over RdW. My logic above does this.
        // The diagram uses 10 for RdM and 01 for RdW for ForwardAE. Let's match that.
        // My `reg_write_e_i` / `rd_addr_e_i` are from ID/EX register, feeding into current EX stage.
        // My `reg_write_m_i` / `rd_addr_m_i` are from EX/MEM register, feeding into current MEM stage.
        // My `reg_write_w_i` / `rd_addr_w_i` are from MEM/WB register, feeding into current WB stage.

        // Correcting based on typical P&H diagram forwarding paths:
        // Path 1: ALU result from instruction in EX stage (now in MEM stage) to current EX stage
        // Path 2: Data from instruction in MEM stage (now in WB stage) to current EX stage

        // Source for ForwardAE = 01 is ALUResultM or ReadDataM from instruction in MEM stage
        // Source for ForwardAE = 10 is ResultW from instruction in WB stage

        // Re-evaluating my signal names vs diagram:
        // My rs1_addr_d_i is Rs1D (or Rs1E on diagram if referring to inputs of EX's ALU).
        // Let's use Rs1D, Rs2D for inputs to Hazard Unit from Decode outputs.
        // RdE, RegWriteE are from ID/EX register (instr currently in EX).
        // RdM, RegWriteM are from EX/MEM register (instr currently in MEM).
        // RdW, RegWriteW are from MEM/WB register (instr currently in WB).

        // Forwarding to current EX stage for operand Rs1D:
        // Priority 1: Data from instruction finishing EX stage (now in EX/MEM reg)
        // This is not directly shown as a separate forward path on the diagram for Rs1D/Rs2D,
        // because the EX stage calculation itself isn't finished to be forwarded back to its own input.
        // Forwarding is from *later* stages to an *earlier* stage's inputs.
        // So, for an instruction currently in EX, we need data from instructions in MEM or WB.

        // Forward from MEM stage to EX stage (for Rs1D)
        // If instr in MEM writes to RdM, and RdM == Rs1D
        if (reg_write_m_i && (rd_addr_m_i != 0) && (rd_addr_m_i == rs1_addr_d_i)) begin
            forward_a_e_o = 2'b01; // Use value from end of MEM stage (ALUResultM or ReadDataM via MEM/WB reg)
                                   // Diagram shows this as ForwardAE=10 (RdM path)
        end
        // Forward from WB stage to EX stage (for Rs1D), if not covered by MEM stage forward
        else if (reg_write_w_i && (rd_addr_w_i != 0) && (rd_addr_w_i == rs1_addr_d_i)) begin
            forward_a_e_o = 2'b10; // Use value from end of WB stage (ResultW)
                                   // Diagram shows this as ForwardAE=01 (RdW path)
        end
        // Note: The encoding 01 vs 10 for MEM vs WB might be arbitrary, what matters is distinct values.
        // I will use 01 for MEM->EX and 10 for WB->EX to make it different from the diagram if my interpretation is different.
        // Let's stick to diagram: ForwardAE = 10 for (EX/MEM data -> EX input), ForwardAE = 01 for (MEM/WB data -> EX input)
        // My 'reg_write_m_i' is from instruction currently IN memory stage (output of EX/MEM). So this is the EX/MEM -> EX path.
        // My 'reg_write_w_i' is from instruction currently IN WB stage (output of MEM/WB). So this is the MEM/WB -> EX path.

        // Re-assigning based on diagram's numbering for ForwardAE:
        // RdM path (data from EX/MEM register, for instruction in MEM stage) has code 10
        // RdW path (data from MEM/WB register, for instruction in WB stage) has code 01
        forward_a_e_o = 2'b00; // Default
        if (reg_write_m_i && (rd_addr_m_i != 0) && (rd_addr_m_i == rs1_addr_d_i)) begin
            forward_a_e_o = 2'b10; // Forward from MEM stage output (EX/MEM pipeline reg content)
        end
        else if (reg_write_w_i && (rd_addr_w_i != 0) && (rd_addr_w_i == rs1_addr_d_i)) begin
            forward_a_e_o = 2'b01; // Forward from WB stage output (MEM/WB pipeline reg content)
        end
    end

    // Forward for Operand B (rs2_addr_d_i)
    always_comb begin
        forward_b_e_o = 2'b00; // Default: no forwarding
        // Forward from MEM stage to EX stage (for Rs2D)
        if (reg_write_m_i && (rd_addr_m_i != 0) && (rd_addr_m_i == rs2_addr_d_i)) begin
            forward_b_e_o = 2'b10; // Forward from MEM stage output
        end
        // Forward from WB stage to EX stage (for Rs2D), if not covered by MEM stage forward
        else if (reg_write_w_i && (rd_addr_w_i != 0) && (rd_addr_w_i == rs2_addr_d_i)) begin
            forward_b_e_o = 2'b01; // Forward from WB stage output
        end
    end

    // The diagram also shows ForwardAE/BE signals from EX stage (RdE).
    // This would be for an instruction in EX forwarding its result to a *subsequent* cycle's EX stage,
    // which is effectively what the reg_write_m_i/rd_addr_m_i path handles (as this instruction moves to MEM).
    // The diagram text "if ((Rs1E == RdM) & RegWriteM)..." means Rs1 of *current EX* vs Rd of *instr in MEM*.
    // The diagram text "if ((Rs1E == RdW) & RegWriteW)..." means Rs1 of *current EX* vs Rd of *instr in WB*.
    // There is no explicit "Rs1E == RdE" forwarding in the text snippet on the diagram for ForwardAE/BE.
    // However, if an ALU op in EX immediately needs its own result (not possible in simple pipeline)
    // or if there's a very tight loop not handled by these, more forwarding might be needed.
    // The standard P&H 5-stage forwarding covers EX/MEM->EX and MEM/WB->EX.

endmodule


--- File: rtl/core/instruction_memory.sv ---
`include "common/defines.svh"

module instruction_memory (
    input  logic [`DATA_WIDTH-1:0] address,
    output logic [`INSTR_WIDTH-1:0] instruction
);

    localparam ROM_SIZE = 256; // Number of instructions
    logic [`INSTR_WIDTH-1:0] mem[ROM_SIZE-1:0];

    // In a real scenario, this would be loaded from a file (e.g., $readmemh)
    initial begin
        for (int i = 0; i < ROM_SIZE; i++) begin
            mem[i] = 32'h00000013; // NOP
        end
        // Add a few distinct instructions for testing later
        mem[0] = 32'h00100093; // addi x1, x0, 1
        mem[1] = 32'h00200113; // addi x2, x0, 2
        // mem[2] = 32'h00008067; // jalr x0, x1, 0 (effectively a jump to x1 content)
        //                        // This is a simplification; jalr needs rs1.
        //                        // Let's use simpler instructions for now.
        mem[2] = 32'h00308193; // addi x3, x1, 3
        mem[3] = 32'h00110213; // addi x4, x2, 1
    end

    assign instruction = mem[address[`DATA_WIDTH-1:2]]; // Use PC[63:2] as index for 32-bit instructions

endmodule


--- File: rtl/pipeline.sv ---
// rtl/pipeline.sv
`default_nettype none
`timescale 1ns/1ps

`include "common/defines.svh"
`include "common/alu_defines.svh"
`include "common/control_signals_defines.svh"
// `include "common/immediate_types.svh" // Not directly needed at top level, submodules use it
// `include "common/riscv_opcodes.svh"  // Not directly needed at top level

module pipeline (
    input  logic clk,
    input  logic rst_n,

    // Outputs for observing/testing (optional)
    output logic [`DATA_WIDTH-1:0] current_pc_debug, // Current PC from Fetch stage
    output logic [`INSTR_WIDTH-1:0] fetched_instr_debug // Instruction fetched
);

    // Signals between Fetch and IF/ID Register
    logic [`INSTR_WIDTH-1:0]    instr_f;
    logic [`DATA_WIDTH-1:0]     pc_f;
    logic [`DATA_WIDTH-1:0]     pc_plus_4_f;

    // Signals between IF/ID Register and Decode Stage
    logic [`INSTR_WIDTH-1:0]    instr_id;
    logic [`DATA_WIDTH-1:0]     pc_id;
    logic [`DATA_WIDTH-1:0]     pc_plus_4_id;

    // Signals between Decode Stage and ID/EX Register
    logic       reg_write_d;
    logic [1:0] result_src_d;
    logic       mem_write_d;
    logic       jump_d;
    logic       branch_d;
    logic       alu_src_d;
    logic [`ALU_CONTROL_WIDTH-1:0] alu_control_d;
    logic [2:0] funct3_d;
    alu_a_src_sel_e op_a_sel_d;
    pc_target_src_sel_e pc_target_src_sel_d;
    logic [`DATA_WIDTH-1:0]  rs1_data_d;
    logic [`DATA_WIDTH-1:0]  rs2_data_d;
    logic [`DATA_WIDTH-1:0]  imm_ext_d;
    logic [`REG_ADDR_WIDTH-1:0] rs1_addr_d; // To Hazard Unit
    logic [`REG_ADDR_WIDTH-1:0] rs2_addr_d; // To Hazard Unit
    logic [`REG_ADDR_WIDTH-1:0] rd_addr_d;  // To ID/EX

    // Signals between ID/EX Register and Execute Stage
    logic       reg_write_e;
    logic [1:0] result_src_e;
    logic       mem_write_e;
    logic       jump_e;
    logic       branch_e;
    logic       alu_src_e;
    logic [`ALU_CONTROL_WIDTH-1:0] alu_control_e;
    logic [2:0] funct3_e;
    alu_a_src_sel_e op_a_sel_e;
    pc_target_src_sel_e pc_target_src_sel_e;
    logic [`DATA_WIDTH-1:0]  pc_e;
    logic [`DATA_WIDTH-1:0]  pc_plus_4_e;
    logic [`DATA_WIDTH-1:0]  rs1_data_e;
    logic [`DATA_WIDTH-1:0]  rs2_data_e;
    logic [`DATA_WIDTH-1:0]  imm_ext_e;
    logic [`REG_ADDR_WIDTH-1:0] rs1_addr_e; // From ID/EX for Hazard Unit
    logic [`REG_ADDR_WIDTH-1:0] rs2_addr_e; // From ID/EX for Hazard Unit
    logic [`REG_ADDR_WIDTH-1:0] rd_addr_e;  // To Hazard Unit & EX/MEM

    // Signals from Execute Stage (to Hazard Unit & EX/MEM Register)
    logic       pc_src_from_ex;          // Output from Execute, PCSrcE on diagram
    logic [`DATA_WIDTH-1:0] pc_target_addr_from_ex; // Output from Execute, PCTargetE on diagram

    // Signals between Execute Stage and EX/MEM Register
    logic       reg_write_m_ex_out;      // RegWriteM from Execute
    logic [1:0] result_src_m_ex_out;   // ResultSrcM from Execute
    logic       mem_write_m_ex_out;      // MemWriteM from Execute
    logic [`DATA_WIDTH-1:0] alu_result_m_ex_out; // ALUResultM from Execute
    logic [`DATA_WIDTH-1:0] rs2_data_m_ex_out;   // WriteDataM from Execute (original rs2 data)
    logic [`REG_ADDR_WIDTH-1:0] rd_addr_m_ex_out;    // RdM from Execute
    logic [`DATA_WIDTH-1:0] pc_plus_4_m_ex_out;  // PCPlus4M from Execute
    logic [2:0] funct3_m_ex_out;         // Funct3 from Execute

    // Signals between EX/MEM Register and Memory Stage
    logic       reg_write_m;
    logic [1:0] result_src_m;
    logic       mem_write_m;
    logic [`DATA_WIDTH-1:0] alu_result_m;
    logic [`DATA_WIDTH-1:0] rs2_data_m;
    logic [`REG_ADDR_WIDTH-1:0] rd_addr_m;  // To Hazard Unit & MEM/WB
    logic [`DATA_WIDTH-1:0] pc_plus_4_m;
    logic [2:0] funct3_m;

    // Signals between Memory Stage and MEM/WB Register
    logic       reg_write_w_mem_out;
    logic [1:0] result_src_w_mem_out;
    logic [`DATA_WIDTH-1:0] read_data_w_mem_out;
    logic [`DATA_WIDTH-1:0] alu_result_w_mem_out;
    logic [`REG_ADDR_WIDTH-1:0] rd_addr_w_mem_out;
    logic [`DATA_WIDTH-1:0] pc_plus_4_w_mem_out;

    // Signals between MEM/WB Register and Writeback Stage
    logic       reg_write_wb;
    logic [1:0] result_src_wb;
    logic [`DATA_WIDTH-1:0] read_data_wb;
    logic [`DATA_WIDTH-1:0] alu_result_wb;
    logic [`REG_ADDR_WIDTH-1:0] rd_addr_wb;  // To Hazard Unit
    logic [`DATA_WIDTH-1:0] pc_plus_4_wb;

    // Signal from Writeback stage to Register File
    logic [`DATA_WIDTH-1:0] result_w;      // ResultW on diagram

    // Hazard Unit Control Signals
    logic stall_f;
    logic stall_d;
    logic flush_d;
    logic flush_e;
    logic [1:0] forward_a_e;
    logic [1:0] forward_b_e;

    // Assign debug outputs
    assign current_pc_debug = pc_f;
    assign fetched_instr_debug = instr_f;

    // Instantiate Pipeline Stages and Registers

    // FETCH STAGE
    fetch u_fetch (
        .clk            (clk),
        .rst_n          (rst_n),
        .stall_f        (stall_f),          // From Hazard Unit
        .pc_src_e       (pc_src_from_ex),   // From Execute Stage
        .pc_target_e    (pc_target_addr_from_ex), // From Execute Stage
        .instr_f_o      (instr_f),
        .pc_f_o         (pc_f),
        .pc_plus_4_f_o  (pc_plus_4_f)
    );

    // IF/ID REGISTER
    if_id_register u_if_id_register (
        .clk            (clk),
        .rst_n          (rst_n),
        .stall_d        (stall_d),          // From Hazard Unit
        .flush_d        (flush_d),          // From Hazard Unit
        .instr_f_i      (instr_f),
        .pc_f_i         (pc_f),
        .pc_plus_4_f_i  (pc_plus_4_f),
        .instr_id_o     (instr_id),
        .pc_id_o        (pc_id),
        .pc_plus_4_id_o (pc_plus_4_id)
    );

    // DECODE STAGE
    // Register file write port is connected from MEM/WB register outputs
    decode u_decode (
        .clk                (clk),
        .rst_n              (rst_n),
        .instr_id_i         (instr_id),
        .pc_id_i            (pc_id),
        .pc_plus_4_id_i     (pc_plus_4_id),
        .rd_write_en_wb_i   (reg_write_wb),     // From MEM/WB (final write enable)
        .rd_addr_wb_i       (rd_addr_wb),       // From MEM/WB (final rd address)
        .rd_data_wb_i       (result_w),         // From Writeback MUX (final data to write)
        .reg_write_d_o      (reg_write_d),
        .result_src_d_o     (result_src_d),
        .mem_write_d_o      (mem_write_d),
        .jump_d_o           (jump_d),
        .branch_d_o         (branch_d),
        .alu_src_d_o        (alu_src_d),
        .alu_control_d_o    (alu_control_d),
        .funct3_d_o         (funct3_d),
        .op_a_sel_d_o       (op_a_sel_d),
        .pc_target_src_sel_d_o (pc_target_src_sel_d),
        .pc_d_o             (pc_id),            // pc_d_o is just pc_id_i passed through
        .pc_plus_4_d_o      (pc_plus_4_id),     // pc_plus_4_d_o is just pc_plus_4_id_i passed through
        .rs1_data_d_o       (rs1_data_d),
        .rs2_data_d_o       (rs2_data_d),
        .imm_ext_d_o        (imm_ext_d),
        .rs1_addr_d_o       (rs1_addr_d),
        .rs2_addr_d_o       (rs2_addr_d),
        .rd_addr_d_o        (rd_addr_d)
    );

    // ID/EX REGISTER
    id_ex_register u_id_ex_register (
        .clk            (clk),
        .rst_n          (rst_n),
        .stall_e        (1'b0),             // stall_e not used per P&H diagram if forwarding handles all, else from HU
        .flush_e        (flush_e),          // From Hazard Unit
        .reg_write_d_i  (reg_write_d),
        .result_src_d_i (result_src_d),
        .mem_write_d_i  (mem_write_d),
        .jump_d_i       (jump_d),
        .branch_d_i     (branch_d),
        .alu_src_d_i    (alu_src_d),
        .alu_control_d_i(alu_control_d),
        .funct3_d_i     (funct3_d),
        .op_a_sel_d_i   (op_a_sel_d),
        .pc_target_src_sel_d_i (pc_target_src_sel_d),
        .pc_d_i         (pc_id),            // pc_d_i from Decode (which is pc_id)
        .pc_plus_4_d_i  (pc_plus_4_id),
        .rs1_data_d_i   (rs1_data_d),
        .rs2_data_d_i   (rs2_data_d),
        .imm_ext_d_i    (imm_ext_d),
        .rs1_addr_d_i   (rs1_addr_d),       // Pass Rs1 Addr
        .rs2_addr_d_i   (rs2_addr_d),       // Pass Rs2 Addr
        .rd_addr_d_i    (rd_addr_d),
        .reg_write_e_o  (reg_write_e),
        .result_src_e_o (result_src_e),
        .mem_write_e_o  (mem_write_e),
        .jump_e_o       (jump_e),
        .branch_e_o     (branch_e),
        .alu_src_e_o    (alu_src_e),
        .alu_control_e_o(alu_control_e),
        .funct3_e_o     (funct3_e),
        .op_a_sel_e_o   (op_a_sel_e),
        .pc_target_src_sel_e_o (pc_target_src_sel_e),
        .pc_e_o         (pc_e),
        .pc_plus_4_e_o  (pc_plus_4_e),
        .rs1_data_e_o   (rs1_data_e),
        .rs2_data_e_o   (rs2_data_e),
        .imm_ext_e_o    (imm_ext_e),
        .rs1_addr_e_o   (rs1_addr_e),
        .rs2_addr_e_o   (rs2_addr_e),
        .rd_addr_e_o    (rd_addr_e)
    );

    // EXECUTE STAGE
    execute u_execute (
        .reg_write_e_i  (reg_write_e),
        .result_src_e_i (result_src_e),
        .mem_write_e_i  (mem_write_e),
        .jump_e_i       (jump_e),
        .branch_e_i     (branch_e),
        .alu_src_e_i    (alu_src_e),
        .alu_control_e_i(alu_control_e),
        .funct3_e_i     (funct3_e),
        .op_a_sel_e_i   (op_a_sel_e),
        .pc_target_src_sel_e_i (pc_target_src_sel_e),
        .pc_e_i         (pc_e),
        .pc_plus_4_e_i  (pc_plus_4_e),
        .rs1_data_e_i   (rs1_data_e),
        .rs2_data_e_i   (rs2_data_e),
        .imm_ext_e_i    (imm_ext_e),
        .rd_addr_e_i    (rd_addr_e),
        .forward_data_mem_i ( (result_src_m == 2'b01) ? read_data_wb : alu_result_m ), // Data from MEM output (alu_result_m or read_data_wb)
        .forward_data_wb_i  (result_w),         // Data from WB output (ResultW)
        .forward_a_e_i  (forward_a_e),      // From Hazard Unit
        .forward_b_e_i  (forward_b_e),      // From Hazard Unit
        .reg_write_m_o  (reg_write_m_ex_out),
        .result_src_m_o (result_src_m_ex_out),
        .mem_write_m_o  (mem_write_m_ex_out),
        .alu_result_m_o (alu_result_m_ex_out),
        .rs2_data_m_o   (rs2_data_m_ex_out),
        .rd_addr_m_o    (rd_addr_m_ex_out),
        .pc_plus_4_m_o  (pc_plus_4_m_ex_out),
        .funct3_m_o     (funct3_m_ex_out),
        .pc_src_e_o     (pc_src_from_ex),
        .pc_target_addr_e_o (pc_target_addr_from_ex)
    );

    // EX/MEM REGISTER
    ex_mem_register u_ex_mem_register (
        .clk            (clk),
        .rst_n          (rst_n),
        .reg_write_e_i  (reg_write_m_ex_out),
        .result_src_e_i (result_src_m_ex_out),
        .mem_write_e_i  (mem_write_m_ex_out),
        .alu_result_e_i (alu_result_m_ex_out),
        .rs2_data_e_i   (rs2_data_m_ex_out),
        .rd_addr_e_i    (rd_addr_m_ex_out),
        .pc_plus_4_e_i  (pc_plus_4_m_ex_out),
        .funct3_e_i     (funct3_m_ex_out),
        .reg_write_m_o  (reg_write_m),
        .result_src_m_o (result_src_m),
        .mem_write_m_o  (mem_write_m),
        .alu_result_m_o (alu_result_m),
        .rs2_data_m_o   (rs2_data_m),
        .rd_addr_m_o    (rd_addr_m),
        .pc_plus_4_m_o  (pc_plus_4_m),
        .funct3_m_o     (funct3_m)
    );

    // MEMORY STAGE
    memory_stage u_memory_stage (
        .clk            (clk),
        .rst_n          (rst_n),
        .reg_write_m_i  (reg_write_m),
        .result_src_m_i (result_src_m),
        .mem_write_m_i  (mem_write_m),
        .funct3_m_i     (funct3_m),
        .alu_result_m_i (alu_result_m),
        .rs2_data_m_i   (rs2_data_m),
        .rd_addr_m_i    (rd_addr_m),
        .pc_plus_4_m_i  (pc_plus_4_m),
        .reg_write_w_o  (reg_write_w_mem_out),
        .result_src_w_o (result_src_w_mem_out),
        .read_data_w_o  (read_data_w_mem_out),
        .alu_result_w_o (alu_result_w_mem_out), // Pass ALU result through
        .rd_addr_w_o    (rd_addr_w_mem_out),
        .pc_plus_4_w_o  (pc_plus_4_w_mem_out)
    );

    // MEM/WB REGISTER
    mem_wb_register u_mem_wb_register (
        .clk            (clk),
        .rst_n          (rst_n),
        .reg_write_m_i  (reg_write_w_mem_out),
        .result_src_m_i (result_src_w_mem_out),
        .read_data_m_i  (read_data_w_mem_out),
        .alu_result_m_i (alu_result_w_mem_out),
        .rd_addr_m_i    (rd_addr_w_mem_out),
        .pc_plus_4_m_i  (pc_plus_4_w_mem_out),
        .reg_write_wb_o (reg_write_wb),
        .result_src_wb_o(result_src_wb),
        .read_data_wb_o (read_data_wb),
        .alu_result_wb_o(alu_result_wb),
        .rd_addr_wb_o   (rd_addr_wb),
        .pc_plus_4_wb_o (pc_plus_4_wb)
    );

    // WRITEBACK STAGE
    writeback_stage u_writeback_stage (
        .result_src_wb_i (result_src_wb),
        .read_data_wb_i  (read_data_wb),
        .alu_result_wb_i (alu_result_wb),
        .pc_plus_4_wb_i  (pc_plus_4_wb),
        .result_w_o      (result_w)
    );

    // HAZARD UNIT (Pipeline Control)
    pipeline_control u_pipeline_control (
        .rs1_addr_d_i   (rs1_addr_d),    // Rs1D from Decode
        .rs2_addr_d_i   (rs2_addr_d),    // Rs2D from Decode

        .rd_addr_e_i    (rd_addr_e),     // RdE from ID/EX output
        .reg_write_e_i  (reg_write_e),   // RegWriteE from ID/EX output
        .result_src_e_i (result_src_e),  // ResultSrcE from ID/EX output (for load detection)

        .rd_addr_m_i    (rd_addr_m),     // RdM from EX/MEM output
        .reg_write_m_i  (reg_write_m),   // RegWriteM from EX/MEM output

        .rd_addr_w_i    (rd_addr_wb),    // RdW from MEM/WB output
        .reg_write_w_i  (reg_write_wb),  // RegWriteW from MEM/WB output

        .pc_src_e_i     (pc_src_from_ex), // PCSrcE from Execute stage output

        .stall_f_o      (stall_f),
        .stall_d_o      (stall_d),
        .flush_d_o      (flush_d),
        .flush_e_o      (flush_e),
        .forward_a_e_o  (forward_a_e),
        .forward_b_e_o  (forward_b_e)
    );

endmodule


