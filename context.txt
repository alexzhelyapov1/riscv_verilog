--- File: rtl/core/control_unit.sv ---
// rtl/core/control_unit.sv
`include "common/defines.svh"
`include "common/alu_defines.svh"
`include "common/immediate_types.svh"
`include "common/riscv_opcodes.svh"
`include "common/control_signals_defines.svh" // New include

module control_unit (
    // Inputs from instruction
    input  logic [6:0] op,
    input  logic [2:0] funct3,
    input  logic       funct7_5,

    // Outputs: Control signals
    output logic       reg_write_d_o,
    output logic [1:0] result_src_d_o,
    output logic       mem_write_d_o,
    output logic       jump_d_o,
    output logic       branch_d_o,
    output logic       alu_src_d_o,      // Selects ALU operand B (Reg vs Imm)
    output logic [`ALU_CONTROL_WIDTH-1:0] alu_control_d_o,
    output immediate_type_e imm_type_d_o,
    output logic [2:0] funct3_d_o,             // Pass funct3 for branch logic in EX & mem access type in MEM
    output alu_a_src_sel_e op_a_sel_d_o,        // Selects ALU operand A source
    output pc_target_src_sel_e pc_target_src_sel_d_o // Selects PC target source for EX
);

    // Pass funct3 directly as it's needed in later stages
    assign funct3_d_o = funct3;

    always_comb begin
        // Initialize signals to a known "safe" or default state for each instruction type
        reg_write_d_o   = 1'b0;
        result_src_d_o  = 2'b00; // Default: Result from ALU
        mem_write_d_o   = 1'b0;
        jump_d_o        = 1'b0;
        branch_d_o      = 1'b0;
        alu_src_d_o     = 1'b0; // Default: ALU Operand B from Register File (rs2)
        alu_control_d_o = `ALU_OP_ADD; // Default ALU operation
        imm_type_d_o    = IMM_TYPE_NONE;
        op_a_sel_d_o    = ALU_A_SRC_RS1; // Default
        pc_target_src_sel_d_o = PC_TARGET_SRC_PC_PLUS_IMM; // Default

        case (op)
            `OPCODE_LUI: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b1; // Imm for OpB
                imm_type_d_o    = IMM_TYPE_U;
                op_a_sel_d_o    = ALU_A_SRC_ZERO; // ALU OpA = 0
                alu_control_d_o = `ALU_OP_ADD;    // ALU = 0 + Imm
                result_src_d_o  = 2'b00;
            end
            `OPCODE_AUIPC: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b1; // Imm for OpB
                imm_type_d_o    = IMM_TYPE_U;
                op_a_sel_d_o    = ALU_A_SRC_PC;   // ALU OpA = PC
                alu_control_d_o = `ALU_OP_ADD;    // ALU = PC + Imm
                result_src_d_o  = 2'b00;
            end
            `OPCODE_JAL: begin
                reg_write_d_o   = 1'b1;
                jump_d_o        = 1'b1;
                imm_type_d_o    = IMM_TYPE_J;
                result_src_d_o  = 2'b10;      // rd = PC+4
                pc_target_src_sel_d_o = PC_TARGET_SRC_PC_PLUS_IMM; // Target = PC + ImmJ
                // ALU might be idle or used by a separate adder for PC+Imm.
                // To keep ALU control consistent if it *were* used for target:
                op_a_sel_d_o    = ALU_A_SRC_PC; // If ALU calculated PC+ImmJ
                alu_src_d_o     = 1'b1;
                alu_control_d_o = `ALU_OP_ADD;
            end
            `OPCODE_JALR: begin
                reg_write_d_o   = 1'b1;
                jump_d_o        = 1'b1;
                alu_src_d_o     = 1'b1; // Imm for OpB
                imm_type_d_o    = IMM_TYPE_I;
                op_a_sel_d_o    = ALU_A_SRC_RS1;  // ALU OpA = RS1
                alu_control_d_o = `ALU_OP_ADD;    // ALU = RS1 + Imm (for target calculation)
                result_src_d_o  = 2'b10;      // rd = PC+4
                pc_target_src_sel_d_o = PC_TARGET_SRC_ALU_JALR; // Target from ALU result & ~1
            end
            `OPCODE_BRANCH: begin
                branch_d_o      = 1'b1;
                alu_src_d_o     = 1'b0; // OpB = RS2 for comparison
                op_a_sel_d_o    = ALU_A_SRC_RS1; // OpA = RS1 for comparison
                imm_type_d_o    = IMM_TYPE_B;    // For PC + ImmB target calculation
                reg_write_d_o   = 1'b0;
                pc_target_src_sel_d_o = PC_TARGET_SRC_PC_PLUS_IMM; // Target is PC+ImmB
                case (funct3)
                    `FUNCT3_BEQ:  alu_control_d_o = `ALU_OP_SUB;
                    `FUNCT3_BNE:  alu_control_d_o = `ALU_OP_SUB;
                    `FUNCT3_BLT:  alu_control_d_o = `ALU_OP_SLT;
                    `FUNCT3_BGE:  alu_control_d_o = `ALU_OP_SLT;
                    `FUNCT3_BLTU: alu_control_d_o = `ALU_OP_SLTU;
                    `FUNCT3_BGEU: alu_control_d_o = `ALU_OP_SLTU;
                    default:      alu_control_d_o = `ALU_OP_ADD; // Or some invalid op
                endcase
            end
            `OPCODE_LOAD: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b1; // Imm for OpB (offset)
                imm_type_d_o    = IMM_TYPE_I;
                op_a_sel_d_o    = ALU_A_SRC_RS1;  // OpA = RS1 (base address)
                alu_control_d_o = `ALU_OP_ADD;    // ALU = RS1 + offset (address calculation)
                result_src_d_o  = 2'b01;      // Result from Memory
                mem_write_d_o   = 1'b0;
            end
            `OPCODE_STORE: begin
                alu_src_d_o     = 1'b1; // Imm for OpB (offset)
                imm_type_d_o    = IMM_TYPE_S;
                op_a_sel_d_o    = ALU_A_SRC_RS1;  // OpA = RS1 (base address)
                alu_control_d_o = `ALU_OP_ADD;    // ALU = RS1 + offset (address calculation)
                mem_write_d_o   = 1'b1;
                reg_write_d_o   = 1'b0;
            end
            `OPCODE_OP_IMM: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b1; // Imm for OpB
                imm_type_d_o    = (funct3 == `FUNCT3_SLLI || funct3 == `FUNCT3_SRLI_SRAI) ? IMM_TYPE_ISHIFT : IMM_TYPE_I;
                op_a_sel_d_o    = ALU_A_SRC_RS1;
                result_src_d_o  = 2'b00;
                case (funct3)
                    `FUNCT3_ADDI:  alu_control_d_o = `ALU_OP_ADD;
                    `FUNCT3_SLTI:  alu_control_d_o = `ALU_OP_SLT;
                    `FUNCT3_SLTIU: alu_control_d_o = `ALU_OP_SLTU;
                    `FUNCT3_XORI:  alu_control_d_o = `ALU_OP_XOR;
                    `FUNCT3_ORI:   alu_control_d_o = `ALU_OP_OR;
                    `FUNCT3_ANDI:  alu_control_d_o = `ALU_OP_AND;
                    `FUNCT3_SLLI:  alu_control_d_o = `ALU_OP_SLL;
                    `FUNCT3_SRLI_SRAI: begin
                        if (funct7_5 == `FUNCT7_5_SUB_ALT) alu_control_d_o = `ALU_OP_SRA;
                        else                               alu_control_d_o = `ALU_OP_SRL;
                    end
                    default:       alu_control_d_o = `ALU_OP_ADD;
                endcase
            end
            `OPCODE_OP: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b0; // OpB = RS2
                op_a_sel_d_o    = ALU_A_SRC_RS1; // OpA = RS1
                imm_type_d_o    = IMM_TYPE_NONE;
                result_src_d_o  = 2'b00;
                case (funct3)
                    `FUNCT3_ADD_SUB: begin
                        if (funct7_5 == `FUNCT7_5_SUB_ALT) alu_control_d_o = `ALU_OP_SUB;
                        else                               alu_control_d_o = `ALU_OP_ADD;
                    end
                    `FUNCT3_SLL:   alu_control_d_o = `ALU_OP_SLL;
                    `FUNCT3_SLT:   alu_control_d_o = `ALU_OP_SLT;
                    `FUNCT3_SLTU:  alu_control_d_o = `ALU_OP_SLTU;
                    `FUNCT3_XOR:   alu_control_d_o = `ALU_OP_XOR;
                    `FUNCT3_SRL_SRA: begin
                        if (funct7_5 == `FUNCT7_5_SUB_ALT) alu_control_d_o = `ALU_OP_SRA;
                        else                               alu_control_d_o = `ALU_OP_SRL;
                    end
                    `FUNCT3_OR:    alu_control_d_o = `ALU_OP_OR;
                    `FUNCT3_AND:   alu_control_d_o = `ALU_OP_AND;
                    default:       alu_control_d_o = `ALU_OP_ADD;
                endcase
            end
            default: begin // NOP / Unknown
                // Default assignments from above cover this
            end
        endcase
    end
endmodule


--- File: rtl/core/register_file.sv ---
// rtl/core/register_file.sv
`include "common/defines.svh"

module register_file (
    input  logic clk, // clk for synchronous write
    input  logic rst_n,

    // Read Port 1 (combinational)
    input  logic [`REG_ADDR_WIDTH-1:0] rs1_addr_i,
    output logic [`DATA_WIDTH-1:0]     rs1_data_o,

    // Read Port 2 (combinational)
    input  logic [`REG_ADDR_WIDTH-1:0] rs2_addr_i,
    output logic [`DATA_WIDTH-1:0]     rs2_data_o,

    // Write Port (from Writeback stage) - Synchronous
    input  logic                       rd_write_en_wb_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_wb_i,
    input  logic [`DATA_WIDTH-1:0]     rd_data_wb_i
);

    logic [`DATA_WIDTH-1:0] regs[31:0] /* verilator public */; // Make regs public for easier C++ TB access

    // Synchronous write on positive clock edge
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (int i = 0; i < 32; i++) begin
                regs[i] <= `DATA_WIDTH'(0);
            end
        end else begin
            if (rd_write_en_wb_i && (rd_addr_wb_i != `REG_ADDR_WIDTH'(0))) begin
                regs[rd_addr_wb_i] <= rd_data_wb_i;
            end
        end
    end

    // Combinational Read Logic
    // Read Port 1
    assign rs1_data_o = (rs1_addr_i == `REG_ADDR_WIDTH'(0)) ? `DATA_WIDTH'(0) :
                        (rd_write_en_wb_i && (rd_addr_wb_i == rs1_addr_i) && (rd_addr_wb_i != 0)) ? rd_data_wb_i : // Internal forwarding for read-after-write in same cycle
                        regs[rs1_addr_i];

    // Read Port 2
    assign rs2_data_o = (rs2_addr_i == `REG_ADDR_WIDTH'(0)) ? `DATA_WIDTH'(0) :
                        (rd_write_en_wb_i && (rd_addr_wb_i == rs2_addr_i) && (rd_addr_wb_i != 0)) ? rd_data_wb_i : // Internal forwarding
                        regs[rs2_addr_i];

endmodule


--- File: rtl/core/data_memory.sv ---
// rtl/core/data_memory.sv
`include "common/defines.svh"
`include "common/riscv_opcodes.svh" // For FUNCT3 defines (LB, LH, LW, etc.)

module data_memory #(
    parameter string DATA_MEM_INIT_FILE = "" // This parameter must exist
)(
    input  logic clk,
    input  logic rst_n,

    input  logic [`DATA_WIDTH-1:0]     addr_i,        // Address from ALU result
    input  logic [`DATA_WIDTH-1:0]     write_data_i,  // Data from RS2 (for stores)
    input  logic                       mem_write_en_i,  // From MemWriteM control signal
    input  logic [2:0]                 funct3_i,      // To determine load/store type (size and sign)

    output logic [`DATA_WIDTH-1:0]     read_data_o    // Data read from memory (for loads)
);

    // Parameter for memory size (e.g., 2^10 = 1024 words of 64-bit)
    // Addresses are byte addresses.
    localparam MEM_ADDR_BITS = 10; // For 1KB of byte-addressable memory (2^10 bytes)
    localparam MEM_SIZE_BYTES = 1 << MEM_ADDR_BITS;
    localparam MEM_SIZE_WORDS = MEM_SIZE_BYTES / (`DATA_WIDTH/8);

    // Byte-addressable memory array. Each element is a byte.
    logic [7:0] mem [MEM_SIZE_BYTES-1:0];
    logic [`DATA_WIDTH-1:0] aligned_word_read;
    logic [`DATA_WIDTH-1:0] temp_read_data;

    // For faster simulation, Verilator might prefer word-oriented memory if operations are word-aligned
    // but byte-addressable is more general for LB/SB etc.

    // Read logic (combinational read based on address)
    // Handles different load types based on funct3
    logic [`DATA_WIDTH-1:0] read_data_aligned;
    always_comb begin
        // Default to 'x' or 0 if address is out of bounds (not explicitly handled here for simplicity)
        read_data_aligned = `DATA_WIDTH'('0);
        if (addr_i < MEM_SIZE_BYTES) begin
            // Read a full 64-bit word aligned to 8 bytes for simplicity first
            // This assumes addr_i is mostly aligned for LW/LD. Unaligned access is complex.
            // For byte/half access, we need to pick correct bytes from the word.
            // Let's read the 8 bytes starting at the (potentially unaligned) address.
            // This is a simplification; real unaligned access is more involved.
            // We'll handle alignment and byte picking for loads.
            // For simplicity, assume addr_i is aligned for word/double-word access.
            // For byte/half, addr_i can be unaligned within the word.

            // Construct the 64-bit value from individual bytes
            // This handles potential unaligned reads across word boundaries if MEM_SIZE_BYTES is large enough
            // and if addr_i + 7 does not exceed MEM_SIZE_BYTES-1.
            // For simplicity, let's assume we read an aligned 64-bit word first, then extract.
            logic [`DATA_WIDTH-1:0] fetched_word;
            logic [2:0] byte_offset_in_word = addr_i[2:0]; // Lower 3 bits for byte offset within a 64-bit word
            logic [MEM_ADDR_BITS-1:3] word_addr_idx;

            // Read the 8 bytes that form the 64-bit chunk containing addr_i
            // This is still a simplification, proper unaligned access over physical memory is hard
            for (int i = 0; i < (`DATA_WIDTH/8); i++) begin
                if ((addr_i + i) < MEM_SIZE_BYTES) begin
                    fetched_word[i*8 +: 8] = mem[addr_i + i];
                end else begin
                    fetched_word[i*8 +: 8] = 8'h00; // Out of bounds byte
                end
            end
            // The above loop is not quite right for constructing the word based on addr_i alignment
            // Let's re-think: fetch the aligned word, then select based on offset and funct3.
            temp_read_data = `DATA_WIDTH'('x);
            word_addr_idx = addr_i[MEM_ADDR_BITS-1:3]; // Index for 64-bit words if mem was word array

            // More correct byte-wise construction for an aligned read:
            for (int i = 0; i < (`DATA_WIDTH/8); i++) begin
                 // addr_i & ~7 ensures we start at an 8-byte boundary for the read
                if (( (addr_i & ~(`DATA_WIDTH/8 - 1)) + i) < MEM_SIZE_BYTES) begin
                    aligned_word_read[(i*8) +: 8] = mem[(addr_i & ~(`DATA_WIDTH/8 - 1)) + i];
                end else begin
                    aligned_word_read[(i*8) +: 8] = 8'h00;
                end
            end


            case (funct3_i)
                `FUNCT3_LB: begin // Load Byte (signed)
                    temp_read_data = {{(`DATA_WIDTH-8){aligned_word_read[byte_offset_in_word*8 + 7]}}, aligned_word_read[byte_offset_in_word*8 +: 8]};
                end
                `FUNCT3_LH: begin // Load Half-word (signed)
                    temp_read_data = {{(`DATA_WIDTH-16){aligned_word_read[byte_offset_in_word*8 + 15]}}, aligned_word_read[byte_offset_in_word*8 +: 16]};
                end
                `FUNCT3_LW: begin // Load Word (signed, 32-bit)
                    temp_read_data = {{(`DATA_WIDTH-32){aligned_word_read[byte_offset_in_word*8 + 31]}}, aligned_word_read[byte_offset_in_word*8 +: 32]};
                end
                `FUNCT3_LD: begin // Load Double-word (64-bit)
                    temp_read_data = aligned_word_read; // Assumes addr_i is 8-byte aligned for LD
                end
                `FUNCT3_LBU: begin // Load Byte (unsigned)
                    temp_read_data = {{(`DATA_WIDTH-8){1'b0}}, aligned_word_read[byte_offset_in_word*8 +: 8]};
                end
                `FUNCT3_LHU: begin // Load Half-word (unsigned)
                    temp_read_data = {{(`DATA_WIDTH-16){1'b0}}, aligned_word_read[byte_offset_in_word*8 +: 16]};
                end
                `FUNCT3_LWU: begin // Load Word (unsigned, 32-bit into 64-bit)
                    temp_read_data = {{(`DATA_WIDTH-32){1'b0}}, aligned_word_read[byte_offset_in_word*8 +: 32]};
                end
                default: temp_read_data = `DATA_WIDTH'('x); // Should not happen for load opcodes
            endcase
            read_data_aligned = temp_read_data;
        end
    end
    assign read_data_o = read_data_aligned;

    // Write logic (synchronous write on positive clock edge)
    always_ff @(posedge clk) begin
        if (mem_write_en_i && addr_i < MEM_SIZE_BYTES) begin
            case (funct3_i)
                `FUNCT3_SB: begin // Store Byte
                    if (addr_i < MEM_SIZE_BYTES) mem[addr_i] = write_data_i[7:0];
                end
                `FUNCT3_SH: begin // Store Half-word
                    if ((addr_i + 1) < MEM_SIZE_BYTES) begin // Check bounds for 2 bytes
                        mem[addr_i]   = write_data_i[7:0];
                        mem[addr_i+1] = write_data_i[15:8];
                    end
                end
                `FUNCT3_SW: begin // Store Word (32-bit)
                    if ((addr_i + 3) < MEM_SIZE_BYTES) begin // Check bounds for 4 bytes
                        for (int i = 0; i < 4; i++) begin
                            mem[addr_i+i] = write_data_i[i*8 +: 8];
                        end
                    end
                end
                `FUNCT3_SD: begin // Store Double-word (64-bit)
                    if ((addr_i + 7) < MEM_SIZE_BYTES) begin // Check bounds for 8 bytes
                        for (int i = 0; i < (`DATA_WIDTH/8); i++) begin
                            mem[addr_i+i] = write_data_i[i*8 +: 8];
                        end
                    end
                end
                default: ; // No action for other funct3 values during store
            endcase
        end
    end

    // Optional: Initialize memory on reset (for simulation)
    initial begin
        if (rst_n) begin // Wait for reset to de-assert if this initial block runs at time 0
            for (int i = 0; i < MEM_SIZE_BYTES; i++) begin
                mem[i] = 8'h00;
            end
        end
    end
    // Better reset handling:
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (int i = 0; i < MEM_SIZE_BYTES; i++) begin
                mem[i] = 8'h00;
            end
        end
    end

endmodule


--- File: rtl/core/execute.sv ---
// rtl/core/execute.sv
`include "common/pipeline_types.svh"
`include "common/riscv_opcodes.svh" // For FUNCT3 defines for branches

module execute (
    // Clock and Reset (potentially unused if purely combinational)
    // input  logic clk,
    // input  logic rst_n,

    // Input from Decode (latched by ID/EX register in pipeline.sv)
    input  id_ex_data_t            id_ex_data_i,

    // Forwarding signals from Hazard Unit and data from later stages
    input  logic [`DATA_WIDTH-1:0] forward_data_mem_i, // Data from EX/MEM output (ALUResultM or ReadDataM)
    input  logic [`DATA_WIDTH-1:0] forward_data_wb_i,  // Data from MEM/WB output (ResultW)
    input  logic [1:0]             forward_a_e_i,      // Control for OpA forwarding MUX
    input  logic [1:0]             forward_b_e_i,      // Control for OpB forwarding MUX

    // Output to Memory stage (to be latched by EX/MEM register in pipeline.sv)
    output ex_mem_data_t           ex_mem_data_o,

    // Outputs to Fetch Stage / PC update logic
    output logic                   pc_src_o,           // PCSrcE: 1 if branch/jump taken
    output logic [`DATA_WIDTH-1:0] pc_target_addr_o // PCTargetE: target address
);

    logic [`DATA_WIDTH-1:0] alu_operand_a_mux_out;
    logic [`DATA_WIDTH-1:0] alu_operand_a_final;
    logic [`DATA_WIDTH-1:0] alu_operand_b_mux_out;
    logic [`DATA_WIDTH-1:0] alu_operand_b_final;

    logic [`DATA_WIDTH-1:0] alu_result_internal;
    logic                   alu_zero_flag_internal;

    // ALU Operand A Source Selection (before forwarding)
    always_comb begin
        case (id_ex_data_i.op_a_sel)
            ALU_A_SRC_RS1:  alu_operand_a_mux_out = id_ex_data_i.rs1_data;
            ALU_A_SRC_PC:   alu_operand_a_mux_out = id_ex_data_i.pc;
            ALU_A_SRC_ZERO: alu_operand_a_mux_out = `DATA_WIDTH'(0);
            default:        alu_operand_a_mux_out = id_ex_data_i.rs1_data; // Should not happen
        endcase
    end

    // ALU Operand A Forwarding
    always_comb begin
        case (forward_a_e_i)
            2'b00:  alu_operand_a_final = alu_operand_a_mux_out;    // No forward
            2'b10:  alu_operand_a_final = forward_data_mem_i;       // Forward from EX/MEM stage (RdM)
            2'b01:  alu_operand_a_final = forward_data_wb_i;        // Forward from MEM/WB stage (RdW)
            default: alu_operand_a_final = alu_operand_a_mux_out;   // Should not happen
        endcase
    end

    // ALU Operand B Source Selection (before forwarding)
    assign alu_operand_b_mux_out = id_ex_data_i.alu_src ? id_ex_data_i.imm_ext : id_ex_data_i.rs2_data;

    // ALU Operand B Forwarding
    always_comb begin
        if (id_ex_data_i.alu_src) begin // If Operand B is an Immediate, no forwarding
            alu_operand_b_final = id_ex_data_i.imm_ext;
        end else begin // Operand B is from a register (rs2_data), forwarding might apply
            case (forward_b_e_i)
                2'b00:  alu_operand_b_final = alu_operand_b_mux_out;    // No forward
                2'b10:  alu_operand_b_final = forward_data_mem_i;       // Forward from EX/MEM stage (RdM)
                2'b01:  alu_operand_b_final = forward_data_wb_i;        // Forward from MEM/WB stage (RdW)
                default: alu_operand_b_final = alu_operand_b_mux_out;   // Should not happen
            endcase
        end
    end

    // ALU Instance
    alu u_alu (
        .operand_a   (alu_operand_a_final),
        .operand_b   (alu_operand_b_final),
        .alu_control (id_ex_data_i.alu_control),
        .result      (alu_result_internal),
        .zero_flag   (alu_zero_flag_internal)
    );

    // PC Target Address Calculation
    logic [`DATA_WIDTH-1:0] target_addr_pc_plus_imm;
    logic [`DATA_WIDTH-1:0] target_addr_alu_jalr_masked;

    assign target_addr_pc_plus_imm = id_ex_data_i.pc + id_ex_data_i.imm_ext;
    // For JALR: target = (ALU result of RS1 + Imm) & ~1.
    // ALU computes (RS1 + Imm) if op_a_sel=RS1, alu_src=Imm, alu_control=ADD.
    // This specific ALU result (alu_result_internal) is used for JALR.
    assign target_addr_alu_jalr_masked = alu_result_internal & ~(`DATA_WIDTH'(1));

    assign pc_target_addr_o = (id_ex_data_i.pc_target_src_sel == PC_TARGET_SRC_ALU_JALR) ?
                               target_addr_alu_jalr_masked : target_addr_pc_plus_imm;

    // Branch Condition Logic
    logic take_branch;
    always_comb begin
        take_branch = 1'b0;
        if (id_ex_data_i.branch) begin
            case (id_ex_data_i.funct3) // Use pipelined funct3
                `FUNCT3_BEQ:  take_branch = alu_zero_flag_internal;
                `FUNCT3_BNE:  take_branch = ~alu_zero_flag_internal;
                `FUNCT3_BLT:  take_branch = alu_result_internal[0];  // SLT result is 1 if taken
                `FUNCT3_BGE:  take_branch = ~alu_result_internal[0]; // SLT result is 0 if taken
                `FUNCT3_BLTU: take_branch = alu_result_internal[0];  // SLTU result is 1 if taken
                `FUNCT3_BGEU: take_branch = ~alu_result_internal[0]; // SLTU result is 0 if taken
                default:      take_branch = 1'b0;
            endcase
        end
    end

    // PCSrc signal: Controls MUX for next PC in Fetch stage
    assign pc_src_o = (id_ex_data_i.jump) || (id_ex_data_i.branch && take_branch);

    // Assign outputs to EX/MEM data structure
    assign ex_mem_data_o.reg_write  = id_ex_data_i.reg_write;
    assign ex_mem_data_o.result_src = id_ex_data_i.result_src;
    assign ex_mem_data_o.mem_write  = id_ex_data_i.mem_write;
    assign ex_mem_data_o.funct3     = id_ex_data_i.funct3;      // Pass funct3 for Memory stage (load/store type)
    assign ex_mem_data_o.alu_result = alu_result_internal;      // Result of ALU operation
    assign ex_mem_data_o.rs2_data   = id_ex_data_i.rs2_data;    // Original RS2 data (e.g., for Store instructions)
    assign ex_mem_data_o.rd_addr    = id_ex_data_i.rd_addr;
    assign ex_mem_data_o.pc_plus_4  = id_ex_data_i.pc_plus_4;   // For JAL/JALR writeback

endmodule


--- File: rtl/core/immediate_generator.sv ---
// rtl/core/immediate_generator.sv
`include "common/defines.svh"
`include "common/immediate_types.svh"

module immediate_generator (
    input  logic [`INSTR_WIDTH-1:0] instr_i,
    input  immediate_type_e         imm_type_sel_i, // Selects the type of immediate to generate
    output logic [`DATA_WIDTH-1:0]  imm_ext_o      // Sign-extended immediate value
);

    logic [`DATA_WIDTH-1:0] imm_i_type;
    logic [`DATA_WIDTH-1:0] imm_s_type;
    logic [`DATA_WIDTH-1:0] imm_b_type;
    logic [`DATA_WIDTH-1:0] imm_u_type;
    logic [`DATA_WIDTH-1:0] imm_j_type;
    logic [`DATA_WIDTH-1:0] imm_ishift_type;

    // I-type immediate: instr[31:20] (12 bits)
    assign imm_i_type = {{(`DATA_WIDTH-12){instr_i[31]}}, instr_i[31:20]};

    // S-type immediate: instr[31:25], instr[11:7] (12 bits)
    assign imm_s_type = {{(`DATA_WIDTH-12){instr_i[31]}}, instr_i[31:25], instr_i[11:7]};

    // B-type immediate: {instr[31], instr[7], instr[30:25], instr[11:8], 1'b0} (13 bits)
    // Sign-extended from original bit 12 (instr[31]) of the conceptual 13-bit immediate.
    assign imm_b_type = {{(`DATA_WIDTH-13){instr_i[31]}}, instr_i[31], instr_i[7], instr_i[30:25], instr_i[11:8], 1'b0};

    // U-type immediate: {instr[31:12], 12'b0} (32 bits)
    // Sign-extended from bit 31 of the effective 32-bit immediate. For RV64, this means sign-extend from bit 31 of the value.
    assign imm_u_type = {{(`DATA_WIDTH-32){instr_i[31]}}, instr_i[31:12], 12'h000};

    // J-type immediate: {instr[31], instr[19:12], instr[20], instr[30:21], 1'b0} (21 bits)
    // Sign-extended from original bit 20 (instr[31]) of the conceptual 21-bit immediate.
    assign imm_j_type = {{(`DATA_WIDTH-21){instr_i[31]}}, instr_i[31], instr_i[19:12], instr_i[20], instr_i[30:21], 1'b0};
    assign imm_ishift_type = `DATA_WIDTH'(instr_i[25:20]);

    always_comb begin
        case (imm_type_sel_i)
            IMM_TYPE_I:    imm_ext_o = imm_i_type;
            IMM_TYPE_S:    imm_ext_o = imm_s_type;
            IMM_TYPE_B:    imm_ext_o = imm_b_type;
            IMM_TYPE_U:    imm_ext_o = imm_u_type;
            IMM_TYPE_J:    imm_ext_o = imm_j_type;
            IMM_TYPE_ISHIFT: imm_ext_o = imm_ishift_type;
            IMM_TYPE_NONE: imm_ext_o = `DATA_WIDTH'(0); // Or 'x if preferred for non-existent immediates
            default:       imm_ext_o = `DATA_WIDTH'('x); // Should not happen with valid enum
        endcase
    end

endmodule


--- File: rtl/core/fetch.sv ---
// rtl/core/fetch.sv
`include "common/pipeline_types.svh"

module fetch #(
    parameter string INSTR_MEM_INIT_FILE_PARAM = "", // Parameter for instruction memory init file
    parameter logic [`DATA_WIDTH-1:0] PC_INIT_VALUE_PARAM = `PC_RESET_VALUE // Parameter for initial PC value
)(
    input  logic clk,
    input  logic rst_n,

    // Control signals
    input  logic                       stall_f_i,
    input  logic                       pc_src_e_i,
    input  logic [`DATA_WIDTH-1:0]     pc_target_e_i,

    output if_id_data_t                if_id_data_o
);

    logic [`DATA_WIDTH-1:0] pc_reg;
    logic [`DATA_WIDTH-1:0] pc_next;
    logic [`DATA_WIDTH-1:0] pc_plus_4_temp;
    logic [`INSTR_WIDTH-1:0] instr_mem_data;

    instruction_memory #(
        .MEM_INIT_FILE(INSTR_MEM_INIT_FILE_PARAM)
    ) i_instr_mem (
        .address     (pc_reg),
        .instruction (instr_mem_data)
    );

    assign pc_plus_4_temp = pc_reg + 4;
    assign pc_next = pc_src_e_i ? pc_target_e_i : pc_plus_4_temp;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            pc_reg <= PC_INIT_VALUE_PARAM; // Use parameterized reset value
        end else if (!stall_f_i) begin
            pc_reg <= pc_next;
        end
    end

    assign if_id_data_o.instr      = instr_mem_data;
    assign if_id_data_o.pc         = pc_reg;
    assign if_id_data_o.pc_plus_4  = pc_plus_4_temp;

endmodule


--- File: rtl/core/alu.sv ---
// rtl/core/alu.sv
`include "common/defines.svh"
`include "common/alu_defines.svh" // Will use new defines

module alu (
    input  logic [`DATA_WIDTH-1:0]     operand_a,
    input  logic [`DATA_WIDTH-1:0]     operand_b,
    input  logic [`ALU_CONTROL_WIDTH-1:0] alu_control, // Unified control signal
    output logic [`DATA_WIDTH-1:0]     result,
    output logic                       zero_flag
);

    logic [`DATA_WIDTH-1:0] result_comb;
    logic [5:0]             shift_amount; // For RV64, shift by lower 6 bits of operand_b

    assign shift_amount = operand_b[5:0];

    always_comb begin
        result_comb = {`DATA_WIDTH{1'bx}}; // Default to 'x'

        case (alu_control)
            `ALU_OP_ADD:  result_comb = operand_a + operand_b;
            `ALU_OP_SUB:  result_comb = operand_a - operand_b;
            `ALU_OP_SLL:  result_comb = operand_a << shift_amount;
            `ALU_OP_SLT:  result_comb = ($signed(operand_a) < $signed(operand_b)) ? {{`DATA_WIDTH-1{1'b0}}, 1'b1} : {`DATA_WIDTH{1'b0}};
            `ALU_OP_SLTU: result_comb = (operand_a < operand_b) ? {{`DATA_WIDTH-1{1'b0}}, 1'b1} : {`DATA_WIDTH{1'b0}};
            `ALU_OP_XOR:  result_comb = operand_a ^ operand_b;
            `ALU_OP_SRL:  result_comb = operand_a >> shift_amount;
            `ALU_OP_SRA:  result_comb = $signed(operand_a) >>> shift_amount;
            `ALU_OP_OR:   result_comb = operand_a | operand_b;
            `ALU_OP_AND:  result_comb = operand_a & operand_b;
            // `ALU_OP_PASS_B: result_comb = operand_b; // If we had this explicit op
            default:      result_comb = {`DATA_WIDTH{1'bx}}; // Undefined operation
        endcase
    end

    assign result = result_comb;
    assign zero_flag = (result_comb == {`DATA_WIDTH{1'b0}});

endmodule


--- File: rtl/core/decode.sv ---
// rtl/core/decode.sv
`include "common/pipeline_types.svh"
`include "common/riscv_opcodes.svh" // For opcode/funct defines used in submodules

module decode (
    input  logic clk,
    input  logic rst_n,

    // Input from Fetch (latched by IF/ID register in pipeline.sv)
    input  if_id_data_t     if_id_data_i,

    // Input from Writeback stage for Register File write
    input  rf_write_data_t  writeback_data_i,

    // Output to Execute (to be latched by ID/EX register in pipeline.sv)
    output id_ex_data_t     id_ex_data_o,

    // Outputs for Hazard Unit (direct from instruction)
    output logic [`REG_ADDR_WIDTH-1:0] rs1_addr_d_o,
    output logic [`REG_ADDR_WIDTH-1:0] rs2_addr_d_o
    // rd_addr_d_o is part of id_ex_data_o.rd_addr
);

    // Instruction fields extracted from if_id_data_i.instr
    logic [6:0] opcode;
    logic [`REG_ADDR_WIDTH-1:0] rs1_addr_instr;
    logic [`REG_ADDR_WIDTH-1:0] rs2_addr_instr;
    logic [`REG_ADDR_WIDTH-1:0] rd_addr_instr;
    logic [2:0] funct3_instr;
    logic       funct7_5_instr;

    // Intermediate signals from submodules
    immediate_type_e imm_type_sel_internal;
    logic [`DATA_WIDTH-1:0] rs1_data_from_rf;
    logic [`DATA_WIDTH-1:0] rs2_data_from_rf;
    logic [`DATA_WIDTH-1:0] imm_ext_internal;

    // Decompose instruction from the input structure
    assign opcode         = if_id_data_i.instr[6:0];
    assign rd_addr_instr  = if_id_data_i.instr[11:7];
    assign funct3_instr   = if_id_data_i.instr[14:12];
    assign rs1_addr_instr = if_id_data_i.instr[19:15];
    assign rs2_addr_instr = if_id_data_i.instr[24:20];
    assign funct7_5_instr = if_id_data_i.instr[30];

    // Control Unit instance
    control_unit u_control_unit (
        .op                    (opcode),
        .funct3                (funct3_instr),
        .funct7_5              (funct7_5_instr),
        .reg_write_d_o         (id_ex_data_o.reg_write),
        .result_src_d_o        (id_ex_data_o.result_src),
        .mem_write_d_o         (id_ex_data_o.mem_write),
        .jump_d_o              (id_ex_data_o.jump),
        .branch_d_o            (id_ex_data_o.branch),
        .alu_src_d_o           (id_ex_data_o.alu_src),
        .alu_control_d_o       (id_ex_data_o.alu_control),
        .imm_type_d_o          (imm_type_sel_internal),
        .funct3_d_o            (id_ex_data_o.funct3), // Directly passes funct3_instr
        .op_a_sel_d_o          (id_ex_data_o.op_a_sel),
        .pc_target_src_sel_d_o (id_ex_data_o.pc_target_src_sel)
    );

    // Register File instance
    register_file u_register_file (
        .clk               (clk),
        .rst_n             (rst_n),
        .rs1_addr_i        (rs1_addr_instr),
        .rs1_data_o        (rs1_data_from_rf),
        .rs2_addr_i        (rs2_addr_instr),
        .rs2_data_o        (rs2_data_from_rf),
        .rd_write_en_wb_i  (writeback_data_i.reg_write_en),
        .rd_addr_wb_i      (writeback_data_i.rd_addr),
        .rd_data_wb_i      (writeback_data_i.result_to_rf)
    );

    // Immediate Generator instance
    immediate_generator u_immediate_generator (
        .instr_i           (if_id_data_i.instr),
        .imm_type_sel_i    (imm_type_sel_internal),
        .imm_ext_o         (imm_ext_internal)
    );

    // Assign data fields to the output structure
    // PC and PC+4 values are passed through from IF/ID stage data
    assign id_ex_data_o.pc         = if_id_data_i.pc;
    assign id_ex_data_o.pc_plus_4  = if_id_data_i.pc_plus_4;

    // Register data from RF
    assign id_ex_data_o.rs1_data   = rs1_data_from_rf;
    assign id_ex_data_o.rs2_data   = rs2_data_from_rf;

    // Extended immediate value
    assign id_ex_data_o.imm_ext    = imm_ext_internal;

    // Register addresses (rs1_addr and rs2_addr are also output separately for Hazard Unit)
    assign id_ex_data_o.rs1_addr   = rs1_addr_instr;
    assign id_ex_data_o.rs2_addr   = rs2_addr_instr;
    assign id_ex_data_o.rd_addr    = rd_addr_instr;

    // Outputs for Hazard Unit (direct from instruction fields)
    assign rs1_addr_d_o = rs1_addr_instr;
    assign rs2_addr_d_o = rs2_addr_instr;

endmodule


--- File: rtl/core/writeback_stage.sv ---
// rtl/core/writeback_stage.sv
`include "common/pipeline_types.svh"

module writeback_stage (
    // Input from Memory (latched by MEM/WB register in pipeline.sv)
    input  mem_wb_data_t           mem_wb_data_i,

    // Output to Register File write port (directly connected in pipeline.sv)
    output rf_write_data_t         rf_write_data_o
);

    logic [`DATA_WIDTH-1:0] result_selected_for_rf;

    // MUX to select the data to be written back to the register file
    always_comb begin
        case (mem_wb_data_i.result_src)
            2'b00:  result_selected_for_rf = mem_wb_data_i.alu_result;    // Result from ALU
            2'b01:  result_selected_for_rf = mem_wb_data_i.read_data_mem; // Data from memory
            2'b10:  result_selected_for_rf = mem_wb_data_i.pc_plus_4;     // PC+4 for JAL/JALR
            default: result_selected_for_rf = `DATA_WIDTH'('x); // Should not happen
        endcase
    end

    // Assign outputs for the register file write data structure
    assign rf_write_data_o.reg_write_en = mem_wb_data_i.reg_write;
    assign rf_write_data_o.rd_addr      = mem_wb_data_i.rd_addr;
    assign rf_write_data_o.result_to_rf = result_selected_for_rf;

endmodule


--- File: rtl/core/pipeline_control.sv ---
// rtl/core/pipeline_control.sv
`include "common/pipeline_types.svh"

module pipeline_control (
    // Inputs from various pipeline stages (latched values in pipeline.sv)
    input  if_id_data_t    if_id_data_i,     // For rs1_addr_d, rs2_addr_d (extracted from instr)
    input  id_ex_data_t    id_ex_data_i,     // For RdE, RegWriteE, ResultSrcE (load-use) and Rs1E, Rs2E (for forwarding)
    input  ex_mem_data_t   ex_mem_data_i,    // For RdM, RegWriteM (forwarding)
    input  mem_wb_data_t   mem_wb_data_i,    // For RdW, RegWriteW (forwarding)

    input  logic           pc_src_from_ex_i, // PCSrcE from Execute stage output

    // Output structure with all hazard control signals
    output hazard_control_t hazard_ctrl_o
);

    logic load_use_hazard;
    logic is_load_in_ex;

    // Extract rs1_addr and rs2_addr for the instruction currently in Decode stage,
    // which will be in Execute stage when these forwarding/stall signals are applied.
    // These correspond to Rs1D and Rs2D from the diagram for load-use hazard detection.
    logic [`REG_ADDR_WIDTH-1:0] rs1_addr_d_from_instr;
    logic [`REG_ADDR_WIDTH-1:0] rs2_addr_d_from_instr;

    assign rs1_addr_d_from_instr = if_id_data_i.instr[19:15];
    assign rs2_addr_d_from_instr = if_id_data_i.instr[24:20];


    // ** 1. Load-Use Hazard Detection & Stall Generation **
    // An instruction in EX is a load, and its destination (RdE) is a source for an instruction in ID.
    assign is_load_in_ex = (id_ex_data_i.result_src == 2'b01); // Data from memory

    assign load_use_hazard = is_load_in_ex && id_ex_data_i.reg_write && (id_ex_data_i.rd_addr != 0) &&
                             ((id_ex_data_i.rd_addr == rs1_addr_d_from_instr) || (id_ex_data_i.rd_addr == rs2_addr_d_from_instr));

    assign hazard_ctrl_o.stall_f = load_use_hazard;
    assign hazard_ctrl_o.stall_d = load_use_hazard; // Stall IF/ID register (holds current content)

    // ** 2. Flush Generation **
    // FlushD (IF/ID output becomes NOP): if branch/jump taken in EX.
    // FlushE (ID/EX output becomes NOP): if load-use stall OR branch/jump taken in EX.
    assign hazard_ctrl_o.flush_d = pc_src_from_ex_i;
    assign hazard_ctrl_o.flush_e = load_use_hazard || pc_src_from_ex_i;


    // ** 3. Forwarding Logic **
    // Forwarding for instruction currently in Execute stage.
    // Rs1E and Rs2E for the current EX instruction are id_ex_data_i.rs1_addr and id_ex_data_i.rs2_addr.

    // Forward for Operand A (connected to ALU operand A input in Execute)
    always_comb begin
        hazard_ctrl_o.forward_a_e = 2'b00; // Default: No forward

        // Check EX/MEM stage hazard: if instr in MEM writes to RdM, and RdM is Rs1 of instr in EX
        if (ex_mem_data_i.reg_write && (ex_mem_data_i.rd_addr != 0) &&
            (ex_mem_data_i.rd_addr == id_ex_data_i.rs1_addr)) begin
            hazard_ctrl_o.forward_a_e = 2'b10; // Forward from EX/MEM (RdM path)
        end
        // Check MEM/WB stage hazard: if instr in WB writes to RdW, and RdW is Rs1 of instr in EX
        // (and not already covered by EX/MEM forward)
        else if (mem_wb_data_i.reg_write && (mem_wb_data_i.rd_addr != 0) &&
                 (mem_wb_data_i.rd_addr == id_ex_data_i.rs1_addr)) begin
            hazard_ctrl_o.forward_a_e = 2'b01; // Forward from MEM/WB (RdW path)
        end
    end

    // Forward for Operand B (connected to ALU operand B input in Execute)
    always_comb begin
        hazard_ctrl_o.forward_b_e = 2'b00; // Default: No forward

        if (ex_mem_data_i.reg_write && (ex_mem_data_i.rd_addr != 0) &&
            (ex_mem_data_i.rd_addr == id_ex_data_i.rs2_addr)) begin
            hazard_ctrl_o.forward_b_e = 2'b10; // Forward from EX/MEM
        end
        else if (mem_wb_data_i.reg_write && (mem_wb_data_i.rd_addr != 0) &&
                 (mem_wb_data_i.rd_addr == id_ex_data_i.rs2_addr)) begin
            hazard_ctrl_o.forward_b_e = 2'b01; // Forward from MEM/WB
        end
    end

endmodule


--- File: rtl/core/instruction_memory.sv ---
// rtl/core/instruction_memory.sv
`include "common/defines.svh"

module instruction_memory (
    input  logic [`DATA_WIDTH-1:0] address,
    output logic [`INSTR_WIDTH-1:0] instruction
);

    parameter string MEM_INIT_FILE = ""; // Parameter for memory initialization file
    localparam ROM_SIZE = 256; // Number of instructions
    logic [`INSTR_WIDTH-1:0] mem[ROM_SIZE-1:0];

    initial begin
        // Default initialize all memory to NOP
        for (int i = 0; i < ROM_SIZE; i++) begin
            mem[i] = `NOP_INSTRUCTION;
        end

        // if (MEM_INIT_FILE != "") begin
        //     $readmemh(MEM_INIT_FILE, mem);
        // end else begin
            // Hardcoded test instructions for basic pipeline test
            mem[0] = 32'h00100093; // addi x1, x0, 1
            mem[1] = 32'h00200113; // addi x2, x0, 2
            mem[2] = 32'h00300193; // addi x3, x0, 3 (rd=x3)
            mem[3] = 32'h00400213; // addi x4, x0, 4 (rd=x4)
            // $display("Instruction memory initialized with basic addi test program.");
        // end
    end

    assign instruction = (address[`DATA_WIDTH-1:2] < ROM_SIZE) ?
                     mem[address[`DATA_WIDTH-1:2]] :
                     `NOP_INSTRUCTION; // Return NOP for out-of-bounds access

endmodule


--- File: rtl/core/memory_stage.sv ---
// rtl/core/memory_stage.sv
`include "common/pipeline_types.svh"

module memory_stage #(
    parameter string DATA_MEM_INIT_FILE_PARAM = "" // Parameter for data memory init file
)(
    input  logic clk,
    input  logic rst_n,
    input  ex_mem_data_t           ex_mem_data_i,
    output mem_wb_data_t           mem_wb_data_o
);

    logic [`DATA_WIDTH-1:0] mem_read_data_internal;

    data_memory #(
        .DATA_MEM_INIT_FILE(DATA_MEM_INIT_FILE_PARAM)
    ) u_data_memory (
        .clk            (clk),
        .rst_n          (rst_n),
        .addr_i         (ex_mem_data_i.alu_result),
        .write_data_i   (ex_mem_data_i.rs2_data),
        .mem_write_en_i (ex_mem_data_i.mem_write),
        .funct3_i       (ex_mem_data_i.funct3),
        .read_data_o    (mem_read_data_internal)
    );

    assign mem_wb_data_o.reg_write      = ex_mem_data_i.reg_write;
    assign mem_wb_data_o.result_src     = ex_mem_data_i.result_src;
    assign mem_wb_data_o.read_data_mem  = mem_read_data_internal;
    assign mem_wb_data_o.alu_result     = ex_mem_data_i.alu_result;
    assign mem_wb_data_o.pc_plus_4      = ex_mem_data_i.pc_plus_4;
    assign mem_wb_data_o.rd_addr        = ex_mem_data_i.rd_addr;

endmodule


--- File: rtl/common/riscv_opcodes.svh ---
// rtl/common/riscv_opcodes.svh
`ifndef RISCV_OPCODES_SVH
`define RISCV_OPCODES_SVH

// Opcodes (bottom 7 bits of instruction)
`define OPCODE_LUI        7'b0110111 // Load Upper Immediate
`define OPCODE_AUIPC      7'b0010111 // Add Upper Immediate to PC
`define OPCODE_JAL        7'b1101111 // Jump and Link
`define OPCODE_JALR       7'b1100111 // Jump and Link Register
`define OPCODE_BRANCH     7'b1100011 // Conditional Branches (BEQ, BNE, etc.)
`define OPCODE_LOAD       7'b0000011 // Loads (LB, LH, LW, LD, LBU, LHU, LWU)
`define OPCODE_STORE      7'b0100011 // Stores (SB, SH, SW, SD)
`define OPCODE_OP_IMM   7'b0010011 // Immediate Arithmetic/Logic (ADDI, SLTI, etc.)
`define OPCODE_OP         7'b0110011 // Register-Register Arithmetic/Logic (ADD, SUB, etc.)
`define OPCODE_MISC_MEM 7'b0001111 // FENCE, FENCE.I
`define OPCODE_SYSTEM     7'b1110011 // ECALL, EBREAK, CSR instructions

// Funct3 codes for OP_IMM, OP, BRANCH, LOAD, STORE, JALR
// For OP_IMM & OP
`define FUNCT3_ADDI       3'b000 // ADDI
`define FUNCT3_ADD_SUB    3'b000 // ADD/SUB (OP)
`define FUNCT3_SLLI       3'b001 // SLLI (OP_IMM)
`define FUNCT3_SLL        3'b001 // SLL (OP)
`define FUNCT3_SLTI       3'b010 // SLTI (OP_IMM)
`define FUNCT3_SLT        3'b010 // SLT (OP)
`define FUNCT3_SLTIU      3'b011 // SLTIU (OP_IMM)
`define FUNCT3_SLTU       3'b011 // SLTU (OP)
`define FUNCT3_XORI       3'b100 // XORI (OP_IMM)
`define FUNCT3_XOR        3'b100 // XOR (OP)
`define FUNCT3_SRLI_SRAI  3'b101 // SRLI/SRAI (OP_IMM) - Distinguish by funct7
`define FUNCT3_SRL_SRA    3'b101 // SRL/SRA (OP)     - Distinguish by funct7
`define FUNCT3_ORI        3'b110 // ORI (OP_IMM)
`define FUNCT3_OR         3'b110 // OR (OP)
`define FUNCT3_ANDI       3'b111 // ANDI (OP_IMM)
`define FUNCT3_AND        3'b111 // AND (OP)

// For BRANCH
`define FUNCT3_BEQ        3'b000
`define FUNCT3_BNE        3'b001
`define FUNCT3_BLT        3'b100
`define FUNCT3_BGE        3'b101
`define FUNCT3_BLTU       3'b110
`define FUNCT3_BGEU       3'b111

// For LOAD
`define FUNCT3_LB         3'b000
`define FUNCT3_LH         3'b001
`define FUNCT3_LW         3'b010
`define FUNCT3_LD         3'b011 // RV64
`define FUNCT3_LBU        3'b100
`define FUNCT3_LHU        3'b101
`define FUNCT3_LWU        3'b110 // RV64

// For STORE
`define FUNCT3_SB         3'b000
`define FUNCT3_SH         3'b001
`define FUNCT3_SW         3'b010
`define FUNCT3_SD         3'b011 // RV64

// For JALR
`define FUNCT3_JALR       3'b000

// Funct7 codes (or relevant bits)
// For ADD/SUB and SRA/SRL distinction in OP and OP_IMM type instructions.
// For R-type (OP) and I-type shifts (OP_IMM), bit 5 of funct7 (instr[30]) is often used.
`define FUNCT7_5_SUB_ALT  1'b1 // For SUB, SRA, SRAI (funct7[5])
`define FUNCT7_5_ADD_MAIN 1'b0 // For ADD, SRL, SRLI (funct7[5])
// `define FUNCT7_SRL        7'b0000000 (SRL, SRLI, SRLW, SRLIW)
// `define FUNCT7_SRA        7'b0100000 (SRA, SRAI, SRAW, SRAIW)
// `define FUNCT7_ADD        7'b0000000
// `define FUNCT7_SUB        7'b0100000

`endif // RISCV_OPCODES_SVH


--- File: rtl/common/immediate_types.svh ---
// rtl/common/immediate_types.svh
`ifndef IMMEDIATE_TYPES_SVH
`define IMMEDIATE_TYPES_SVH

// Enum for selecting immediate type in immediate_generator
// This allows the control unit to specify exactly which format to use.
typedef enum logic [2:0] {
    IMM_TYPE_NONE, // For R-type or when immediate is not used by ALU operand B or for address calculation
    IMM_TYPE_I,    // I-type (ADDI, LW, JALR)
    IMM_TYPE_S,    // S-type (SW)
    IMM_TYPE_B,    // B-type (Branches)
    IMM_TYPE_U,    // U-type (LUI, AUIPC)
    IMM_TYPE_J,     // J-type (JAL)
    IMM_TYPE_ISHIFT // Новый тип для SLLI, SRLI, SRAI
} immediate_type_e;

`endif // IMMEDIATE_TYPES_SVH


--- File: rtl/common/pipeline_types.svh ---
// common/pipeline_types.svh
`ifndef PIPELINE_TYPES_SVH
`define PIPELINE_TYPES_SVH

`include "common/defines.svh"
`include "common/alu_defines.svh"
`include "common/control_signals_defines.svh"
`include "common/immediate_types.svh"

// Data from Fetch to Decode
typedef struct packed {
    logic [`INSTR_WIDTH-1:0]    instr;
    logic [`DATA_WIDTH-1:0]     pc;
    logic [`DATA_WIDTH-1:0]     pc_plus_4;
} if_id_data_t;

// Data from Decode to Execute
typedef struct packed {
    // Control Signals
    logic                       reg_write;
    logic [1:0]                 result_src; // 00:ALU, 01:MemRead, 10:PC+4
    logic                       mem_write;
    logic                       jump;
    logic                       branch;
    logic                       alu_src;    // Selects ALU OpB (0: Reg_Rs2, 1: Imm)
    logic [`ALU_CONTROL_WIDTH-1:0] alu_control;
    alu_a_src_sel_e             op_a_sel;
    pc_target_src_sel_e         pc_target_src_sel;
    logic [2:0]                 funct3;     // Pipelined funct3

    // Data
    logic [`DATA_WIDTH-1:0]     pc;
    logic [`DATA_WIDTH-1:0]     pc_plus_4;
    logic [`DATA_WIDTH-1:0]     rs1_data;
    logic [`DATA_WIDTH-1:0]     rs2_data;
    logic [`DATA_WIDTH-1:0]     imm_ext;

    // Register Addresses
    logic [`REG_ADDR_WIDTH-1:0] rs1_addr;
    logic [`REG_ADDR_WIDTH-1:0] rs2_addr;
    logic [`REG_ADDR_WIDTH-1:0] rd_addr;
} id_ex_data_t;

// Data from Execute to Memory
typedef struct packed {
    // Control Signals
    logic                       reg_write;
    logic [1:0]                 result_src;
    logic                       mem_write;
    logic [2:0]                 funct3;     // For memory access type

    // Data
    logic [`DATA_WIDTH-1:0]     alu_result; // Effective address or ALU result
    logic [`DATA_WIDTH-1:0]     rs2_data;   // Data to be stored
    logic [`DATA_WIDTH-1:0]     pc_plus_4;  // For JAL/JALR writeback

    // Register Address
    logic [`REG_ADDR_WIDTH-1:0] rd_addr;
} ex_mem_data_t;

// Data from Memory to Writeback
typedef struct packed {
    // Control Signals
    logic                       reg_write;
    logic [1:0]                 result_src;

    // Data
    logic [`DATA_WIDTH-1:0]     read_data_mem; // Data read from memory
    logic [`DATA_WIDTH-1:0]     alu_result;    // ALU result from EX
    logic [`DATA_WIDTH-1:0]     pc_plus_4;     // PC+4 from EX

    // Register Address
    logic [`REG_ADDR_WIDTH-1:0] rd_addr;
} mem_wb_data_t;

// Data for actual writeback to Register File (subset of mem_wb_data_t + selected result)
typedef struct packed {
    logic                       reg_write_en;
    logic [`REG_ADDR_WIDTH-1:0] rd_addr;
    logic [`DATA_WIDTH-1:0]     result_to_rf;
} rf_write_data_t;


// Control signals from Hazard Unit
typedef struct packed {
    logic       stall_f;
    logic       stall_d; // Stalls IF/ID latching new data
    logic       flush_d; // Clears IF/ID outputs (inserts NOP)
    logic       flush_e; // Clears ID/EX outputs (inserts NOP)
    logic [1:0] forward_a_e;
    logic [1:0] forward_b_e;
} hazard_control_t;


// NOP default values for pipeline data structures
// Used for reset and flushing stages

localparam if_id_data_t NOP_IF_ID_DATA = '{
    instr:      `NOP_INSTRUCTION,
    pc:         `PC_RESET_VALUE, // Or other defined "safe" PC
    pc_plus_4:  `PC_RESET_VALUE + 4 // Or other defined "safe" PC+4
};

localparam id_ex_data_t NOP_ID_EX_DATA = '{
    reg_write:          1'b0,
    result_src:         2'b00, // ALU Result
    mem_write:          1'b0,
    jump:               1'b0,
    branch:             1'b0,
    alu_src:            1'b0,  // Operand B from Reg
    alu_control:        `ALU_OP_ADD, // Default ADD
    op_a_sel:           ALU_A_SRC_RS1,
    pc_target_src_sel:  PC_TARGET_SRC_PC_PLUS_IMM,
    funct3:             3'b000,
    pc:                 `PC_RESET_VALUE,
    pc_plus_4:          `PC_RESET_VALUE + 4,
    rs1_data:           `DATA_WIDTH'(0),
    rs2_data:           `DATA_WIDTH'(0),
    imm_ext:            `DATA_WIDTH'(0),
    rs1_addr:           `REG_ADDR_WIDTH'(0),
    rs2_addr:           `REG_ADDR_WIDTH'(0),
    rd_addr:            `REG_ADDR_WIDTH'(0)
};

localparam ex_mem_data_t NOP_EX_MEM_DATA = '{
    reg_write:          1'b0,
    result_src:         2'b00,
    mem_write:          1'b0,
    funct3:             3'b000,
    alu_result:         `DATA_WIDTH'(0),
    rs2_data:           `DATA_WIDTH'(0),
    pc_plus_4:          `PC_RESET_VALUE + 4,
    rd_addr:            `REG_ADDR_WIDTH'(0)
};

localparam mem_wb_data_t NOP_MEM_WB_DATA = '{
    reg_write:          1'b0,
    result_src:         2'b00,
    read_data_mem:      `DATA_WIDTH'(0),
    alu_result:         `DATA_WIDTH'(0),
    pc_plus_4:          `PC_RESET_VALUE + 4,
    rd_addr:            `REG_ADDR_WIDTH'(0)
};

`endif // PIPELINE_TYPES_SVH


--- File: rtl/common/defines.svh ---
`ifndef COMMON_DEFINES_SVH
`define COMMON_DEFINES_SVH

`define DATA_WIDTH 64
`define INSTR_WIDTH 32
`define REG_ADDR_WIDTH 5
`define PC_RESET_VALUE 64'h00000000 // Standard PC reset value
`define NOP_INSTRUCTION 32'h00000013 // addi x0, x0, 0

`endif


--- File: rtl/common/control_signals_defines.svh ---
// rtl/common/control_signals_defines.svh
`ifndef CONTROL_SIGNALS_DEFINES_SVH
`define CONTROL_SIGNALS_DEFINES_SVH

// Selector for ALU Operand A
typedef enum logic [1:0] {
    ALU_A_SRC_RS1,   // Select RS1 data
    ALU_A_SRC_PC,    // Select PC
    ALU_A_SRC_ZERO   // Select constant Zero (for LUI: 0 + Imm)
    // ALU_A_SRC_FWD // Will be handled by forwarding logic, this selects the *original* source
} alu_a_src_sel_e;

// Selector for PC Target Address source in Execute stage
typedef enum logic [0:0] { // Only two main sources for now
    PC_TARGET_SRC_PC_PLUS_IMM, // Target = PC + Immediate (for Branch, JAL)
    PC_TARGET_SRC_ALU_JALR     // Target = (ALU_Result from RS1+Imm) & ~1 (for JALR)
} pc_target_src_sel_e;

`endif // CONTROL_SIGNALS_DEFINES_SVH


--- File: rtl/common/alu_defines.svh ---
// rtl/common/alu_defines.svh
`ifndef ALU_DEFINES_SVH
`define ALU_DEFINES_SVH

`define ALU_CONTROL_WIDTH 4 // Needs 4 bits for ~10 operations

// Unified ALU Control Signals
// R-Type / I-Type Arithmetic
`define ALU_OP_ADD  4'b0000 // Addition
`define ALU_OP_SUB  4'b0001 // Subtraction
`define ALU_OP_SLL  4'b0010 // Shift Left Logical
`define ALU_OP_SLT  4'b0011 // Set Less Than (Signed)
`define ALU_OP_SLTU 4'b0100 // Set Less Than (Unsigned)
`define ALU_OP_XOR  4'b0101 // XOR
`define ALU_OP_SRL  4'b0110 // Shift Right Logical
`define ALU_OP_SRA  4'b0111 // Shift Right Arithmetic
`define ALU_OP_OR   4'b1000 // OR
`define ALU_OP_AND  4'b1001 // AND

// Potentially other operations for specific instructions if needed, e.g., pass Operand B
// `define ALU_OP_PASS_B 4'b1010 // Pass operand_b directly (e.g., for LUI if srcA is 0)
// For LUI, it's rd = imm. If ALU is used, srcA=0, srcB=imm, op=ADD. So ALU_OP_ADD works.
// For AUIPC, it's rd = pc + imm. srcA=PC, srcB=imm, op=ADD. So ALU_OP_ADD works.

`endif // ALU_DEFINES_SVH


--- File: rtl/pipeline.sv ---
// rtl/pipeline.sv
`default_nettype none
`timescale 1ns/1ps

`include "common/pipeline_types.svh"

module pipeline #(
    parameter string INSTR_MEM_INIT_FILE = "",
    parameter logic [`DATA_WIDTH-1:0] PC_START_ADDR = `PC_RESET_VALUE,
    parameter string DATA_MEM_INIT_FILE = "" // Added for data memory initialization
)(
    input  logic clk,
    input  logic rst_n,

    // Optional debug outputs
    output logic [`DATA_WIDTH-1:0] debug_pc_f,
    output logic [`INSTR_WIDTH-1:0] debug_instr_f,
    output logic                   debug_reg_write_wb,
    output logic [`REG_ADDR_WIDTH-1:0] debug_rd_addr_wb,
    output logic [`DATA_WIDTH-1:0] debug_result_w
);

    // Pipeline stage data registers (latches between stages)
    if_id_data_t    if_id_data_q, if_id_data_d;
    id_ex_data_t    id_ex_data_q, id_ex_data_d;
    ex_mem_data_t   ex_mem_data_q, ex_mem_data_d;
    mem_wb_data_t   mem_wb_data_q, mem_wb_data_d;

    if_id_data_t    if_id_data_from_fetch;
    id_ex_data_t    id_ex_data_from_decode;
    ex_mem_data_t   ex_mem_data_from_execute;
    mem_wb_data_t   mem_wb_data_from_memory;
    rf_write_data_t rf_write_data_from_wb;

    logic                   pc_src_ex_o;
    logic [`DATA_WIDTH-1:0] pc_target_ex_o;
    hazard_control_t        hazard_ctrl;

    logic [`REG_ADDR_WIDTH-1:0] rs1_addr_from_decode;
    logic [`REG_ADDR_WIDTH-1:0] rs2_addr_from_decode;

    fetch #(
        .INSTR_MEM_INIT_FILE_PARAM(INSTR_MEM_INIT_FILE),
        .PC_INIT_VALUE_PARAM(PC_START_ADDR)
    ) u_fetch (
        .clk                (clk),
        .rst_n              (rst_n),
        .stall_f_i          (hazard_ctrl.stall_f),
        .pc_src_e_i         (pc_src_ex_o),
        .pc_target_e_i      (pc_target_ex_o),
        .if_id_data_o       (if_id_data_from_fetch)
    );

    decode u_decode (
        .clk                (clk),
        .rst_n              (rst_n),
        .if_id_data_i       (if_id_data_q),
        .writeback_data_i   (rf_write_data_from_wb),
        .id_ex_data_o       (id_ex_data_from_decode),
        .rs1_addr_d_o       (rs1_addr_from_decode),
        .rs2_addr_d_o       (rs2_addr_from_decode)
    );

    execute u_execute (
        .id_ex_data_i       (id_ex_data_q),
        .forward_data_mem_i (ex_mem_data_q.alu_result),
        .forward_data_wb_i  (rf_write_data_from_wb.result_to_rf),
        .forward_a_e_i      (hazard_ctrl.forward_a_e),
        .forward_b_e_i      (hazard_ctrl.forward_b_e),
        .ex_mem_data_o      (ex_mem_data_from_execute),
        .pc_src_o           (pc_src_ex_o),
        .pc_target_addr_o   (pc_target_ex_o)
    );

    // Pass DATA_MEM_INIT_FILE to memory_stage
    memory_stage #(
        .DATA_MEM_INIT_FILE_PARAM(DATA_MEM_INIT_FILE)
    ) u_memory_stage (
        .clk                (clk),
        .rst_n              (rst_n),
        .ex_mem_data_i      (ex_mem_data_q),
        .mem_wb_data_o      (mem_wb_data_from_memory)
    );

    writeback_stage u_writeback_stage (
        .mem_wb_data_i      (mem_wb_data_q),
        .rf_write_data_o    (rf_write_data_from_wb)
    );

    pipeline_control u_pipeline_control (
        .if_id_data_i       (if_id_data_q),
        .id_ex_data_i       (id_ex_data_q),
        .ex_mem_data_i      (ex_mem_data_q),
        .mem_wb_data_i      (mem_wb_data_q),
        .pc_src_from_ex_i   (pc_src_ex_o),
        .hazard_ctrl_o      (hazard_ctrl)
    );

    // Pipeline register logic (same as before)
    // IF/ID Register Logic
    always_comb begin
        if (hazard_ctrl.flush_d) begin
            if_id_data_d = NOP_IF_ID_DATA;
            // Если flush, PC в NOP должен быть "разумным", NOP_IF_ID_DATA.pc уже PC_RESET_VALUE
            // Если PC_START_ADDR != PC_RESET_VALUE, то NOP_IF_ID_DATA.pc может быть не тем, что мы хотим для PC_START_ADDR
            // Однако, pc_reg в fetch уже инициализирован PC_START_ADDR.
            // if_id_data_from_fetch.pc будет PC_START_ADDR на первом такте.
        end else if (hazard_ctrl.stall_d) begin
            if_id_data_d = if_id_data_q;
        end else begin
            if_id_data_d = if_id_data_from_fetch;
        end
    end
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            if_id_data_q <= NOP_IF_ID_DATA; // NOP_IF_ID_DATA.pc == PC_RESET_VALUE
            // Явно установим PC поля, если PC_START_ADDR отличается от PC_RESET_VALUE
            // или если хотим гарантировать PC_START_ADDR при сбросе этого регистра
            if_id_data_q.pc <= PC_START_ADDR;
            if_id_data_q.pc_plus_4 <= PC_START_ADDR + 4;
        end else begin
            if_id_data_q <= if_id_data_d;
        end
    end

    // ID/EX Register Logic
    always_comb begin
        if (hazard_ctrl.flush_e) begin
            id_ex_data_d = NOP_ID_EX_DATA; // NOP_ID_EX_DATA.pc == PC_RESET_VALUE
        end else begin
            id_ex_data_d = id_ex_data_from_decode;
        end
    end
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            id_ex_data_q <= NOP_ID_EX_DATA;
            // Аналогично для ID/EX
            id_ex_data_q.pc <= PC_START_ADDR; // PC инструкции, которая была бы здесь при сбросе
            id_ex_data_q.pc_plus_4 <= PC_START_ADDR + 4;
        end else begin
            id_ex_data_q <= id_ex_data_d;
        end
    end

    // EX/MEM Register Logic
    assign ex_mem_data_d = ex_mem_data_from_execute;
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            ex_mem_data_q <= NOP_EX_MEM_DATA;
            // PC поля в NOP_EX_MEM_DATA также могут нуждаться в PC_START_ADDR
            // ex_mem_data_q.pc_plus_4 <= PC_START_ADDR + 4; // Если pc_plus_4 хранится и здесь
        end else begin
            ex_mem_data_q <= ex_mem_data_d;
        end
    end

    // MEM/WB Register Logic
    assign mem_wb_data_d = mem_wb_data_from_memory;
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            mem_wb_data_q <= NOP_MEM_WB_DATA;
            // mem_wb_data_q.pc_plus_4 <= PC_START_ADDR + 4; // Если pc_plus_4 хранится и здесь
        end else begin
            mem_wb_data_q <= mem_wb_data_d;
        end
    end

    assign debug_pc_f         = if_id_data_from_fetch.pc;
    assign debug_instr_f      = if_id_data_from_fetch.instr;
    assign debug_reg_write_wb = rf_write_data_from_wb.reg_write_en;
    assign debug_rd_addr_wb   = rf_write_data_from_wb.rd_addr;
    assign debug_result_w     = rf_write_data_from_wb.result_to_rf;

endmodule


--- File: tests/integration/simple_addi_expected_rf.txt ---
# Expected final register values for simple_addi.s
# Reg Value
1 0xa         // x1 should be 10
2 0x14        // x2 should be 20
3 0x1e        // x3 should be 30
# Other registers assumed 0 or "don't care"


--- File: tests/integration/CMakeLists.txt ---
# tests/integration/CMakeLists.txt
cmake_minimum_required(VERSION 3.16)

# Файл C++ тестбенча для конвейера (будет один для всех интеграционных тестов конвейера)
set(PIPELINE_TB_CPP_FILE ${CMAKE_CURRENT_SOURCE_DIR}/pipeline_tb.cpp)

# Проверка наличия скрипта конвертации
set(ELF_TO_MEMH_SCRIPT ${CMAKE_SOURCE_DIR}/scripts/elf_to_memh.py)
if(NOT EXISTS ${ELF_TO_MEMH_SCRIPT})
    message(FATAL_ERROR "Script elf_to_memh.py not found at ${ELF_TO_MEMH_SCRIPT}")
endif()

message(STATUS ${RISCV_AS})
message(STATUS ${RISCV_LD})
message(STATUS ${RISCV_OBJCOPY})
message(STATUS ${RISCV_READELF})

# Проверка наличия утилит тулчейна (уже должны быть найдены в корневом CMakeLists.txt)
if(NOT RISCV_AS OR NOT RISCV_LD OR NOT RISCV_OBJCOPY OR NOT RISCV_READELF)
    message(FATAL_ERROR "RISC-V toolchain utilities (AS, LD, OBJCOPY, READELF) not found by root CMake. Ensure they are in PATH or configure them.")
endif()

# --- Функция для добавления интеграционного теста конвейера ---
function(add_pipeline_integration_test test_name asm_file_rel expected_rf_file_rel num_cycles pc_start_hex)
    set(VERILOG_TOP_MODULE "pipeline") # Наш основной модуль конвейера

    # Исходные RTL файлы для всего конвейера
    set(PIPELINE_RTL_FILES
        ${CMAKE_SOURCE_DIR}/rtl/pipeline.sv
        ${CMAKE_SOURCE_DIR}/rtl/core/fetch.sv
        ${CMAKE_SOURCE_DIR}/rtl/core/decode.sv
        ${CMAKE_SOURCE_DIR}/rtl/core/execute.sv
        ${CMAKE_SOURCE_DIR}/rtl/core/memory_stage.sv
        ${CMAKE_SOURCE_DIR}/rtl/core/writeback_stage.sv
        ${CMAKE_SOURCE_DIR}/rtl/core/pipeline_control.sv
        ${CMAKE_SOURCE_DIR}/rtl/core/alu.sv
        ${CMAKE_SOURCE_DIR}/rtl/core/control_unit.sv
        ${CMAKE_SOURCE_DIR}/rtl/core/data_memory.sv
        ${CMAKE_SOURCE_DIR}/rtl/core/immediate_generator.sv
        ${CMAKE_SOURCE_DIR}/rtl/core/instruction_memory.sv
        ${CMAKE_SOURCE_DIR}/rtl/core/register_file.sv
    )
    set(RTL_INCLUDE_PATH ${CMAKE_SOURCE_DIR}/rtl) # Для `include "common/..."

    # Пути и имена файлов для конкретного теста
    set(TEST_CASE_DIR ${CMAKE_CURRENT_SOURCE_DIR}) # Где лежат .s и .txt файлы
    set(OBJ_DIR ${CMAKE_CURRENT_BINARY_DIR}/obj_dir_pipeline_${test_name})
    set(VERILATOR_EXECUTABLE ${OBJ_DIR}/V${VERILOG_TOP_MODULE})

    set(ASM_FILE_FULL_PATH "${TEST_CASE_DIR}/${asm_file_rel}")
    set(ASM_OBJECT_FILE "${OBJ_DIR}/${test_name}.o")
    set(LINKED_ELF_FILE "${OBJ_DIR}/${test_name}.elf")
    set(HEX_MEM_FILENAME_PARAM_VALUE "${test_name}_instr.hex") # Это будет передано в Verilog
    set(GENERATED_HEX_MEM_FILE_FULL_PATH "${OBJ_DIR}/${HEX_MEM_FILENAME_PARAM_VALUE}")
    set(EXPECTED_RF_FILE_FULL_PATH "${TEST_CASE_DIR}/${expected_rf_file_rel}")

    # Verilog параметры (значения для -G...)
    set(VERILOG_PARAM_INSTR_MEM_FILE_DEF "-GINSTR_MEM_INIT_FILE=\"${HEX_MEM_FILENAME_PARAM_VALUE}\"") # Важно: кавычки для строки!
    set(VERILOG_PARAM_PC_START_ADDR_DEF "-GPC_START_ADDR=64'h${pc_start_hex}")
    # DATA_MEM_INIT_FILE пока не используем для простых тестов, но можно добавить
    # set(VERILOG_PARAM_DATA_MEM_FILE_DEF "-GDATA_MEM_INIT_FILE=\"some_data.hex\"")


    # C++ defines (для -D...)
    set(FINAL_CXX_FLAGS "${CMAKE_CXX_FLAGS}") # Начальные флаги из CMake
    list(APPEND FINAL_CXX_FLAGS "-DPIPELINE_TEST_NAME_STR_RAW=${test_name}")
    list(APPEND FINAL_CXX_FLAGS "-DEXPECTED_RF_FILE_PATH_STR_RAW=${EXPECTED_RF_FILE_FULL_PATH}")
    list(APPEND FINAL_CXX_FLAGS "-DNUM_CYCLES_TO_RUN=${num_cycles}")
    string(REPLACE ";" " " FINAL_CXX_FLAGS_STR "${FINAL_CXX_FLAGS}") # Преобразовать список в строку

    set(BUILD_TARGET_NAME build_pipeline_test_${test_name})
    add_custom_target(${BUILD_TARGET_NAME} ALL
        COMMAND ${CMAKE_COMMAND} -E make_directory ${OBJ_DIR}
        COMMAND ${RISCV_AS} -march=rv64i -mabi=lp64 -o ${ASM_OBJECT_FILE} ${ASM_FILE_FULL_PATH}
            COMMENT "Assembling ${asm_file_rel}"
        COMMAND ${RISCV_LD} --no-relax -Ttext=0x${pc_start_hex} -o ${LINKED_ELF_FILE} ${ASM_OBJECT_FILE}
            COMMENT "Linking ${test_name}.o to ${test_name}.elf"
        COMMAND ${Python3_EXECUTABLE} "${ELF_TO_MEMH_SCRIPT}"
                "${LINKED_ELF_FILE}"
                "${GENERATED_HEX_MEM_FILE_FULL_PATH}"
                --objcopy "${RISCV_OBJCOPY}" --readelf "${RISCV_READELF}" --section ".text" --wordsize 4
            COMMENT "Converting ${test_name}.elf to ${HEX_MEM_FILENAME_PARAM_VALUE}"
        COMMAND ${PROJECT_VERILATOR_EXECUTABLE}
                -Wall --Wno-fatal --cc --exe --build --trace
                --top-module ${VERILOG_TOP_MODULE}
                -I${RTL_INCLUDE_PATH}
                ${VERILOG_PARAM_INSTR_MEM_FILE_DEF}
                ${VERILOG_PARAM_PC_START_ADDR_DEF}
                ${PIPELINE_RTL_FILES}
                "${PIPELINE_TB_CPP_FILE}"
                --Mdir "${OBJ_DIR}"
                -CFLAGS "${FINAL_CXX_FLAGS_STR}" # Передаем объединенную строку флагов
        DEPENDS ${PIPELINE_TB_CPP_FILE} ${ASM_FILE_FULL_PATH} ${EXPECTED_RF_FILE_FULL_PATH} ${ELF_TO_MEMH_SCRIPT} ${PIPELINE_RTL_FILES}
        COMMENT "Verilating and Building pipeline for test: ${test_name}"
        VERBATIM
        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    )

    # Цель для запуска теста
    set(RUN_TARGET_NAME run_pipeline_test_${test_name})
    add_test(NAME ${test_name}_pipeline_integration COMMAND "${VERILATOR_EXECUTABLE}")
    set_tests_properties(${test_name}_pipeline_integration PROPERTIES
        WORKING_DIRECTORY ${OBJ_DIR} 
        DEPENDS ${BUILD_TARGET_NAME}
    )
    add_custom_target(${RUN_TARGET_NAME}
        COMMAND "${VERILATOR_EXECUTABLE}"
        DEPENDS ${BUILD_TARGET_NAME}
        WORKING_DIRECTORY ${OBJ_DIR}
        COMMENT "Running pipeline test: ${test_name}"
        VERBATIM
    )

    if(TARGET run_all_integration_tests)
        add_dependencies(run_all_integration_tests ${RUN_TARGET_NAME})
    endif()

    message(STATUS "Configured pipeline integration test: ${test_name}")
endfunction()

# Общая цель для запуска всех интеграционных тестов (можно будет добавить в CTest)
add_custom_target(run_all_integration_tests)
add_dependencies(tests_full run_all_integration_tests)

# --- Определение конкретных тестов ---
# add_pipeline_integration_test(<test_name> <asm_file> <expected_file> <num_cycles> <pc_start_hex_no_0x>)
add_pipeline_integration_test(simple_addi "simple_addi.s" "simple_addi_expected_rf.txt" 15 "0")
# Добавьте другие тесты здесь...
# add_pipeline_integration_test(data_hazard_test "data_hazard.s" "data_hazard_expected.txt" 20 "100")


--- File: tests/integration/pipeline_tb.cpp ---
// tests/integration/pipeline_tb.cpp
#include "Vpipeline.h" // Generated by Verilator
#include "verilated_vcd_c.h"
#include "verilated.h"

#include <iostream>
#include <fstream>
#include <iomanip>
#include <string>
#include <vector>
#include <sstream>
#include <map> // For expected register values

// --- Макросы, определяемые CMake ---
#ifndef PIPELINE_TEST_NAME_STR_RAW
#error "PIPELINE_TEST_NAME_STR_RAW not defined! Pass it via CFLAGS from CMake."
#endif

#ifndef EXPECTED_RF_FILE_PATH_STR_RAW
#error "EXPECTED_RF_FILE_PATH_STR_RAW not defined! Pass it via CFLAGS from CMake."
#endif

#ifndef NUM_CYCLES_TO_RUN
#error "NUM_CYCLES_TO_RUN not defined! Pass it via CFLAGS from CMake."
#endif

// Вспомогательные макросы для превращения в строку
#define STRINGIFY_HELPER(x) #x
#define STRINGIFY(x) STRINGIFY_HELPER(x)

// Глобальные переменные из макросов
const std::string G_PIPELINE_TEST_NAME = STRINGIFY(PIPELINE_TEST_NAME_STR_RAW);
const std::string G_EXPECTED_RF_FILE_PATH = STRINGIFY(EXPECTED_RF_FILE_PATH_STR_RAW);
const int G_NUM_CYCLES_TO_RUN = NUM_CYCLES_TO_RUN;

// Специальное значение для "не важно" или "нет записи" в файле ожидаемых результатов
const uint64_t VAL_X = 0xDEADBEEFDEADBEEF; // Просто уникальное значение

vluint64_t sim_time = 0;

void tick(Vpipeline* top, VerilatedVcdC* tfp) {
    top->clk = 0;
    top->eval();
    if (tfp) tfp->dump(sim_time);
    sim_time++;

    top->clk = 1;
    top->eval();
    if (tfp) tfp->dump(sim_time);
    sim_time++;
}

void reset_pipeline(Vpipeline* top, VerilatedVcdC* tfp, int cycles = 5) {
    std::cout << "Resetting pipeline for test: " << G_PIPELINE_TEST_NAME << "..." << std::endl;
    top->rst_n = 0;
    for (int i = 0; i < cycles; ++i) {
        tick(top, tfp);
    }
    top->rst_n = 1;
    tick(top, tfp);
    std::cout << "Pipeline reset complete." << std::endl;
}

// Функция для загрузки ожидаемых состояний регистров
// Формат файла:
// # Комментарии начинаются с #
// <имя_регистра_без_x> <ожидаемое_значение_hex>
// Например:
// 1 0x1
// 2 0x2
// Можно также добавить строки "CYCLE <N>" для проверки на конкретном цикле,
// но для начала просто финальные значения.
bool load_expected_rf_states(const std::string& filepath, std::map<int, uint64_t>& expected_regs) {
    std::ifstream file(filepath);
    if (!file.is_open()) {
        std::cerr << "ERROR: Could not open expected RF file: " << filepath << std::endl;
        return false;
    }
    std::string line;
    int line_num = 0;
    while (std::getline(file, line)) {
        line_num++;
        if (line.empty() || line[0] == '#') {
            continue;
        }
        std::stringstream ss(line);
        std::string reg_name_str;
        std::string val_str;
        ss >> reg_name_str >> val_str;

        if (reg_name_str.empty() || val_str.empty()) {
            std::cerr << "Warning: Skipping malformed line " << line_num << " in " << filepath << ": '" << line << "'" << std::endl;
            continue;
        }
        try {
            int reg_idx = std::stoi(reg_name_str);
            if (reg_idx < 0 || reg_idx > 31) {
                 std::cerr << "Warning: Invalid register index " << reg_idx << " at line " << line_num << " in " << filepath << ". Skipping." << std::endl;
                 continue;
            }
            if (val_str == "x" || val_str == "X") {
                 expected_regs[reg_idx] = VAL_X;
            } else {
                expected_regs[reg_idx] = std::stoull(val_str, nullptr, 16);
            }
        } catch (const std::exception& e) {
            std::cerr << "Error parsing line " << line_num << " in " << filepath << ": '" << line << "'. Error: " << e.what() << std::endl;
            return false;
        }
    }
    file.close();
    return true;
}


int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vpipeline* top = new Vpipeline;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    std::string vcd_file_name = G_PIPELINE_TEST_NAME + "_pipeline.vcd";
    tfp->open(vcd_file_name.c_str());

    std::cout << "Pipeline Test Case: " << G_PIPELINE_TEST_NAME << std::endl;
    std::cout << "Expected RF file: " << G_EXPECTED_RF_FILE_PATH << std::endl;
    std::cout << "Cycles to run: " << G_NUM_CYCLES_TO_RUN << std::endl;

    std::map<int, uint64_t> expected_final_regs;
    if (!G_EXPECTED_RF_FILE_PATH.empty() && G_EXPECTED_RF_FILE_PATH != "none") {
        if (!load_expected_rf_states(G_EXPECTED_RF_FILE_PATH, expected_final_regs)) {
            if (tfp) tfp->close();
            delete top;
            return 1; // Error loading expected results
        }
    }

    reset_pipeline(top, tfp);

    std::cout << "\nSimulating " << G_NUM_CYCLES_TO_RUN << " cycles...\n" << std::endl;
    std::cout << "Cycle | PC_Fetch | Instr_Fetch      | WB? | WB_Rd | WB_Data" << std::endl;
    std::cout << "------|----------|------------------|-----|-------|-------------------" << std::endl;

    for (int cycle = 0; cycle < G_NUM_CYCLES_TO_RUN; ++cycle) {
        tick(top, tfp);
        std::cout << std::setw(5) << std::dec << (sim_time / 2) << " | "
                  << "0x" << std::setw(8) << std::setfill('0') << std::hex << top->debug_pc_f << " | "
                  << "0x" << std::setw(16) << std::setfill('0') << std::hex << top->debug_instr_f << " | "
                  << std::setw(3) << std::dec << (top->debug_reg_write_wb ? "Y" : "N") << " | "
                  << std::setw(5) << std::dec << (top->debug_reg_write_wb ? (int)top->debug_rd_addr_wb : -1) << " | "
                  << (top->debug_reg_write_wb ? ("0x" + [&]{std::stringstream ss; ss << std::setw(16) << std::setfill('0') << std::hex << top->debug_result_w; return ss.str(); }())
                                              : "------------------")
                  << std::setfill(' ') << std::dec << std::endl;
    }

    bool test_passed = true;
    if (!expected_final_regs.empty()) {
        std::cout << "\nChecking final register states:" << std::endl;
        for (const auto& pair : expected_final_regs) {
            int reg_idx = pair.first;
            uint64_t expected_val = pair.second;
            if (reg_idx == 0 && expected_val != 0 && expected_val != VAL_X) {
                 std::cout << "  WARN: Expected value for x0 is non-zero (" << std::hex << expected_val << "). x0 must be 0." << std::endl;
            }
            if (reg_idx == 0) continue; // x0 is always 0, no need to check write

            // Accessing internal register file state - requires Verilator public access or DPI
            // Assuming Vpipeline_tb->u_pipeline->u_decode->u_register_file->regs[reg_idx]
            // This path needs to be correct based on your Verilator setup.
            // If using the debug_rf_xN outputs in pipeline_tb.sv, that's an alternative.
            // For now, this is a placeholder for how you'd access it.
            // We'll need to ensure 'regs' array in 'register_file.sv' is accessible.
            // Or, modify pipeline_tb.sv to expose specific registers for checking.
            //
            // For now, we can't directly verify from Vpipeline.
            // We would check the `debug_result_w` on the cycle it's written,
            // or add specific DPI functions to read registers.
            //
            // Let's assume we have debug ports for a few registers in Vpipeline_tb for now,
            // or we rely on `top->debug_result_w` at the right cycle.
            // The provided Vpipeline does not expose internal RF state directly.
            // The expected_rf_file should correspond to values observed on debug_result_w
            // during the cycles where debug_reg_write_wb is true for that register.

            // This check is more conceptual for now if we don't have direct RF access in tb.
            // The current testbench structure from your friend checks wd3_o (our debug_result_w) per cycle.
            // Let's adapt to that philosophy. The provided cpp file checks wd3_o per cycle.

            // This C++ testbench will simply run and produce a VCD.
            // The pass/fail will be determined by comparing the VCD or console output to expected values.
            // The example pipeline_tb.cpp from context was comparing wd3_o per cycle.
        }
    }


    std::cout << "\nSimulation finished for: " << G_PIPELINE_TEST_NAME << std::endl;
    std::cout << "Please check VCD: " << vcd_file_name << std::endl;

    if (tfp) tfp->close();
    delete top;

    // For now, all tests are considered "passing" if they complete simulation.
    // Actual verification would involve comparing VCD or output logs.
    // Or implementing cycle-by-cycle checks as in your friend's pipeline_tb.cpp.
    // The CMake function 'add_test' relies on the executable returning 0 for pass, non-zero for fail.
    // We'll enhance this later.
    return EXIT_SUCCESS;
}


--- File: tests/integration/simple_addi.s ---
.section .text
.global _start

_start:
    addi x1, x0, 10
    addi x2, x0, 20
    add  x3, x1, x2
    nop
    nop
    nop


--- File: tests/CMakeLists.txt ---
set(RTL_INCLUDE_PATH ${CMAKE_SOURCE_DIR}/rtl)

function(add_verilator_test module_name)
    set(OBJ_DIR ${CMAKE_CURRENT_BINARY_DIR}/obj_dir_${module_name})
    set(CPP_TESTBENCH_FILE ${CMAKE_CURRENT_SOURCE_DIR}/${module_name}.cpp)

    set(RTL_SOURCES "")
    foreach(rtl_file ${ARGN})
        list(APPEND RTL_SOURCES "${rtl_file}")
    endforeach()

    add_custom_target(build-unit-test-${module_name} ALL
        COMMAND ${CMAKE_COMMAND} -E make_directory ${OBJ_DIR}
        COMMAND ${PROJECT_VERILATOR_EXECUTABLE}
                -Wall --Wno-fatal --cc --exe --build --trace
                --top-module ${module_name}
                -I${RTL_INCLUDE_PATH}
                ${RTL_SOURCES}
                ${CPP_TESTBENCH_FILE}
                --Mdir "${OBJ_DIR}"
                -CFLAGS "-std=c++17 -Wall"
        DEPENDS ${RTL_SOURCES} ${CPP_TESTBENCH_FILE}
        COMMENT "Verilating and Building executable for ${module_name}"
        VERBATIM
        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    )

    add_custom_target(run-unit-test-${module_name}
        COMMAND "${OBJ_DIR}/V${module_name}"
        DEPENDS "build-unit-test-${module_name}"
        WORKING_DIRECTORY ${OBJ_DIR}
        COMMENT "Running Verilated test for ${module_name}"
        VERBATIM
    )

    if(TARGET tests_full)
        add_dependencies(tests_full run-unit-test-${module_name})
    endif()
endfunction()


add_custom_target(tests_full)
add_subdirectory(unit)
add_subdirectory(integration)

# if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/integration/CMakeLists.txt)
#     add_subdirectory(integration)
#     if(TARGET tests_full AND TARGET run_all_integration_tests)
#         add_dependencies(tests_full run_all_integration_tests)
#     endif()
# endif()


--- File: tests/unit/memory_stage_tb.sv ---
`include "common/defines.svh"

module memory_stage_tb (
    input  logic clk,
    input  logic rst_n,

    // Inputs to memory_stage (simulating outputs of EX/MEM register)
    input  logic       i_reg_write_m,
    input  logic [1:0] i_result_src_m,
    input  logic       i_mem_write_m,
    input  logic [2:0] i_funct3_m,       // For load/store type

    input  logic [`DATA_WIDTH-1:0]     i_alu_result_m, // Address for memory or result from ALU
    input  logic [`DATA_WIDTH-1:0]     i_rs2_data_m,   // Data to store in memory
    input  logic [`REG_ADDR_WIDTH-1:0] i_rd_addr_m,
    input  logic [`DATA_WIDTH-1:0]     i_pc_plus_4_m,

    // Outputs from memory_stage (these would go to MEM/WB register)
    output logic       o_reg_write_w,
    output logic [1:0] o_result_src_w,
    output logic [`DATA_WIDTH-1:0] o_read_data_w,  // Data read from memory
    output logic [`DATA_WIDTH-1:0] o_alu_result_w, // ALU result passed through
    output logic [`REG_ADDR_WIDTH-1:0] o_rd_addr_w,
    output logic [`DATA_WIDTH-1:0] o_pc_plus_4_w
    // o_mem_write_w не существует, т.к. mem_write потребляется в этой стадии
);

    memory_stage u_memory_stage (
        .clk            (clk),
        .rst_n          (rst_n),

        .reg_write_m_i  (i_reg_write_m),
        .result_src_m_i (i_result_src_m),
        .mem_write_m_i  (i_mem_write_m),
        .funct3_m_i     (i_funct3_m),
        .alu_result_m_i (i_alu_result_m),
        .rs2_data_m_i   (i_rs2_data_m),
        .rd_addr_m_i    (i_rd_addr_m),
        .pc_plus_4_m_i  (i_pc_plus_4_m),

        .reg_write_w_o  (o_reg_write_w),
        .result_src_w_o (o_result_src_w),
        .read_data_w_o  (o_read_data_w),
        .alu_result_w_o (o_alu_result_w),
        .rd_addr_w_o    (o_rd_addr_w),
        .pc_plus_4_w_o  (o_pc_plus_4_w)
    );

    // Для доступа к содержимому data_memory из C++ теста, нам нужен способ
    // либо вынести data_memory на верхний уровень тестбенча, либо использовать DPI.
    // Для простоты, пока не будем напрямую читать память из C++ в этом юнит-тесте,
    // а будем полагаться на чтение через Load инструкции.
    // Более полный тест data_memory был бы отдельным.
    // Здесь мы тестируем memory_stage и его взаимодействие с data_memory.

endmodule


--- File: tests/unit/control_unit_tb.cpp ---
// tests/unit/control_unit_tb.cpp
#include "Vcontrol_unit_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <string>
#include <map> // Not strictly needed here, but useful for complex setups
#include <bitset>

// --- C++ Constants Mirroring Verilog Defines ---
// From common/alu_defines.svh
const int ALU_CONTROL_WIDTH_CPP_CU = 4; // Suffix to avoid clash if alu.cpp linked
const uint8_t ALU_OP_ADD_CU  = 0b0000;
const uint8_t ALU_OP_SUB_CU  = 0b0001;
const uint8_t ALU_OP_SLL_CU  = 0b0010;
const uint8_t ALU_OP_SLT_CU  = 0b0011;
const uint8_t ALU_OP_SLTU_CU = 0b0100;
const uint8_t ALU_OP_XOR_CU  = 0b0101;
const uint8_t ALU_OP_SRL_CU  = 0b0110;
const uint8_t ALU_OP_SRA_CU  = 0b0111;
const uint8_t ALU_OP_OR_CU   = 0b1000;
const uint8_t ALU_OP_AND_CU  = 0b1001;

// From common/immediate_types.svh
enum ImmediateTypeCppCU {
    IMM_TYPE_NONE_CU, IMM_TYPE_I_CU, IMM_TYPE_S_CU, IMM_TYPE_B_CU,
    IMM_TYPE_U_CU, IMM_TYPE_J_CU, IMM_TYPE_ISHIFT_CU
};

// From common/control_signals_defines.svh
enum AluASrcSelCppCU { ALU_A_SRC_RS1_CU, ALU_A_SRC_PC_CU, ALU_A_SRC_ZERO_CU };
enum PcTargetSrcSelCppCU { PC_TARGET_SRC_PC_PLUS_IMM_CU, PC_TARGET_SRC_ALU_JALR_CU };

// From common/riscv_opcodes.svh
// Opcodes
const uint8_t OPCODE_LUI_CU        = 0b0110111;
const uint8_t OPCODE_AUIPC_CU      = 0b0010111;
const uint8_t OPCODE_JAL_CU        = 0b1101111;
const uint8_t OPCODE_JALR_CU       = 0b1100111;
const uint8_t OPCODE_BRANCH_CU     = 0b1100011;
const uint8_t OPCODE_LOAD_CU       = 0b0000011;
const uint8_t OPCODE_STORE_CU      = 0b0100011;
const uint8_t OPCODE_OP_IMM_CU   = 0b0010011;
const uint8_t OPCODE_OP_CU         = 0b0110011;
// Funct3 (examples, add more as needed for specific tests)
const uint8_t FUNCT3_ADDI_CU       = 0b000;
const uint8_t FUNCT3_SLLI_CU       = 0b001;
const uint8_t FUNCT3_SLTI_CU       = 0b010;
const uint8_t FUNCT3_SRLI_SRAI_CU  = 0b101;
const uint8_t FUNCT3_ADD_SUB_CU    = 0b000;
const uint8_t FUNCT3_BEQ_CU        = 0b000;
const uint8_t FUNCT3_BNE_CU        = 0b001;
const uint8_t FUNCT3_BLT_CU        = 0b100;
const uint8_t FUNCT3_BGE_CU        = 0b101;
const uint8_t FUNCT3_BLTU_CU       = 0b110;
const uint8_t FUNCT3_BGEU_CU       = 0b111;
// Funct7_5
const uint8_t FUNCT7_5_SRA_ALT_CU  = 1; // For SRA/SRAI/SUB
const uint8_t FUNCT7_5_ADD_MAIN_CU = 0; // For SRL/SRLI/ADD


vluint64_t sim_time_cu = 0;

void eval_cu(Vcontrol_unit_tb* dut, VerilatedVcdC* tfp) {
    dut->eval();
    if (tfp) tfp->dump(sim_time_cu);
    // sim_time_cu++; // For combinational, advance time per test case
}

struct ControlUnitTestCase {
    std::string name;
    uint8_t     op;
    uint8_t     funct3;
    uint8_t     funct7_5; // Only 1 bit

    // Expected outputs
    bool        exp_reg_write;
    uint8_t     exp_result_src; // 2 bits
    bool        exp_mem_write;
    bool        exp_jump;
    bool        exp_branch;
    bool        exp_alu_src_b;   // Operand B: 0 for Reg, 1 for Imm
    uint8_t     exp_alu_control;
    ImmediateTypeCppCU exp_imm_type;
    // exp_funct3_d is implicitly tc.funct3
    AluASrcSelCppCU exp_op_a_sel;
    PcTargetSrcSelCppCU exp_pc_target_sel;
};

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vcontrol_unit_tb* top = new Vcontrol_unit_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_control_unit.vcd");

    std::cout << "Starting Control Unit Testbench" << std::endl;

    std::vector<ControlUnitTestCase> test_cases = {
        // LUI
        {"LUI", OPCODE_LUI_CU, 0, 0, true, 0b00, false, false, false, true, ALU_OP_ADD_CU, IMM_TYPE_U_CU, ALU_A_SRC_ZERO_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        // AUIPC
        {"AUIPC", OPCODE_AUIPC_CU, 0, 0, true, 0b00, false, false, false, true, ALU_OP_ADD_CU, IMM_TYPE_U_CU, ALU_A_SRC_PC_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        // JAL
        {"JAL", OPCODE_JAL_CU, 0, 0, true, 0b10, false, true, false, true, ALU_OP_ADD_CU, IMM_TYPE_J_CU, ALU_A_SRC_PC_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        // JALR
        {"JALR", OPCODE_JALR_CU, FUNCT3_ADDI_CU, 0, true, 0b10, false, true, false, true, ALU_OP_ADD_CU, IMM_TYPE_I_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_ALU_JALR_CU},
        // Branches (BEQ, BNE, BLT, BGE, BLTU, BGEU)
        {"BEQ", OPCODE_BRANCH_CU, FUNCT3_BEQ_CU, 0, false,0b00,false,false,true, false,ALU_OP_SUB_CU, IMM_TYPE_B_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        {"BNE", OPCODE_BRANCH_CU, FUNCT3_BNE_CU, 0, false,0b00,false,false,true, false,ALU_OP_SUB_CU, IMM_TYPE_B_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        {"BLT", OPCODE_BRANCH_CU, FUNCT3_BLT_CU, 0, false,0b00,false,false,true, false,ALU_OP_SLT_CU, IMM_TYPE_B_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        {"BGE", OPCODE_BRANCH_CU, FUNCT3_BGE_CU, 0, false,0b00,false,false,true, false,ALU_OP_SLT_CU, IMM_TYPE_B_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        {"BLTU",OPCODE_BRANCH_CU, FUNCT3_BLTU_CU,0, false,0b00,false,false,true, false,ALU_OP_SLTU_CU,IMM_TYPE_B_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        {"BGEU",OPCODE_BRANCH_CU, FUNCT3_BGEU_CU,0, false,0b00,false,false,true, false,ALU_OP_SLTU_CU,IMM_TYPE_B_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        // Load (e.g. LW, funct3=010)
        {"LOAD (LW)", OPCODE_LOAD_CU, 0b010, 0, true, 0b01, false, false, false, true, ALU_OP_ADD_CU, IMM_TYPE_I_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        // Store (e.g. SW, funct3=010)
        {"STORE (SW)", OPCODE_STORE_CU, 0b010, 0, false,0b00,true, false, false, true, ALU_OP_ADD_CU, IMM_TYPE_S_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        // OP_IMM (ADDI, SLTI, SLTIU, XORI, ORI, ANDI, SLLI, SRLI, SRAI)
        {"ADDI", OPCODE_OP_IMM_CU, FUNCT3_ADDI_CU, 0,                true,0b00,false,false,false, true, ALU_OP_ADD_CU, IMM_TYPE_I_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        {"SLLI", OPCODE_OP_IMM_CU, FUNCT3_SLLI_CU, FUNCT7_5_ADD_MAIN_CU, true,0b00,false,false,false, true, ALU_OP_SLL_CU, IMM_TYPE_ISHIFT_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        {"SRLI", OPCODE_OP_IMM_CU, FUNCT3_SRLI_SRAI_CU, FUNCT7_5_ADD_MAIN_CU,true,0b00,false,false,false, true, ALU_OP_SRL_CU, IMM_TYPE_ISHIFT_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        {"SRAI", OPCODE_OP_IMM_CU, FUNCT3_SRLI_SRAI_CU, FUNCT7_5_SRA_ALT_CU, true,0b00,false,false,false, true, ALU_OP_SRA_CU, IMM_TYPE_ISHIFT_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        // OP (ADD, SUB, SLL, SLT, SLTU, XOR, SRL, SRA, OR, AND)
        {"ADD", OPCODE_OP_CU, FUNCT3_ADD_SUB_CU, FUNCT7_5_ADD_MAIN_CU, true,0b00,false,false,false, false,ALU_OP_ADD_CU, IMM_TYPE_NONE_CU,ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        {"SUB", OPCODE_OP_CU, FUNCT3_ADD_SUB_CU, FUNCT7_5_SRA_ALT_CU,  true,0b00,false,false,false, false,ALU_OP_SUB_CU, IMM_TYPE_NONE_CU,ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        {"SRA", OPCODE_OP_CU, FUNCT3_SRLI_SRAI_CU, FUNCT7_5_SRA_ALT_CU,true,0b00,false,false,false, false,ALU_OP_SRA_CU, IMM_TYPE_NONE_CU,ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        // Unknown Opcode
        {"Unknown Opcode", 0x7F, 0, 0, false,0b00,false,false,false,false,ALU_OP_ADD_CU, IMM_TYPE_NONE_CU,ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU}
    };

    int passed_count = 0;
    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name
                  << " (op=0x" << std::hex << (int)tc.op
                  << ", f3=0x" << (int)tc.funct3
                  << ", f7_5=" << (int)tc.funct7_5 << std::dec << ")" << std::endl;

        top->i_op = tc.op;
        top->i_funct3 = tc.funct3;
        top->i_funct7_5 = tc.funct7_5;

        eval_cu(top, tfp);
        sim_time_cu++;

        bool current_pass = true;
        if(top->o_reg_write_d != tc.exp_reg_write) {std::cout << "  FAIL: RegWrite. Exp=" << tc.exp_reg_write << " Got=" << (int)top->o_reg_write_d << std::endl; current_pass=false;}
        if(top->o_result_src_d != tc.exp_result_src) {std::cout << "  FAIL: ResultSrc. Exp=" << (int)tc.exp_result_src << " Got=" << (int)top->o_result_src_d << std::endl; current_pass=false;}
        if(top->o_mem_write_d != tc.exp_mem_write) {std::cout << "  FAIL: MemWrite. Exp=" << tc.exp_mem_write << " Got=" << (int)top->o_mem_write_d << std::endl; current_pass=false;}
        if(top->o_jump_d != tc.exp_jump) {std::cout << "  FAIL: Jump. Exp=" << tc.exp_jump << " Got=" << (int)top->o_jump_d << std::endl; current_pass=false;}
        if(top->o_branch_d != tc.exp_branch) {std::cout << "  FAIL: Branch. Exp=" << tc.exp_branch << " Got=" << (int)top->o_branch_d << std::endl; current_pass=false;}
        if(top->o_alu_src_d != tc.exp_alu_src_b) {std::cout << "  FAIL: AluSrcB. Exp=" << tc.exp_alu_src_b << " Got=" << (int)top->o_alu_src_d << std::endl; current_pass=false;}
        if(top->o_alu_control_d != tc.exp_alu_control) {std::cout << "  FAIL: AluControl. Exp=0b" << std::bitset<ALU_CONTROL_WIDTH_CPP_CU>(tc.exp_alu_control) << " Got=0b" << std::bitset<ALU_CONTROL_WIDTH_CPP_CU>(top->o_alu_control_d) << std::endl; current_pass=false;}
        if(top->o_imm_type_d != static_cast<uint8_t>(tc.exp_imm_type)) {std::cout << "  FAIL: ImmType. Exp=" << (int)tc.exp_imm_type << " Got=" << (int)top->o_imm_type_d << std::endl; current_pass=false;}
        if(top->o_funct3_d != tc.funct3) {std::cout << "  FAIL: Funct3Out. Exp=0b" << std::bitset<3>(tc.funct3) << " Got=0b" << std::bitset<3>(top->o_funct3_d) << std::endl; current_pass=false;} // Funct3 should pass through
        if(top->o_op_a_sel_d != static_cast<uint8_t>(tc.exp_op_a_sel)) {std::cout << "  FAIL: OpASel. Exp=" << (int)tc.exp_op_a_sel << " Got=" << (int)top->o_op_a_sel_d << std::endl; current_pass=false;}
        if(top->o_pc_target_src_sel_d != static_cast<uint8_t>(tc.exp_pc_target_sel)) {std::cout << "  FAIL: PcTargetSel. Exp=" << (int)tc.exp_pc_target_sel << " Got=" << (int)top->o_pc_target_src_sel_d << std::endl; current_pass=false;}

        if (current_pass) {
            std::cout << "  PASS" << std::endl;
            passed_count++;
        } else {
            std::cout << "  FAILED" << std::endl;
        }
    }

    std::cout << "\nControl Unit Testbench Finished. Passed " << passed_count << "/" << test_cases.size() << " tests." << std::endl;

    if (tfp) tfp->close();
    delete top;
    return (passed_count == test_cases.size()) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/immediate_generator_tb.cpp ---
// tests/unit/immediate_generator_tb.cpp
#include "Vimmediate_generator_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h" // Optional for VCD

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <string>

// C++ enum equivalent for immediate_type_e
enum ImmediateTypeCpp {
    IMM_TYPE_NONE_CPP,
    IMM_TYPE_I_CPP,
    IMM_TYPE_S_CPP,
    IMM_TYPE_B_CPP,
    IMM_TYPE_U_CPP,
    IMM_TYPE_J_CPP,
    IMM_TYPE_ISHIFT_CPP
};

vluint64_t sim_time_immgen = 0;

void eval_immgen(Vimmediate_generator_tb* dut, VerilatedVcdC* tfp) {
    dut->eval();
    if (tfp) {
        tfp->dump(sim_time_immgen);
    }
    // sim_time_immgen++; // For combinational, time can be advanced per test case
}

// Helper function to construct instruction bits for testing immediates
// This is crucial for precisely setting immediate fields.
// Fields: opcode(6:0), rd(11:7), funct3(14:12), rs1(19:15), rs2(24:20), imm_generic(31:20 or other)
// For simplicity, we'll focus on setting the immediate bits directly within a pseudo-instruction.
// More complex: functions to generate full valid instructions for each type.

// For I-type: imm[11:0] is in instr[31:20]
uint32_t instr_i_type(uint16_t imm12) {
    return (uint32_t(imm12 & 0xFFF) << 20);
}

// For S-type: imm[11:5] in instr[31:25], imm[4:0] in instr[11:7]
uint32_t instr_s_type(uint16_t imm12) {
    return ((uint32_t(imm12 >> 5) & 0x7F) << 25) | ((uint32_t(imm12 & 0x1F)) << 7);
}

// For B-type: imm[12|10:5|4:1|11] (13-bit, LSB is implicit 0)
// imm_val is the actual signed offset (e.g., +20, -8).
// The immediate encoded in instruction is imm_val >> 1.
uint32_t instr_b_type(int16_t signed_offset_val) {
    uint16_t imm13_shifted = uint16_t(signed_offset_val >> 1); // Value to encode
    uint32_t instr = 0;
    instr |= ((uint32_t(imm13_shifted >> 11) & 0x1) << 31); // imm[12]
    instr |= ((uint32_t(imm13_shifted >> 4) & 0x3F) << 25); // imm[10:5]
    instr |= ((uint32_t(imm13_shifted >> 0) & 0xF) << 8);   // imm[4:1]
    instr |= ((uint32_t(imm13_shifted >> 10) & 0x1) << 7);  // imm[11]
    return instr;
}

// For U-type: imm[31:12] in instr[31:12]
uint32_t instr_u_type(uint32_t imm20) { // imm20 is the raw 20-bit value for bits 31:12
    return (uint32_t(imm20 & 0xFFFFF) << 12);
}

// For J-type: imm[20|10:1|11|19:12] (21-bit, LSB is implicit 0)
// imm_val is the actual signed offset.
uint32_t instr_j_type(int32_t signed_offset_val) {
    uint32_t imm21_shifted = uint32_t(signed_offset_val >> 1); // Value to encode
    uint32_t instr = 0;
    instr |= ((uint32_t(imm21_shifted >> 19) & 0x1) << 31);  // imm[20]
    instr |= ((uint32_t(imm21_shifted >> 0) & 0x3FF) << 21); // imm[10:1]
    instr |= ((uint32_t(imm21_shifted >> 10) & 0x1) << 20);  // imm[11]
    instr |= ((uint32_t(imm21_shifted >> 11) & 0xFF) << 12); // imm[19:12]
    return instr;
}

// For ISHIFT-type (RV64): shamt[5:0] in instr[25:20]
// Other bits (e.g. instr[31:26] for SRAI) are part of opcode/funct7
uint32_t instr_ishift_type(uint8_t shamt6, uint8_t fixed_upper_bits = 0) {
    // fixed_upper_bits would be 0b010000 for SRAI's instr[31:26]
    // For SLLI/SRLI it's 0b000000
    return (uint32_t(fixed_upper_bits & 0x3F) << 26) | (uint32_t(shamt6 & 0x3F) << 20);
}


struct ImmGenTestCase {
    std::string name;
    uint32_t    instruction_bits; // The full instruction word
    ImmediateTypeCpp imm_type;
    uint64_t    expected_imm_ext;
};

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vimmediate_generator_tb* top = new Vimmediate_generator_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_immediate_generator.vcd");

    std::cout << "Starting Immediate Generator Testbench" << std::endl;

    std::vector<ImmGenTestCase> test_cases = {
        // I-Type
        {"I-Type positive", instr_i_type(100), IMM_TYPE_I_CPP, 100},
        {"I-Type negative", instr_i_type(0xFFF), IMM_TYPE_I_CPP, 0xFFFFFFFFFFFFFFFFULL}, // -1 (12-bit 0xFFF)
        {"I-Type max pos", instr_i_type(0x7FF), IMM_TYPE_I_CPP, 0x7FF}, // 2047
        {"I-Type min neg", instr_i_type(0x800), IMM_TYPE_I_CPP, 0xFFFFFFFFFFFFF800ULL}, // -2048
        {"I-Type zero", instr_i_type(0), IMM_TYPE_I_CPP, 0},

        // S-Type
        {"S-Type positive", instr_s_type(200), IMM_TYPE_S_CPP, 200},
        {"S-Type negative", instr_s_type(0xF00), IMM_TYPE_S_CPP, 0xFFFFFFFFFFFFFF00ULL}, // -256 (0xF00 is 1111 0000 0000, sign bit is instr[31])
        {"S-Type max pos", instr_s_type(0x7FF), IMM_TYPE_S_CPP, 0x7FF},
        {"S-Type min neg", instr_s_type(0x800), IMM_TYPE_S_CPP, 0xFFFFFFFFFFFFF800ULL},

        // B-Type
        {"B-Type positive offset +20", instr_b_type(20), IMM_TYPE_B_CPP, 20},
        {"B-Type negative offset -20", instr_b_type(-20), IMM_TYPE_B_CPP, (uint64_t)-20},
        {"B-Type max pos offset (4094)", instr_b_type(4094), IMM_TYPE_B_CPP, 4094}, // 2^12 - 2
        {"B-Type min neg offset (-4096)", instr_b_type(-4096), IMM_TYPE_B_CPP, (uint64_t)-4096},

        // U-Type (imm is shifted left by 12 bits internally by LUI/AUIPC, generator outputs imm_val for bits 31:12, zero-extended lower)
        // The generator itself outputs {instr[31:12], 12'h0}, sign-extended from bit 31 of this 32-bit value.
        {"U-Type 0xABCD0", instr_u_type(0xABCD0), IMM_TYPE_U_CPP, 0xFFFFFFFFABCD0000ULL}, // A=1010, so MSB is 1
        {"U-Type 0x12345", instr_u_type(0x12345), IMM_TYPE_U_CPP, 0x0000000012345000ULL}, // MSB is 0
        {"U-Type 0x0", instr_u_type(0x0), IMM_TYPE_U_CPP, 0x0},
        {"U-Type max (0xFFFFF)", instr_u_type(0xFFFFF), IMM_TYPE_U_CPP, 0xFFFFFFFFFFFFF000ULL},

        // J-Type
        {"J-Type positive offset +2046", instr_j_type(2046), IMM_TYPE_J_CPP, 2046}, // Max positive for 11 bit field for example (2^11-2)
                                                                                   // J-imm is 21 bits, so 2^20 max offset
        {"J-Type negative offset -2048", instr_j_type(-2048), IMM_TYPE_J_CPP, (uint64_t)-2048},
        {"J-Type max pos offset (2^19-2)", instr_j_type((1<<19)-2), IMM_TYPE_J_CPP, (1ULL<<19)-2},
        {"J-Type min neg offset (-2^19)", instr_j_type(-(1<<19)), IMM_TYPE_J_CPP, (uint64_t)(-(1LL<<19))},

        // ISHIFT-Type (RV64 shamt is 6 bits, instr[25:20])
        {"ISHIFT shamt=1", instr_ishift_type(1), IMM_TYPE_ISHIFT_CPP, 1},
        {"ISHIFT shamt=31", instr_ishift_type(31), IMM_TYPE_ISHIFT_CPP, 31},
        {"ISHIFT shamt=63", instr_ishift_type(63), IMM_TYPE_ISHIFT_CPP, 63},
        {"ISHIFT shamt=0", instr_ishift_type(0), IMM_TYPE_ISHIFT_CPP, 0},
        {"ISHIFT (SRAI fixed bits)", instr_ishift_type(5, 0b010000), IMM_TYPE_ISHIFT_CPP, 5}, // Check shamt extraction part

        // IMM_TYPE_NONE
        {"None Type", 0, IMM_TYPE_NONE_CPP, 0},
    };

    int passed_count = 0;
    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name << std::endl;
        std::cout << "  Instruction Bits: 0x" << std::hex << tc.instruction_bits
                  << ", Type: " << (int)tc.imm_type << std::dec << std::endl;

        top->i_instr = tc.instruction_bits;
        top->i_imm_type_sel = static_cast<uint8_t>(tc.imm_type); // Cast enum to uint8_t for Verilator port

        eval_immgen(top, tfp);
        sim_time_immgen++; // Increment time for VCD for each test case

        bool current_pass = true;
        if (top->o_imm_ext != tc.expected_imm_ext) {
            std::cout << "  FAIL: Immediate Mismatch." << std::endl;
            std::cout << "    Expected: 0x" << std::hex << tc.expected_imm_ext << std::dec << std::endl;
            std::cout << "    Got:      0x" << std::hex << top->o_imm_ext << std::dec << std::endl;
            current_pass = false;
        }

        if (current_pass) {
            std::cout << "  PASS" << std::endl;
            passed_count++;
        } else {
            std::cout << "  FAILED" << std::endl;
        }
    }

    std::cout << "\nImmediate Generator Testbench Finished. Passed " << passed_count << "/" << test_cases.size() << " tests." << std::endl;

    if (tfp) tfp->close();
    delete top;
    return (passed_count == test_cases.size()) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/execute_tb.sv ---
`include "common/defines.svh"
`include "common/alu_defines.svh"
`include "common/control_signals_defines.svh"

module execute_tb (
    input  logic clk, // Not strictly used by execute.sv's logic but good for TB
    input  logic rst_n, // Same as clk

    // Inputs to Execute Stage (simulating outputs of ID/EX register)
    input  logic       i_reg_write_e,
    input  logic [1:0] i_result_src_e,
    input  logic       i_mem_write_e,
    input  logic       i_jump_e,
    input  logic       i_branch_e,
    input  logic       i_alu_src_e, // Selects ALU Operand B
    input  logic [`ALU_CONTROL_WIDTH-1:0] i_alu_control_e,
    input  logic [2:0] i_funct3_e,          // Pipelined funct3
    input  alu_a_src_sel_e i_op_a_sel_e,    // Selects ALU Operand A's original source
    input  pc_target_src_sel_e i_pc_target_src_sel_e, // Selects PC Target calculation method

    input  logic [`DATA_WIDTH-1:0]  i_pc_e,
    input  logic [`DATA_WIDTH-1:0]  i_pc_plus_4_e,
    input  logic [`DATA_WIDTH-1:0]  i_rs1_data_e,   // Data from RF for Rs1 (before forwarding)
    input  logic [`DATA_WIDTH-1:0]  i_rs2_data_e,   // Data from RF for Rs2 (before forwarding)
    input  logic [`DATA_WIDTH-1:0]  i_imm_ext_e,
    input  logic [`REG_ADDR_WIDTH-1:0] i_rd_addr_e,

    // Forwarding inputs
    input  logic [`DATA_WIDTH-1:0]     i_forward_data_mem, // Data from MEM stage output for forwarding
    input  logic [`DATA_WIDTH-1:0]     i_forward_data_wb,  // Data from WB stage output for forwarding
    input  logic [1:0]                 i_forward_a_e,      // Control for OpA forwarding MUX
    input  logic [1:0]                 i_forward_b_e,      // Control for OpB forwarding MUX

    // Outputs from Execute stage (these would go to EX/MEM register)
    output logic       o_reg_write_m,
    output logic [1:0] o_result_src_m,
    output logic       o_mem_write_m,
    output logic [`DATA_WIDTH-1:0] o_alu_result_m,
    output logic [`DATA_WIDTH-1:0] o_rs2_data_m,    // Original rs2_data_e passed through (for SW)
    output logic [`REG_ADDR_WIDTH-1:0] o_rd_addr_m,
    output logic [`DATA_WIDTH-1:0] o_pc_plus_4_m,
    output logic [2:0] o_funct3_m,          // Pipelined funct3 passed through

    // Outputs from Execute stage that affect PC update
    output logic       o_pc_src_e,           // PCSrcE: 1 if branch/jump taken
    output logic [`DATA_WIDTH-1:0] o_pc_target_addr_e // PCTargetE: target address
);

    execute u_execute (
        // .clk            (clk), // Not used internally by current execute.sv
        // .rst_n          (rst_n), // Not used internally

        .reg_write_e_i  (i_reg_write_e),
        .result_src_e_i (i_result_src_e),
        .mem_write_e_i  (i_mem_write_e),
        .jump_e_i       (i_jump_e),
        .branch_e_i     (i_branch_e),
        .alu_src_e_i    (i_alu_src_e),
        .alu_control_e_i(i_alu_control_e),
        .funct3_e_i     (i_funct3_e),
        .op_a_sel_e_i   (i_op_a_sel_e),
        .pc_target_src_sel_e_i (i_pc_target_src_sel_e),
        .pc_e_i         (i_pc_e),
        .pc_plus_4_e_i  (i_pc_plus_4_e),
        .rs1_data_e_i   (i_rs1_data_e),
        .rs2_data_e_i   (i_rs2_data_e),
        .imm_ext_e_i    (i_imm_ext_e),
        .rd_addr_e_i    (i_rd_addr_e),

        .forward_data_mem_i (i_forward_data_mem),
        .forward_data_wb_i  (i_forward_data_wb),
        .forward_a_e_i  (i_forward_a_e),
        .forward_b_e_i  (i_forward_b_e),

        .reg_write_m_o  (o_reg_write_m),
        .result_src_m_o (o_result_src_m),
        .mem_write_m_o  (o_mem_write_m),
        .alu_result_m_o (o_alu_result_m),
        .rs2_data_m_o   (o_rs2_data_m),
        .rd_addr_m_o    (o_rd_addr_m),
        .pc_plus_4_m_o  (o_pc_plus_4_m),
        .funct3_m_o     (o_funct3_m),
        .pc_src_e_o     (o_pc_src_e),
        .pc_target_addr_e_o (o_pc_target_addr_e)
    );

endmodule


--- File: tests/unit/decode_tb.sv ---
// tests/unit/decode_tb.sv
`include "common/defines.svh"
`include "common/alu_defines.svh"          // For ALU_CONTROL_WIDTH
`include "common/control_signals_defines.svh" // For alu_a_src_sel_e, pc_target_src_sel_e

module decode_tb (
    input  logic clk,
    input  logic rst_n,

    // Inputs to control the test environment
    // To IF/ID register
    input  logic                       i_if_id_stall_d, // Stall for if_id register
    input  logic                       i_if_id_flush_d, // Flush for if_id register
    input  logic [`INSTR_WIDTH-1:0]    i_instr_f,       // Instruction from a virtual "fetch"
    input  logic [`DATA_WIDTH-1:0]     i_pc_f,          // PC from a virtual "fetch"
    input  logic [`DATA_WIDTH-1:0]     i_pc_plus_4_f,   // PC+4 from a virtual "fetch"

    // To Register File (for initialization during test, and Writeback simulation)
    input  logic                       i_wb_write_en,
    input  logic [`REG_ADDR_WIDTH-1:0] i_wb_rd_addr,
    input  logic [`DATA_WIDTH-1:0]     i_wb_rd_data,

    // Outputs from Decode stage (to observe)
    // Control Signals
    output logic       o_reg_write_d,
    output logic [1:0] o_result_src_d,
    output logic       o_mem_write_d,
    output logic       o_jump_d,
    output logic       o_branch_d,
    output logic       o_alu_src_d, // Selects ALU Operand B
    output logic [`ALU_CONTROL_WIDTH-1:0] o_alu_control_d,
    output logic [2:0] o_funct3_d,
    output alu_a_src_sel_e o_op_a_sel_d,
    output pc_target_src_sel_e o_pc_target_src_sel_d,

    // Data
    output logic [`DATA_WIDTH-1:0]  o_pc_d,
    output logic [`DATA_WIDTH-1:0]  o_pc_plus_4_d,
    output logic [`DATA_WIDTH-1:0]  o_rs1_data_d,
    output logic [`DATA_WIDTH-1:0]  o_rs2_data_d,
    output logic [`DATA_WIDTH-1:0]  o_imm_ext_d,

    // Register addresses
    output logic [`REG_ADDR_WIDTH-1:0] o_rs1_addr_d,
    output logic [`REG_ADDR_WIDTH-1:0] o_rs2_addr_d,
    output logic [`REG_ADDR_WIDTH-1:0] o_rd_addr_d,

    // Output from IF/ID for sanity check
    output logic [`INSTR_WIDTH-1:0]    o_instr_id,
    output logic [`DATA_WIDTH-1:0]     o_pc_id,
    output logic [`DATA_WIDTH-1:0]     o_pc_plus_4_id
);

    // Signals between IF/ID and Decode
    logic [`INSTR_WIDTH-1:0]    instr_id_val;
    logic [`DATA_WIDTH-1:0]     pc_id_val;
    logic [`DATA_WIDTH-1:0]     pc_plus_4_id_val;

    // IF/ID Register instance
    if_id_register u_if_id_reg (
        .clk            (clk),
        .rst_n          (rst_n),
        .stall_d        (i_if_id_stall_d),
        .flush_d        (i_if_id_flush_d),
        .instr_f_i      (i_instr_f),
        .pc_f_i         (i_pc_f),
        .pc_plus_4_f_i  (i_pc_plus_4_f),
        .instr_id_o     (instr_id_val),
        .pc_id_o        (pc_id_val),
        .pc_plus_4_id_o (pc_plus_4_id_val)
    );

    // Decode Stage instance
    decode u_decode (
        .clk                (clk),
        .rst_n              (rst_n),
        .instr_id_i         (instr_id_val),
        .pc_id_i            (pc_id_val),
        .pc_plus_4_id_i     (pc_plus_4_id_val),
        .rd_write_en_wb_i   (i_wb_write_en),
        .rd_addr_wb_i       (i_wb_rd_addr),
        .rd_data_wb_i       (i_wb_rd_data),

        .reg_write_d_o      (o_reg_write_d),
        .result_src_d_o     (o_result_src_d),
        .mem_write_d_o      (o_mem_write_d),
        .jump_d_o           (o_jump_d),
        .branch_d_o         (o_branch_d),
        .alu_src_d_o        (o_alu_src_d),
        .alu_control_d_o    (o_alu_control_d),
        .funct3_d_o         (o_funct3_d),
        .op_a_sel_d_o       (o_op_a_sel_d),
        .pc_target_src_sel_d_o (o_pc_target_src_sel_d),

        .pc_d_o             (o_pc_d),
        .pc_plus_4_d_o      (o_pc_plus_4_d),
        .rs1_data_d_o       (o_rs1_data_d),
        .rs2_data_d_o       (o_rs2_data_d),
        .imm_ext_d_o        (o_imm_ext_d),
        .rs1_addr_d_o       (o_rs1_addr_d),
        .rs2_addr_d_o       (o_rs2_addr_d),
        .rd_addr_d_o        (o_rd_addr_d)
    );

    // Assign IF/ID outputs for observation
    assign o_instr_id     = instr_id_val;
    assign o_pc_id        = pc_id_val;
    assign o_pc_plus_4_id = pc_plus_4_id_val;

endmodule


--- File: tests/unit/writeback_stage_tb.sv ---
`include "common/defines.svh"

module writeback_stage_tb (
    // Inputs to writeback_stage
    input  logic [1:0]                 i_result_src_wb,
    input  logic [`DATA_WIDTH-1:0]     i_read_data_wb,
    input  logic [`DATA_WIDTH-1:0]     i_alu_result_wb,
    input  logic [`DATA_WIDTH-1:0]     i_pc_plus_4_wb,

    // Output from writeback_stage
    output logic [`DATA_WIDTH-1:0]     o_result_w
);

    writeback_stage u_writeback_stage (
        .result_src_wb_i (i_result_src_wb),
        .read_data_wb_i  (i_read_data_wb),
        .alu_result_wb_i (i_alu_result_wb),
        .pc_plus_4_wb_i  (i_pc_plus_4_wb),
        .result_w_o      (o_result_w)
    );

endmodule


--- File: tests/unit/fetch_tb.cpp ---
#include "Vfetch_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>

// В defines.svh INSTR_WIDTH = 32, DATA_WIDTH = 64
const uint32_t NOP_INSTRUCTION = 0x00000013;

vluint64_t sim_time = 0;

void tick(Vfetch_tb* dut, VerilatedVcdC* tfp) {
    dut->clk = 0;
    dut->eval();
    if (tfp) tfp->dump(sim_time);
    sim_time++;

    dut->clk = 1;
    dut->eval();
    if (tfp) tfp->dump(sim_time);
    sim_time++;
}

void reset_dut(Vfetch_tb* dut, VerilatedVcdC* tfp) {
    dut->rst_n = 0;
    // Initialize inputs to known safe values during reset
    dut->i_stall_f = 0;
    dut->i_pc_src_e = 0;
    dut->i_pc_target_e = 0;
    dut->i_stall_d = 0;
    dut->i_flush_d = 0;
    for (int i = 0; i < 5; ++i) { // Hold reset for a few cycles
        tick(dut, tfp);
    }
    dut->rst_n = 1;
    tick(dut, tfp); // One tick out of reset
    std::cout << "DUT Reset" << std::endl;
}


int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vfetch_tb* top = new Vfetch_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_fetch.vcd");

    std::cout << "Starting Fetch Stage Testbench" << std::endl;

    reset_dut(top, tfp);

    // Test Case 1: Basic sequential fetch
    std::cout << "Test Case 1: Sequential Fetch" << std::endl;
    top->i_stall_f = 0;
    top->i_pc_src_e = 0;
    top->i_pc_target_e = 0; // Don't care
    top->i_stall_d = 0;
    top->i_flush_d = 0;

    // Cycle 1: PC=0, Fetch instr @0. IF/ID gets this after this cycle.
    tick(top, tfp);
    std::cout << "  PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected after reset and first tick: PC_F=0. IF/ID output still from reset state or previous garbage before first valid data.
    // After PC=0 is fetched, on the NEXT rising edge, IF/ID will latch PC=0 and Instr @0.

    // Cycle 2: PC=0 latched into IF/ID. Fetch stage moves to PC=4.
    tick(top, tfp);
    std::cout << "  PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=4. IF/ID PC=0, Instr = mem[0] (0x00100093)

    // Cycle 3: PC=4 latched into IF/ID. Fetch stage moves to PC=8.
    tick(top, tfp);
    std::cout << "  PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=8. IF/ID PC=4, Instr = mem[1] (0x00200113)


    // Test Case 2: Stall Fetch (StallF)
    std::cout << "\nTest Case 2: Stall Fetch (stall_f)" << std::endl;
    top->i_stall_f = 1; // Stall PC update
    top->i_stall_d = 0; // IF/ID register loads normally
    // PC_F was 8. It should remain 8. Instr_F will be from PC=8.
    // IF/ID will latch current Instr_F and PC_F+4.
    // Previous IF/ID instr was mem[1] (from PC=4).
    tick(top, tfp); // PC=8 (stalled), instr_f = mem[8/4=2]. IF/ID gets (instr @ PC=8, PC=8+4)
    std::cout << "  StallF=1. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=8. IF/ID PC=8, Instr = mem[2] (0x00308193)

    tick(top, tfp); // PC=8 (still stalled), instr_f = mem[8/4=2]. IF/ID re-latches same values.
    std::cout << "  StallF=1. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=8. IF/ID PC=8, Instr = mem[2]

    top->i_stall_f = 0; // Release stall_f


    // Test Case 3: Stall Decode (StallD)
    std::cout << "\nTest Case 3: Stall Decode (stall_d)" << std::endl;
    // PC_F was 8. Now stall_f=0, so PC will advance to 12. instr_f = mem[12/4=3].
    // IF/ID was (PC=8, instr=mem[2]). Now stall_d=1, so IF/ID holds its value.
    top->i_stall_d = 1;
    tick(top, tfp);
    std::cout << "  StallD=1. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=12 (0xC). IF/ID PC=8, Instr = mem[2] (holds previous)

    // PC_F advances to 16. instr_f = mem[16/4=4].
    // IF/ID still holds (PC=8, instr=mem[2]).
    tick(top, tfp);
    std::cout << "  StallD=1. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=16 (0x10). IF/ID PC=8, Instr = mem[2]

    top->i_stall_d = 0; // Release stall_d


    // Test Case 4: Flush Decode (FlushD)
    std::cout << "\nTest Case 4: Flush Decode (flush_d)" << std::endl;
    // PC_F was 16. Now stall_d=0, PC advances to 20. instr_f = mem[20/4=5].
    // IF/ID was (PC=8, instr=mem[2]). Now flush_d=1. IF/ID should be NOP.
    top->i_flush_d = 1;
    tick(top, tfp);
    std::cout << "  FlushD=1. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=20 (0x14). IF/ID PC=0, Instr = NOP (0x13)

    top->i_flush_d = 0; // Release flush_d
    tick(top, tfp); // PC_F advances to 24. IF/ID gets (instr @ PC=20, PC=20+4)
    std::cout << "  FlushD=0. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=24 (0x18). IF/ID PC=20, Instr = mem[5]

    // Test Case 5: Branch Taken (pc_src_e)
    std::cout << "\nTest Case 5: Branch Taken" << std::endl;
    top->i_pc_src_e = 1;
    top->i_pc_target_e = 0x100; // Jump to address 0x100
    // PC_F was 24. Next PC should be 0x100. instr_f will be mem[0x100/4].
    // IF/ID was (PC=20, instr=mem[5]). IF/ID gets (instr @ PC=0x100, PC=0x100+4)
    tick(top, tfp);
    std::cout << "  Branch. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=0x100. IF/ID PC=0x100, Instr = mem[0x100/4] (which is NOP by default init)

    top->i_pc_src_e = 0; // Next cycle, no branch
    tick(top, tfp); // PC_F advances to 0x104. IF/ID gets (instr @ PC=0x100, PC=0x100+4)
    std::cout << "  After Branch. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=0x104. IF/ID PC=0x100, Instr = mem[0x100/4]


    std::cout << "\nFetch Stage Testbench Finished." << std::endl;

    if (tfp) tfp->close();
    delete top;
    return 0;
}


--- File: tests/unit/instruction_memory_tb.sv ---
// tests/unit/instruction_memory_tb.sv

`include "common/defines.svh"

module instruction_memory_tb (
    // Testbench is combinational for instruction_memory inputs/outputs
    // clk/rst_n are not strictly needed by instruction_memory.sv itself for read path,
    // but Verilator testbenches often have them. We can omit for this simple module.

    input  logic [`DATA_WIDTH-1:0]     i_address,
    output logic [`INSTR_WIDTH-1:0]    o_instruction
);

    instruction_memory u_instr_mem (
        .address     (i_address),
        .instruction (o_instruction)
    );

endmodule


--- File: tests/unit/pipeline_tb.sv ---
// tests/unit/pipeline_tb.sv
`default_nettype none
`timescale 1ns/1ps

`include "common/pipeline_types.svh"

module pipeline_tb (
    input  logic clk,
    input  logic rst_n,

    // Debug outputs from pipeline
    output logic [`DATA_WIDTH-1:0]     debug_pc_f_o,
    output logic [`INSTR_WIDTH-1:0]    debug_instr_f_o,
    output logic                       debug_reg_write_wb_o,
    output logic [`REG_ADDR_WIDTH-1:0] debug_rd_addr_wb_o,
    output logic [`DATA_WIDTH-1:0]     debug_result_w_o,

    // If we want to observe pipeline register contents for detailed debugging:
    // These would need to be made outputs of the 'pipeline' module itself.
    // For now, we rely on the specific debug signals provided by 'pipeline.sv'.
    // output if_id_data_t    debug_if_id_data_q_o,
    // output id_ex_data_t    debug_id_ex_data_q_o,
    // output ex_mem_data_t   debug_ex_mem_data_q_o,
    // output mem_wb_data_t   debug_mem_wb_data_q_o

    // Output from RF for checking (requires DPI or making RF content visible)
    // For now, we check writeback via debug_reg_write_wb_o etc.
    output logic [`DATA_WIDTH-1:0]     debug_rf_x1, // Example: Value of register x1
    output logic [`DATA_WIDTH-1:0]     debug_rf_x2,
    output logic [`DATA_WIDTH-1:0]     debug_rf_x3,
    output logic [`DATA_WIDTH-1:0]     debug_rf_x4
);

    // Instantiate the pipeline
    // Parameters for memory init files can be passed here if 'pipeline' module is parameterized
    pipeline u_pipeline (
        .clk                  (clk),
        .rst_n                (rst_n),
        .debug_pc_f           (debug_pc_f_o),
        .debug_instr_f        (debug_instr_f_o),
        .debug_reg_write_wb   (debug_reg_write_wb_o),
        .debug_rd_addr_wb     (debug_rd_addr_wb_o),
        .debug_result_w       (debug_result_w_o)
        // .debug_if_id_q_o    (debug_if_id_data_q_o), // Example if pipeline exposes these
        // .debug_id_ex_q_o    (debug_id_ex_data_q_o),
        // .debug_ex_mem_q_o   (debug_ex_mem_data_q_o),
        // .debug_mem_wb_q_o   (debug_mem_wb_data_q_o)
    );

    // For observing register file content, we'd typically need DPI access
    // or to instantiate the register file separately here and mirror writes.
    // As a simplification for this basic test, we can add specific 'export'
    // signals directly from the register_file.sv if we modify it, or use Verilator's
    // ability to access internal signals via their hierarchical path in C++.
    //
    // Let's assume for now we use Verilator's public signal access from C++
    // or we add `export` to register file if needed.
    // For this Verilog TB, we are just providing ports for C++ to read.
    // The C++ side will use Verilator's features to peek into u_pipeline.u_decode.u_register_file.regs[x]

    // These are placeholders; actual values will be read by C++ from internal signals
    assign debug_rf_x1 = u_pipeline.u_decode.u_register_file.regs[1];
    assign debug_rf_x2 = u_pipeline.u_decode.u_register_file.regs[2];
    assign debug_rf_x3 = u_pipeline.u_decode.u_register_file.regs[3];
    assign debug_rf_x4 = u_pipeline.u_decode.u_register_file.regs[4];

endmodule


--- File: tests/unit/pipeline_control_tb.sv ---
`include "common/defines.svh"

module pipeline_control_tb (
    // Inputs to pipeline_control
    input  logic [`REG_ADDR_WIDTH-1:0] i_rs1_addr_d,
    input  logic [`REG_ADDR_WIDTH-1:0] i_rs2_addr_d,
    input  logic [`REG_ADDR_WIDTH-1:0] i_rd_addr_e,
    input  logic                       i_reg_write_e,
    input  logic [1:0]                 i_result_src_e,
    input  logic [`REG_ADDR_WIDTH-1:0] i_rd_addr_m,
    input  logic                       i_reg_write_m,
    input  logic [`REG_ADDR_WIDTH-1:0] i_rd_addr_w,
    input  logic                       i_reg_write_w,
    input  logic                       i_pc_src_e,

    // Outputs from pipeline_control
    output logic                       o_stall_f,
    output logic                       o_stall_d,
    output logic                       o_flush_d,
    output logic                       o_flush_e,
    output logic [1:0]                 o_forward_a_e,
    output logic [1:0]                 o_forward_b_e
);

    pipeline_control u_pipeline_control (
        .rs1_addr_d_i   (i_rs1_addr_d),
        .rs2_addr_d_i   (i_rs2_addr_d),
        .rd_addr_e_i    (i_rd_addr_e),
        .reg_write_e_i  (i_reg_write_e),
        .result_src_e_i (i_result_src_e),
        .rd_addr_m_i    (i_rd_addr_m),
        .reg_write_m_i  (i_reg_write_m),
        .rd_addr_w_i    (i_rd_addr_w),
        .reg_write_w_i  (i_reg_write_w),
        .pc_src_e_i     (i_pc_src_e),
        .stall_f_o      (o_stall_f),
        .stall_d_o      (o_stall_d),
        .flush_d_o      (o_flush_d),
        .flush_e_o      (o_flush_e),
        .forward_a_e_o  (o_forward_a_e),
        .forward_b_e_o  (o_forward_b_e)
    );

endmodule


--- File: tests/unit/alu.cpp ---
// tests/unit/alu.cpp
#include "Valu.h" // Verilator generated header for alu module
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cassert>
#include <cstdint>
#include <string>
#include <vector>
#include <bitset>

// ALU Control Opcodes (из alu_defines.svh)
const int ALU_CONTROL_WIDTH_CPP = 4;
const uint8_t ALU_OP_ADD_CPP  = 0b0000;
const uint8_t ALU_OP_SUB_CPP  = 0b0001;
const uint8_t ALU_OP_SLL_CPP  = 0b0010;
const uint8_t ALU_OP_SLT_CPP  = 0b0011;
const uint8_t ALU_OP_SLTU_CPP = 0b0100;
const uint8_t ALU_OP_XOR_CPP  = 0b0101;
const uint8_t ALU_OP_SRL_CPP  = 0b0110;
const uint8_t ALU_OP_SRA_CPP  = 0b0111;
const uint8_t ALU_OP_OR_CPP   = 0b1000;
const uint8_t ALU_OP_AND_CPP  = 0b1001;

vluint64_t sim_time = 0; // Глобальное время симуляции для VCD

double sc_time_stamp() {
    return sim_time;
}

// Измененная функция eval_alu: clk не нужен для комбинационного ALU
void eval_alu(Valu* alu_core, VerilatedVcdC* tfp) {
    alu_core->eval(); // Просто вызываем eval
    if (tfp) {
        tfp->dump(sim_time); // Дампим на текущее время симуляции
    }
}

struct AluTestCase {
    std::string name;
    uint64_t a, b;
    uint8_t alu_control_val;
    uint64_t expected_res;
    bool expected_zero;
};

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Valu* top = new Valu;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_alu.vcd");

    std::cout << "Starting Enhanced ALU Testbench (RV64)" << std::endl;

    AluTestCase tests[] = {
        // === ADD Tests ===
        {"ADD 5+10", 5, 10, ALU_OP_ADD_CPP, 15, false},
        {"ADD 0+0", 0, 0, ALU_OP_ADD_CPP, 0, true},
        {"ADD -1+1", 0xFFFFFFFFFFFFFFFFULL, 1, ALU_OP_ADD_CPP, 0, true},
        {"ADD MAX_UINT64+1", 0xFFFFFFFFFFFFFFFFULL, 1, ALU_OP_ADD_CPP, 0, true},
        {"ADD MAX_INT64+1", 0x7FFFFFFFFFFFFFFFULL, 1, ALU_OP_ADD_CPP, 0x8000000000000000ULL, false},
        {"ADD MIN_INT64-1", 0x8000000000000000ULL, 0xFFFFFFFFFFFFFFFFULL, ALU_OP_ADD_CPP, 0x7FFFFFFFFFFFFFFFULL, false},
        {"ADD large positives", 0x7000000000000000ULL, 0x0FFFFFFFFFFFFFFFULL, ALU_OP_ADD_CPP, 0x7FFFFFFFFFFFFFFFULL, false},

        // === SUB Tests ===
        {"SUB 10-5", 10, 5, ALU_OP_SUB_CPP, 5, false},
        {"SUB 5-10", 5, 10, ALU_OP_SUB_CPP, (uint64_t)-5, false},
        {"SUB 0-0", 0, 0, ALU_OP_SUB_CPP, 0, true},
        {"SUB 0-1", 0, 1, ALU_OP_SUB_CPP, (uint64_t)-1, false},
        {"SUB MIN_INT64-1", 0x8000000000000000ULL, 1, ALU_OP_SUB_CPP, 0x7FFFFFFFFFFFFFFFULL, false},
        {"SUB MAX_INT64 - MIN_INT64", 0x7FFFFFFFFFFFFFFFULL, 0x8000000000000000ULL, ALU_OP_SUB_CPP, 0xFFFFFFFFFFFFFFFFULL, false},

        // === SLL Tests ===
        {"SLL 1<<3", 0x1ULL, 3, ALU_OP_SLL_CPP, 0x8ULL, false},
        {"SLL 1<<0", 0x1ULL, 0, ALU_OP_SLL_CPP, 0x1ULL, false},
        {"SLL 1<<63", 0x1ULL, 63, ALU_OP_SLL_CPP, 0x8000000000000000ULL, false},
        {"SLL 1<<64 (shamt=0)", 0x1ULL, 64, ALU_OP_SLL_CPP, 0x1ULL, false}, // operand_b[5:0] -> shamt=0
        {"SLL 0xFF<<8", 0xFFULL, 8, ALU_OP_SLL_CPP, 0xFF00ULL, false},
        {"SLL anything by 0", 0xABCDEF1234567890ULL, 0, ALU_OP_SLL_CPP, 0xABCDEF1234567890ULL, false},

        // === SLT Tests ===
        {"SLT 5<10", 5, 10, ALU_OP_SLT_CPP, 1, false},
        {"SLT 10<5", 10, 5, ALU_OP_SLT_CPP, 0, true},
        {"SLT 5<5", 5, 5, ALU_OP_SLT_CPP, 0, true},
        {"SLT -5<2", (uint64_t)-5, 2, ALU_OP_SLT_CPP, 1, false},
        {"SLT 2<-5", 2, (uint64_t)-5, ALU_OP_SLT_CPP, 0, true},
        {"SLT -2<-5", (uint64_t)-2, (uint64_t)-5, ALU_OP_SLT_CPP, 0, true},
        {"SLT -5<-2", (uint64_t)-5, (uint64_t)-2, ALU_OP_SLT_CPP, 1, false},
        {"SLT MAX_INT64 vs MIN_INT64", 0x7FFFFFFFFFFFFFFFULL, 0x8000000000000000ULL, ALU_OP_SLT_CPP, 0, true},
        {"SLT MIN_INT64 vs MAX_INT64", 0x8000000000000000ULL, 0x7FFFFFFFFFFFFFFFULL, ALU_OP_SLT_CPP, 1, false},

        // === SLTU Tests ===
        {"SLTU 5<10", 5, 10, ALU_OP_SLTU_CPP, 1, false},
        {"SLTU 10<5", 10, 5, ALU_OP_SLTU_CPP, 0, true},
        {"SLTU 5<5", 5, 5, ALU_OP_SLTU_CPP, 0, true},
        {"SLTU (uint)-5 < 2", (uint64_t)-5, 2, ALU_OP_SLTU_CPP, 0, true}, 
        {"SLTU 2 < (uint)-5", 2, (uint64_t)-5, ALU_OP_SLTU_CPP, 1, false},
        {"SLTU MAX_UINT64 vs 0", 0xFFFFFFFFFFFFFFFFULL, 0, ALU_OP_SLTU_CPP, 0, true},
        {"SLTU 0 vs MAX_UINT64", 0, 0xFFFFFFFFFFFFFFFFULL, ALU_OP_SLTU_CPP, 1, false},

        // === XOR Tests ===
        {"XOR F0F0^0F0F", 0xF0F0F0F0F0F0F0F0ULL, 0x0F0F0F0F0F0F0F0FULL, ALU_OP_XOR_CPP, 0xFFFFFFFFFFFFFFFFULL, false},
        {"XOR A^A=0", 0x123456789ABCDEF0ULL, 0x123456789ABCDEF0ULL, ALU_OP_XOR_CPP, 0, true},
        {"XOR A^0=A", 0x123456789ABCDEF0ULL, 0, ALU_OP_XOR_CPP, 0x123456789ABCDEF0ULL, false},

        // === SRL Tests ===
        {"SRL 0x8000...>>1", 0x8000000000000000ULL, 1, ALU_OP_SRL_CPP, 0x4000000000000000ULL, false},
        {"SRL 0x0F...>>4", 0x0F00000000000000ULL, 4, ALU_OP_SRL_CPP, 0x00F0000000000000ULL, false},
        {"SRL val by 0", 0xABCDEF1234567890ULL, 0, ALU_OP_SRL_CPP, 0xABCDEF1234567890ULL, false},
        {"SRL val by 64 (shamt=0)", 0xABCDEF1234567890ULL, 64, ALU_OP_SRL_CPP, 0xABCDEF1234567890ULL, false},
        {"SRL val by 63", 0x8000000000000000ULL, 63, ALU_OP_SRL_CPP, 1, false},

        // === SRA Tests ===
        {"SRA 0x8000...>>1 (neg)", 0x8000000000000000ULL, 1, ALU_OP_SRA_CPP, 0xC000000000000000ULL, false},
        {"SRA 0x4000...>>1 (pos)", 0x4000000000000000ULL, 1, ALU_OP_SRA_CPP, 0x2000000000000000ULL, false},
        {"SRA -16>>4", 0xFFFFFFFFFFFFFFF0ULL, 4, ALU_OP_SRA_CPP, 0xFFFFFFFFFFFFFFFFULL, false}, 
        {"SRA val by 0", 0x8BCDEF1234567890ULL, 0, ALU_OP_SRA_CPP, 0x8BCDEF1234567890ULL, false},
        {"SRA val by 64 (shamt=0)", 0x8BCDEF1234567890ULL, 64, ALU_OP_SRA_CPP, 0x8BCDEF1234567890ULL, false},
        {"SRA -2 by 1", (uint64_t)-2, 1, ALU_OP_SRA_CPP, (uint64_t)-1, false}, 
        {"SRA MIN_INT64 by 63", 0x8000000000000000ULL, 63, ALU_OP_SRA_CPP, 0xFFFFFFFFFFFFFFFFULL, false},

        // === OR Tests ===
        {"OR F0F0|0F0F", 0xF0F0F0F0F0F0F0F0ULL, 0x0F0F0F0F0F0F0F0FULL, ALU_OP_OR_CPP, 0xFFFFFFFFFFFFFFFFULL, false},
        {"OR A|0=A", 0x123456789ABCDEF0ULL, 0, ALU_OP_OR_CPP, 0x123456789ABCDEF0ULL, false},
        {"OR A|A=A", 0x123456789ABCDEF0ULL, 0x123456789ABCDEF0ULL, ALU_OP_OR_CPP, 0x123456789ABCDEF0ULL, false},
        {"OR A|~A = FFs", 0x5555555555555555ULL, 0xAAAAAAAAAAAAAAAAULL, ALU_OP_OR_CPP, 0xFFFFFFFFFFFFFFFFULL, false},

        // === AND Tests ===
        {"AND F0F0&0F0F", 0xF0F0F0F0F0F0F0F0ULL, 0x0F0F0F0F0F0F0F0FULL, ALU_OP_AND_CPP, 0, true},
        {"AND A&0=0", 0x123456789ABCDEF0ULL, 0, ALU_OP_AND_CPP, 0, true},
        {"AND A&A=A", 0x123456789ABCDEF0ULL, 0x123456789ABCDEF0ULL, ALU_OP_AND_CPP, 0x123456789ABCDEF0ULL, false},
        {"AND A&~A = 0", 0x5555555555555555ULL, 0xAAAAAAAAAAAAAAAAULL, ALU_OP_AND_CPP, 0, true},
    };

    int num_tests = sizeof(tests) / sizeof(AluTestCase);
    int passed_tests = 0;

    for (int i = 0; i < num_tests; ++i) {
        AluTestCase& t = tests[i];

        top->operand_a = t.a;
        top->operand_b = t.b;
        top->alu_control = t.alu_control_val;

        eval_alu(top, tfp); // Вызываем eval один раз, т.к. модуль комбинационный
        // Для VCD инкрементируем время после каждого набора входов/выходов
        sim_time++;

        bool pass = (top->result == t.expected_res) &&
                    (top->zero_flag == t.expected_zero);

        if (pass) {
            passed_tests++;
        } else {
            std::cout << "FAIL Test: " << t.name << std::endl;
            std::cout << "  Input: A=0x" << std::hex << t.a << ", B=0x" << t.b
                      << ", ALUControl=0b" << std::bitset<ALU_CONTROL_WIDTH_CPP>(t.alu_control_val) << std::dec << std::endl;
            std::cout << "  Got  : Res=0x" << std::hex << top->result << ", Zero=" << (int)top->zero_flag << std::dec << std::endl;
            std::cout << "  Exp  : Res=0x" << std::hex << t.expected_res << ", Zero=" << (int)t.expected_zero << std::dec << std::endl;
        }
        assert(pass);
    }

    std::cout << "\nEnhanced ALU Testbench Finished. Passed " << passed_tests << "/" << num_tests << " tests." << std::endl;

    if (tfp) tfp->close();
    delete top;
    return (passed_tests == num_tests) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/data_memory_tb.cpp ---
// tests/unit/data_memory_tb.cpp
#include "Vdata_memory_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <bitset>
#include <cstdint>
#include <vector>
#include <string>

// Funct3 codes for LOAD/STORE (из common/riscv_opcodes.svh)
const uint8_t FUNCT3_LB_CPP  = 0b000;
const uint8_t FUNCT3_LH_CPP  = 0b001;
const uint8_t FUNCT3_LW_CPP  = 0b010;
const uint8_t FUNCT3_LD_CPP  = 0b011;
const uint8_t FUNCT3_LBU_CPP = 0b100;
const uint8_t FUNCT3_LHU_CPP = 0b101;
const uint8_t FUNCT3_LWU_CPP = 0b110;

const uint8_t FUNCT3_SB_CPP  = 0b000;
const uint8_t FUNCT3_SH_CPP  = 0b001;
const uint8_t FUNCT3_SW_CPP  = 0b010;
const uint8_t FUNCT3_SD_CPP  = 0b011;


vluint64_t sim_time_dmem = 0;

void tick_dmem(Vdata_memory_tb* dut, VerilatedVcdC* tfp) {
    // Память синхронная по записи, комбинационная по чтению (но зависит от clk для записи)
    // Поэтому тактируем
    dut->clk = 0;
    dut->eval();
    if (tfp) tfp->dump(sim_time_dmem);
    sim_time_dmem++;

    dut->clk = 1;
    dut->eval(); // Запись происходит на posedge clk
    if (tfp) tfp->dump(sim_time_dmem);
    sim_time_dmem++;
}


void reset_dmem(Vdata_memory_tb* dut, VerilatedVcdC* tfp) {
    dut->rst_n = 0;
    dut->i_addr = 0;
    dut->i_write_data = 0;
    dut->i_mem_write_en = 0;
    dut->i_funct3 = 0;
    // Держим ресет несколько тактов
    for(int i=0; i<5; ++i) {
        tick_dmem(dut, tfp);
    }
    dut->rst_n = 1;
    tick_dmem(dut, tfp); // Один такт после снятия ресета
    std::cout << "DUT Data Memory Reset" << std::endl;
}

struct DmemTestCase {
    std::string name;
    // Действия: "WRITE" или "READ"
    std::string action;
    uint64_t    address;
    uint8_t     funct3;
    uint64_t    write_data; // Используется для WRITE
    bool        mem_write_en;

    // Ожидания (только для READ)
    uint64_t    expected_read_data;
    bool        check_read_data; // true, если нужно проверять прочитанные данные
};


int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vdata_memory_tb* top = new Vdata_memory_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_data_memory.vcd");

    std::cout << "Starting Data Memory Testbench" << std::endl;

    reset_dmem(top, tfp);

    std::vector<DmemTestCase> test_cases = {
        // Test SB (Store Byte) then LB (Load Byte Signed)
        {"Write Byte 0xAA to 0x00", "WRITE", 0x00, FUNCT3_SB_CPP, 0xAA, true, 0, false},
        {"Read Byte from 0x00 (signed AA)", "READ", 0x00, FUNCT3_LB_CPP, 0, false, 0xFFFFFFFFFFFFFFAAULL, true},
        {"Write Byte 0x55 to 0x01", "WRITE", 0x01, FUNCT3_SB_CPP, 0x55, true, 0, false},
        {"Read Byte from 0x01 (signed 55)", "READ", 0x01, FUNCT3_LB_CPP, 0, false, 0x55, true},

        // Test SH (Store Half) then LH (Load Half Signed) / LHU (Load Half Unsigned)
        {"Write Half 0xCCBB to 0x04", "WRITE", 0x04, FUNCT3_SH_CPP, 0xCCBB, true, 0, false},
        {"Read Half from 0x04 (signed CCBB)", "READ", 0x04, FUNCT3_LH_CPP, 0, false, 0xFFFFFFFFFFFFCCBBULL, true},
        {"Read Half from 0x04 (unsigned CCBB)", "READ", 0x04, FUNCT3_LHU_CPP, 0, false, 0xCCBB, true},
        {"Write Half 0x3344 to 0x0A", "WRITE", 0x0A, FUNCT3_SH_CPP, 0x3344, true, 0, false},
        {"Read Half from 0x0A (signed 3344)", "READ", 0x0A, FUNCT3_LH_CPP, 0, false, 0x3344, true},

        // Test SW (Store Word) then LW (Load Word Signed) / LWU (Load Word Unsigned)
        {"Write Word 0x87654321 to 0x10", "WRITE", 0x10, FUNCT3_SW_CPP, 0x87654321, true, 0, false},
        {"Read Word from 0x10 (signed)", "READ", 0x10, FUNCT3_LW_CPP, 0, false, 0xFFFFFFFF87654321ULL, true},
        {"Read Word from 0x10 (unsigned)", "READ", 0x10, FUNCT3_LWU_CPP, 0, false, 0x87654321, true},

        // Test SD (Store Double) then LD (Load Double)
        {"Write Double 0x1122334455667788 to 0x20", "WRITE", 0x20, FUNCT3_SD_CPP, 0x1122334455667788ULL, true, 0, false},
        {"Read Double from 0x20", "READ", 0x20, FUNCT3_LD_CPP, 0, false, 0x1122334455667788ULL, true},

        // Test LBU (Load Byte Unsigned)
        {"Write Byte 0xDD to 0x02", "WRITE", 0x02, FUNCT3_SB_CPP, 0xDD, true, 0, false},
        {"Read Byte from 0x02 (unsigned DD)", "READ", 0x02, FUNCT3_LBU_CPP, 0, false, 0xDD, true},

        // Test read from unwritten location (should be 0 after reset)
        {"Read from unwritten (0x100)", "READ", 0x100, FUNCT3_LD_CPP, 0, false, 0x00, true},

        // Test write disabled
        {"Attempt Write Byte 0xFF to 0x30 (Write Disabled)", "WRITE", 0x30, FUNCT3_SB_CPP, 0xFF, false, 0, false}, // mem_write_en = false
        {"Read Byte from 0x30 (should be 0)", "READ", 0x30, FUNCT3_LB_CPP, 0, false, 0x00, true}, // Expect 0 (or prev value if not reset)

        // Testfunct3 mismatch on write (should still write based on size)
        // The funct3 is mainly for size on store, and size+sign on load.
        {"Write Byte 0xEE to 0x40 (funct3=SD, but SB behavior)", "WRITE", 0x40, FUNCT3_SD_CPP /* Mismatched funct3, but size is SB */, 0xEE, true, 0, false}, // This test is tricky. Store ops only use funct3 for size.
                                                                                                                                                   // Let's make a specific SD then read it as byte
        {"Write Double 0x12345678ABCDEF01 to 0x50", "WRITE", 0x50, FUNCT3_SD_CPP, 0x12345678ABCDEF01ULL, true, 0, false},
        {"Read Byte from 0x50 (LSB of double)", "READ", 0x50, FUNCT3_LB_CPP, 0, false, 0x01, true} // Assuming Little Endian for byte order
    };

    int passed_count = 0;
    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name << std::endl;
        std::cout << "  Action: " << tc.action
                  << ", Address: 0x" << std::hex << tc.address
                  << ", Funct3: 0b" << std::bitset<3>(tc.funct3) << std::dec;
        if (tc.action == "WRITE") {
            std::cout << ", WriteData: 0x" << std::hex << tc.write_data << std::dec;
        }
        std::cout << ", MemWriteEn: " << tc.mem_write_en << std::endl;

        top->i_addr = tc.address;
        top->i_funct3 = tc.funct3;
        top->i_mem_write_en = tc.mem_write_en;
        if (tc.action == "WRITE") {
            top->i_write_data = tc.write_data;
        } else {
            top->i_write_data = 0; // Don't care for read
        }

        // For WRITE, data is written on posedge. For READ, output is combinational.
        // We tick once to ensure any synchronous write happens.
        // Then, for READs, the output o_read_data should be valid after eval.
        if (tc.action == "WRITE") {
            tick_dmem(top, tfp); // This will apply write on posedge clk
        } else { // READ
            // For read, the output is combinational. One eval after setting address should be enough.
            // But to keep VCD clean and have a "moment" of read:
            top->clk = 0; top->eval(); if(tfp) tfp->dump(sim_time_dmem); // Set address
            sim_time_dmem++;
            top->clk = 1; top->eval(); if(tfp) tfp->dump(sim_time_dmem); // Read output is stable
            sim_time_dmem++;
        }


        bool current_pass = true;
        if (tc.action == "READ" && tc.check_read_data) {
            if (top->o_read_data != tc.expected_read_data) {
                std::cout << "  FAIL: Read Data Mismatch." << std::endl;
                std::cout << "    Expected: 0x" << std::hex << tc.expected_read_data << std::dec << std::endl;
                std::cout << "    Got:      0x" << std::hex << top->o_read_data << std::dec << std::endl;
                current_pass = false;
            }
        }

        if (current_pass) {
            std::cout << "  PASS" << std::endl;
            passed_count++;
        } else {
            std::cout << "  FAILED" << std::endl;
        }
    }

    std::cout << "\nData Memory Testbench Finished. Passed " << passed_count << "/" << test_cases.size() << " tests." << std::endl;

    if (tfp) tfp->close();
    delete top;
    return (passed_count == test_cases.size()) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/pipeline_control_tb.cpp ---
// tests/unit/pipeline_control_tb.cpp
#include "Vpipeline_control_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <string>
#include <bitset>

// Define ResultSrc values for clarity (matching control_unit logic)
const uint8_t RESULT_SRC_ALU_CPP    = 0b00;
const uint8_t RESULT_SRC_MEM_CPP    = 0b01; // Indicates a Load instruction for Load-Use Hazard
const uint8_t RESULT_SRC_PC_PLUS4_CPP = 0b10;

// Define Forwarding codes for clarity (matching pipeline_control hazard unit logic)
const uint8_t FORWARD_NONE_CPP   = 0b00;
const uint8_t FORWARD_MEM_WB_CPP = 0b01; // From MEM/WB (RdW) -> EX (was value for RdW)
const uint8_t FORWARD_EX_MEM_CPP = 0b10; // From EX/MEM (RdM) -> EX (was value for RdM)


vluint64_t sim_time_pc = 0; // Pipeline Control sim time

void eval_pc(Vpipeline_control_tb* dut, VerilatedVcdC* tfp) {
    dut->eval();
    if (tfp) {
        tfp->dump(sim_time_pc);
    }
    // sim_time_pc++; // For combinational, advance time per test case
}

struct PCTestCase {
    std::string name;
    // Inputs from Decode (IF/ID outputs)
    uint8_t rs1_addr_d;
    uint8_t rs2_addr_d;
    // Inputs from Execute (ID/EX outputs)
    uint8_t rd_addr_e;
    bool    reg_write_e;
    uint8_t result_src_e; // To detect Load for Load-Use
    // Inputs from Memory (EX/MEM outputs)
    uint8_t rd_addr_m;
    bool    reg_write_m;
    // Inputs from Writeback (MEM/WB outputs)
    uint8_t rd_addr_w;
    bool    reg_write_w;
    // Control input
    bool    pc_src_e; // Branch/Jump taken in EX

    // Expected Outputs
    bool    exp_stall_f;
    bool    exp_stall_d;
    bool    exp_flush_d;
    bool    exp_flush_e;
    uint8_t exp_forward_a_e; // 2 bits
    uint8_t exp_forward_b_e; // 2 bits
};

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vpipeline_control_tb* top = new Vpipeline_control_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_pipeline_control.vcd");

    std::cout << "Starting Pipeline Control (Hazard Unit) Testbench" << std::endl;

    std::vector<PCTestCase> test_cases = {
        // --- No Hazards ---
        {"No Hazard",
            1, 2, // rs1D, rs2D
            3, true, RESULT_SRC_ALU_CPP, // rdE, RegWE, ResultSrcE (ALU op)
            4, true,           // rdM, RegWriteM
            5, true,           // rdW, RegWriteW
            false,             // pc_src_e
            false, false, false, false, FORWARD_NONE_CPP, FORWARD_NONE_CPP // Expected outputs
        },

        // --- Load-Use Hazard ---
        {"Load-Use rs1D == RdE",
            3, 2, // rs1D=3, rs2D=2
            3, true, RESULT_SRC_MEM_CPP, // EX is LW x3, ...
            4, false,          // No conflict from MEM
            5, false,          // No conflict from WB
            false,             // No branch
            true, true, false, true, FORWARD_NONE_CPP, FORWARD_NONE_CPP // StallF, StallD, FlushE
        },
        {"Load-Use rs2D == RdE",
            1, 3, // rs1D=1, rs2D=3
            3, true, RESULT_SRC_MEM_CPP, // EX is LW x3, ...
            4, false, 5, false, false,
            true, true, false, true, FORWARD_NONE_CPP, FORWARD_NONE_CPP
        },
        {"Load-Use rs1D==RdE, rs2D==RdE",
            3, 3, 3, true, RESULT_SRC_MEM_CPP, 4, false, 5, false, false,
            true, true, false, true, FORWARD_NONE_CPP, FORWARD_NONE_CPP
        },
        {"Load-Use, but RdE = x0",
            1, 2, 0, true, RESULT_SRC_MEM_CPP, 4, false, 5, false, false, // RdE = 0
            false, false, false, false, FORWARD_NONE_CPP, FORWARD_NONE_CPP // No stall
        },
        {"Load-Use, but RegWriteE=false (not typical for Load)",
            3, 2, 3, false,RESULT_SRC_MEM_CPP, 4, false, 5, false, false, // RegWriteE = false
            false, false, false, false, FORWARD_NONE_CPP, FORWARD_NONE_CPP // No stall
        },
        // {"Not a Load in EX, rs1D == RdE (should forward, not stall)",
        //     3, 2, 3, true, RESULT_SRC_ALU_CPP, // EX is ALU op to x3
        //     4, false, 5, false, false,
        //     false, false, false, false, FORWARD_EX_MEM_CPP /*Incorrect expectation: this is for RdM*/, FORWARD_NONE_CPP
        //     // Corrected expectation: If RdE is from current EX, it's not ready for forwarding by this unit.
        //     // This unit forwards from MEM and WB. If RdE is a hazard, it means previous cycle (now in MEM).
        //     // So, for this case, we test forwarding from MEM stage.
        //     // The test "EX/MEM Fwd A (RdM==Rs1D)" covers this. This specific case is redundant or needs clarification.
        //     // For now, let's assume the test below handles this.
        // },

        // --- Data Forwarding from EX/MEM (RdM) ---
        {"EX/MEM Fwd A (RdM==Rs1D)",
            3, 2, // rs1D=3
            10, false, RESULT_SRC_ALU_CPP, // No conflict from EX stage itself
            3, true,           // Instr in MEM writes to x3
            5, false,          // No conflict from WB
            false,
            false, false, false, false, FORWARD_EX_MEM_CPP, FORWARD_NONE_CPP
        },
        {"EX/MEM Fwd B (RdM==Rs2D)",
            1, 3, 10, false, RESULT_SRC_ALU_CPP, 3, true, 5, false, false,
            false, false, false, false, FORWARD_NONE_CPP, FORWARD_EX_MEM_CPP
        },
        {"EX/MEM Fwd A & B (RdM==Rs1D, RdM==Rs2D)",
            3, 3, 10, false, RESULT_SRC_ALU_CPP, 3, true, 5, false, false,
            false, false, false, false, FORWARD_EX_MEM_CPP, FORWARD_EX_MEM_CPP
        },
        {"EX/MEM Fwd A, RdM=x0",
            0, 2, 10, false, RESULT_SRC_ALU_CPP, 0, true, 5, false, false,
            false, false, false, false, FORWARD_NONE_CPP, FORWARD_NONE_CPP // No fwd from x0
        },
        {"EX/MEM Fwd A, RegWriteM=false",
            3, 2, 10, false, RESULT_SRC_ALU_CPP, 3, false, 5, false, false,
            false, false, false, false, FORWARD_NONE_CPP, FORWARD_NONE_CPP // No fwd if no write
        },

        // --- Data Forwarding from MEM/WB (RdW) ---
        {"MEM/WB Fwd A (RdW==Rs1D)",
            3, 2, // rs1D=3
            10, false, RESULT_SRC_ALU_CPP, // No conflict from EX
            11, false,          // No conflict from MEM
            3, true,           // Instr in WB writes to x3
            false,
            false, false, false, false, FORWARD_MEM_WB_CPP, FORWARD_NONE_CPP
        },
        {"MEM/WB Fwd B (RdW==Rs2D)",
            1, 3, 10, false, RESULT_SRC_ALU_CPP, 11, false, 3, true, false,
            false, false, false, false, FORWARD_NONE_CPP, FORWARD_MEM_WB_CPP
        },

        // --- Forwarding Priority: EX/MEM over MEM/WB ---
        {"Fwd Priority: RdM=Rs1D, RdW=Rs1D (MEM takes precedence)",
            3, 2, // rs1D=3
            10, false, RESULT_SRC_ALU_CPP,
            3, true,           // RdM=3, RegWriteM=true
            3, true,           // RdW=3, RegWriteW=true
            false,
            false, false, false, false, FORWARD_EX_MEM_CPP, FORWARD_NONE_CPP // Expect fwd from MEM
        },

        // --- Control Hazards (Branch/Jump Taken) ---
        {"Branch Taken (pc_src_e=1)",
            1, 2, 3, false, RESULT_SRC_ALU_CPP, 4, false, 5, false,
            true,              // pc_src_e = true
            false, false, true, true, FORWARD_NONE_CPP, FORWARD_NONE_CPP // FlushD, FlushE
        },

        // --- Combined: Load-Use Stall AND Branch Taken ---
        // If branch is resolved in EX, and there's a load-use for an instruction *before* the branch
        // this scenario might be tricky. Typically, if branch taken, earlier instructions are flushed.
        // If lwStall and PCSrcE both active, FlushE should be true.
        {"Load-Use Stall AND Branch Taken",
            3, 2, 3, true, RESULT_SRC_MEM_CPP, // Load-use (rs1D=3, RdE=3)
            4, false, 5, false,
            true,              // pc_src_e = true (branch taken)
            true, true, true, true, FORWARD_NONE_CPP, FORWARD_NONE_CPP // StallF, StallD, FlushD, FlushE
        },
    };

    int passed_count = 0;
    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name << std::endl;

        top->i_rs1_addr_d = tc.rs1_addr_d;
        top->i_rs2_addr_d = tc.rs2_addr_d;
        top->i_rd_addr_e = tc.rd_addr_e;
        top->i_reg_write_e = tc.reg_write_e;
        top->i_result_src_e = tc.result_src_e;
        top->i_rd_addr_m = tc.rd_addr_m;
        top->i_reg_write_m = tc.reg_write_m;
        top->i_rd_addr_w = tc.rd_addr_w;
        top->i_reg_write_w = tc.reg_write_w;
        top->i_pc_src_e = tc.pc_src_e;

        eval_pc(top, tfp);
        sim_time_pc++;

        bool current_pass = true;
        if(top->o_stall_f != tc.exp_stall_f) {std::cout << "  FAIL: StallF. Exp=" << tc.exp_stall_f << " Got=" << (int)top->o_stall_f << std::endl; current_pass=false;}
        if(top->o_stall_d != tc.exp_stall_d) {std::cout << "  FAIL: StallD. Exp=" << tc.exp_stall_d << " Got=" << (int)top->o_stall_d << std::endl; current_pass=false;}
        if(top->o_flush_d != tc.exp_flush_d) {std::cout << "  FAIL: FlushD. Exp=" << tc.exp_flush_d << " Got=" << (int)top->o_flush_d << std::endl; current_pass=false;}
        if(top->o_flush_e != tc.exp_flush_e) {std::cout << "  FAIL: FlushE. Exp=" << tc.exp_flush_e << " Got=" << (int)top->o_flush_e << std::endl; current_pass=false;}
        if(top->o_forward_a_e != tc.exp_forward_a_e) {std::cout << "  FAIL: ForwardAE. Exp=0b" << std::bitset<2>(tc.exp_forward_a_e) << " Got=0b" << std::bitset<2>(top->o_forward_a_e) << std::endl; current_pass=false;}
        if(top->o_forward_b_e != tc.exp_forward_b_e) {std::cout << "  FAIL: ForwardBE. Exp=0b" << std::bitset<2>(tc.exp_forward_b_e) << " Got=0b" << std::bitset<2>(top->o_forward_b_e) << std::endl; current_pass=false;}

        if (current_pass) {
            std::cout << "  PASS" << std::endl;
            passed_count++;
        } else {
            std::cout << "  FAILED" << std::endl;
        }
    }

    std::cout << "\nPipeline Control Testbench Finished. Passed " << passed_count << "/" << test_cases.size() << " tests." << std::endl;

    if (tfp) tfp->close();
    delete top;
    return (passed_count == test_cases.size()) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/immediate_generator_tb.sv ---
`include "common/defines.svh"
`include "common/immediate_types.svh" // For immediate_type_e

module immediate_generator_tb (
    input  logic [`INSTR_WIDTH-1:0] i_instr,
    input  immediate_type_e         i_imm_type_sel,
    output logic [`DATA_WIDTH-1:0]  o_imm_ext
);

    immediate_generator u_immediate_generator (
        .instr_i        (i_instr),
        .imm_type_sel_i (i_imm_type_sel),
        .imm_ext_o      (o_imm_ext)
    );

endmodule


--- File: tests/unit/data_memory_tb.sv ---
`include "common/defines.svh"

module data_memory_tb (
    input  logic clk,
    input  logic rst_n,

    // Inputs to data_memory
    input  logic [`DATA_WIDTH-1:0]     i_addr,
    input  logic [`DATA_WIDTH-1:0]     i_write_data,
    input  logic                       i_mem_write_en,
    input  logic [2:0]                 i_funct3,

    // Output from data_memory
    output logic [`DATA_WIDTH-1:0]     o_read_data
);

    data_memory u_data_mem (
        .clk            (clk),
        .rst_n          (rst_n),
        .addr_i         (i_addr),
        .write_data_i   (i_write_data),
        .mem_write_en_i (i_mem_write_en),
        .funct3_i       (i_funct3),
        .read_data_o    (o_read_data)
    );

endmodule


--- File: tests/unit/memory_stage_tb.cpp ---
// tests/unit/memory_stage_tb.cpp
#include "Vmemory_stage_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <string>
#include <bitset> // For printing funct3

// Funct3 codes for LOAD/STORE (mirroring common/riscv_opcodes.svh)
const uint8_t FUNCT3_LB_MSTB  = 0b000;
const uint8_t FUNCT3_LH_MSTB  = 0b001;
const uint8_t FUNCT3_LW_MSTB  = 0b010;
const uint8_t FUNCT3_LD_MSTB  = 0b011;
const uint8_t FUNCT3_LBU_MSTB = 0b100;
const uint8_t FUNCT3_LHU_MSTB = 0b101;
const uint8_t FUNCT3_LWU_MSTB = 0b110;

const uint8_t FUNCT3_SB_MSTB  = 0b000;
const uint8_t FUNCT3_SH_MSTB  = 0b001;
const uint8_t FUNCT3_SW_MSTB  = 0b010;
const uint8_t FUNCT3_SD_MSTB  = 0b011;

// ResultSrc codes (mirroring control_unit logic)
const uint8_t RESULT_SRC_ALU_MSTB = 0b00;
const uint8_t RESULT_SRC_MEM_MSTB = 0b01;
const uint8_t RESULT_SRC_PC4_MSTB = 0b10;

vluint64_t sim_time_mem_stage = 0;

void tick_mem_stage(Vmemory_stage_tb* dut, VerilatedVcdC* tfp) {
    dut->clk = 0;
    dut->eval();
    if (tfp) tfp->dump(sim_time_mem_stage);
    sim_time_mem_stage++;

    dut->clk = 1;
    dut->eval(); // Write to data_memory happens on posedge
    if (tfp) tfp->dump(sim_time_mem_stage);
    sim_time_mem_stage++;
}

void reset_mem_stage(Vmemory_stage_tb* dut, VerilatedVcdC* tfp) {
    dut->rst_n = 0;
    dut->i_reg_write_m = 0;
    dut->i_result_src_m = 0;
    dut->i_mem_write_m = 0;
    dut->i_funct3_m = 0;
    dut->i_alu_result_m = 0;
    dut->i_rs2_data_m = 0;
    dut->i_rd_addr_m = 0;
    dut->i_pc_plus_4_m = 0;
    for (int i = 0; i < 3; ++i) { // Hold reset for a few cycles
        tick_mem_stage(dut, tfp);
    }
    dut->rst_n = 1;
    tick_mem_stage(dut, tfp); // One tick after reset
    std::cout << "DUT Memory Stage Reset" << std::endl;
}

struct MemStageTestCase {
    std::string name;
    // Inputs to memory_stage (from EX/MEM)
    bool     reg_write_m_i;
    uint8_t  result_src_m_i;
    bool     mem_write_m_i;
    uint8_t  funct3_m_i;
    uint64_t alu_result_m_i; // Address for mem or ALU result
    uint64_t rs2_data_m_i;   // Data to store
    uint8_t  rd_addr_m_i;
    uint64_t pc_plus_4_m_i;

    // Expected outputs from memory_stage (to MEM/WB)
    bool     exp_reg_write_w;
    uint8_t  exp_result_src_w;
    uint64_t exp_read_data_w;
    bool     check_read_data; // True if we expect a valid read_data_w
    uint64_t exp_alu_result_w;
    uint8_t  exp_rd_addr_w;
    uint64_t exp_pc_plus_4_w;
};

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vmemory_stage_tb* top = new Vmemory_stage_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_memory_stage.vcd");

    std::cout << "Starting Memory Stage Testbench" << std::endl;

    std::vector<MemStageTestCase> test_cases;

    // --- Test Sequence: Write then Read ---
    // 1. Store Byte 0xAA at address 0x10
    test_cases.push_back({ "Write SB 0xAA @0x10",
        false, RESULT_SRC_ALU_MSTB, true, FUNCT3_SB_MSTB, 0x10, 0xAA, 0, 0,
        false, RESULT_SRC_ALU_MSTB, 0, false, 0x10, 0, 0});
    // 2. Load Byte from 0x10 (expect 0xAA, sign-extended to 0xFF...FFAA)
    test_cases.push_back({ "Read LB from 0x10",
        true, RESULT_SRC_MEM_MSTB, false, FUNCT3_LB_MSTB, 0x10, 0, 1, 0x104,
        true, RESULT_SRC_MEM_MSTB, 0xFFFFFFFFFFFFFFAAULL, true, 0x10, 1, 0x104});
    // 3. Load Byte Unsigned from 0x10 (expect 0xAA)
    test_cases.push_back({ "Read LBU from 0x10",
        true, RESULT_SRC_MEM_MSTB, false, FUNCT3_LBU_MSTB, 0x10, 0, 2, 0x108,
        true, RESULT_SRC_MEM_MSTB, 0xAA, true, 0x10, 2, 0x108});

    // 4. Store Word 0x12345678 at address 0x20
    test_cases.push_back({ "Write SW 0x12345678 @0x20",
        false, RESULT_SRC_ALU_MSTB, true, FUNCT3_SW_MSTB, 0x20, 0x12345678, 0, 0,
        false, RESULT_SRC_ALU_MSTB, 0, false, 0x20, 0, 0});
    // 5. Load Word from 0x20 (expect 0x12345678, sign-extended)
    test_cases.push_back({ "Read LW from 0x20",
        true, RESULT_SRC_MEM_MSTB, false, FUNCT3_LW_MSTB, 0x20, 0, 3, 0,
        true, RESULT_SRC_MEM_MSTB, 0x12345678, true, 0x20, 3, 0}); // 0x12345678 is positive, so sign ext doesn't change value if top bits are 0

    // 6. Store Double 0xAABBCCDD11223344 at address 0x30
    test_cases.push_back({ "Write SD @0x30",
        false, RESULT_SRC_ALU_MSTB, true, FUNCT3_SD_MSTB, 0x30, 0xAABBCCDD11223344ULL, 0, 0,
        false, RESULT_SRC_ALU_MSTB, 0, false, 0x30, 0, 0});
    // 7. Load Double from 0x30
    test_cases.push_back({ "Read LD from 0x30",
        true, RESULT_SRC_MEM_MSTB, false, FUNCT3_LD_MSTB, 0x30, 0, 4, 0,
        true, RESULT_SRC_MEM_MSTB, 0xAABBCCDD11223344ULL, true, 0x30, 4, 0});


    // // --- Test Case: R-Type (ALU result pass-through) --- <--- CTE, need to fix
    // test_cases.push_back({ "R-Type (ALU pass)",
    //     true, RESULT_SRC_ALU_MSTB, false, FUNCT3_ADD_SUB_EX_TB, /*funct3 arbitrary non-mem*/
    //     0xABCDEF0123456789ULL /*ALU res*/, 0 /*rs2 data*/, 10 /*rd*/, 0x1008 /*pc+4*/,
    //     true, RESULT_SRC_ALU_MSTB, 0 /*read_data undefined*/, false, 0xABCDEF0123456789ULL, 10, 0x1008
    // });

    // --- Test Case: JAL/JALR (PC+4 pass-through as result) ---
    test_cases.push_back({ "JAL/JALR (PC+4 pass)",
        true, RESULT_SRC_PC4_MSTB, false, 0, /*funct3 arbitrary non-mem*/
        0xBADADD /*ALU res (target addr)*/, 0, 11 /*rd*/, 0x2010 /*pc+4*/,
        true, RESULT_SRC_PC4_MSTB, 0, false, 0xBADADD, 11, 0x2010
    });

    int passed_count = 0;
    // Reset memory once at the beginning for all test sequences
    reset_mem_stage(top, tfp);

    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name << std::endl;
        // Set inputs
        top->i_reg_write_m = tc.reg_write_m_i;
        top->i_result_src_m = tc.result_src_m_i;
        top->i_mem_write_m = tc.mem_write_m_i;
        top->i_funct3_m = tc.funct3_m_i;
        top->i_alu_result_m = tc.alu_result_m_i;
        top->i_rs2_data_m = tc.rs2_data_m_i;
        top->i_rd_addr_m = tc.rd_addr_m_i;
        top->i_pc_plus_4_m = tc.pc_plus_4_m_i;

        // Clock the DUT
        // For writes, the change happens on posedge.
        // For reads, data_memory is combinational, so output is available after eval.
        // memory_stage itself is combinational.
        // tick_mem_stage will handle one full clock cycle.
        tick_mem_stage(top, tfp);

        // Perform checks
        bool current_pass = true;
        if(top->o_reg_write_w != tc.exp_reg_write_w) {std::cout << "  FAIL: o_reg_write_w. Exp=" << tc.exp_reg_write_w << " Got=" << (int)top->o_reg_write_w << std::endl; current_pass=false;}
        if(top->o_result_src_w != tc.exp_result_src_w) {std::cout << "  FAIL: o_result_src_w. Exp=" << (int)tc.exp_result_src_w << " Got=" << (int)top->o_result_src_w << std::endl; current_pass=false;}
        if(tc.check_read_data && (top->o_read_data_w != tc.exp_read_data_w)) {
            std::cout << "  FAIL: o_read_data_w. Exp=0x" << std::hex << tc.exp_read_data_w << " Got=0x" << top->o_read_data_w << std::dec << std::endl; current_pass=false;
        }
        if(top->o_alu_result_w != tc.exp_alu_result_w) {std::cout << "  FAIL: o_alu_result_w. Exp=0x" << std::hex << tc.exp_alu_result_w << " Got=0x" << top->o_alu_result_w << std::dec << std::endl; current_pass=false;}
        if(top->o_rd_addr_w != tc.exp_rd_addr_w) {std::cout << "  FAIL: o_rd_addr_w. Exp=" << (int)tc.exp_rd_addr_w << " Got=" << (int)top->o_rd_addr_w << std::endl; current_pass=false;}
        if(top->o_pc_plus_4_w != tc.exp_pc_plus_4_w) {std::cout << "  FAIL: o_pc_plus_4_w. Exp=0x" << std::hex << tc.exp_pc_plus_4_w << " Got=0x" << top->o_pc_plus_4_w << std::dec << std::endl; current_pass=false;}

        if (current_pass) {
            std::cout << "  PASS" << std::endl;
            passed_count++;
        } else {
            std::cout << "  FAILED" << std::endl;
        }
    }

    std::cout << "\nMemory Stage Testbench Finished. Passed " << passed_count << "/" << test_cases.size() << " tests." << std::endl;

    if (tfp) tfp->close();
    delete top;
    return (passed_count == test_cases.size()) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/writeback_stage_tb.cpp ---
// tests/unit/writeback_stage_tb.cpp
#include "Vwriteback_stage_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <string>
#include <bitset> // Добавил для вывода result_src в бинарном виде

vluint64_t sim_time_wb = 0;

void eval_wb(Vwriteback_stage_tb* dut, VerilatedVcdC* tfp) {
    dut->eval();
    if (tfp) {
        tfp->dump(sim_time_wb);
    }
}

struct WbTestCase {
    std::string name;
    uint8_t     result_src; // 2 bits
    uint64_t    read_data_in;
    uint64_t    alu_result_in;
    uint64_t    pc_plus_4_in;
    uint64_t    expected_result_w;
    bool        expect_defined_output;
};

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vwriteback_stage_tb* top = new Vwriteback_stage_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_writeback_stage.vcd");

    std::cout << "Starting Writeback Stage Testbench (Corrected)" << std::endl;

    // Используем более различимые и валидные значения
    const uint64_t VAL_MEM  = 0xDDDDDDDDDDDDDDDDULL;
    const uint64_t VAL_ALU  = 0xAAAAAAAAAAAAAAAAULL;
    const uint64_t VAL_PC4  = 0x4444444444444444ULL;
    const uint64_t VAL_ZERO = 0x0000000000000000ULL;
    const uint64_t VAL_MAX  = 0xFFFFFFFFFFFFFFFFULL;


    std::vector<WbTestCase> test_cases = {
        {"Select ALU Result",           0b00, VAL_MEM, VAL_ALU, VAL_PC4, VAL_ALU, true},
        {"Select Memory Data",          0b01, VAL_MEM, VAL_ALU, VAL_PC4, VAL_MEM, true},
        {"Select PC+4",                 0b10, VAL_MEM, VAL_ALU, VAL_PC4, VAL_PC4, true},

        {"Select ALU (data is zero)",   0b00, VAL_MEM, VAL_ZERO, VAL_PC4, VAL_ZERO, true},
        {"Select Mem (data is zero)",   0b01, VAL_ZERO, VAL_ALU, VAL_PC4, VAL_ZERO, true},
        {"Select PC+4 (data is zero)",  0b10, VAL_MEM, VAL_ALU, VAL_ZERO, VAL_ZERO, true},

        {"Select ALU (data is max)",    0b00, VAL_MEM, VAL_MAX, VAL_PC4, VAL_MAX, true},
        {"Select Mem (data is max)",    0b01, VAL_MAX, VAL_ALU, VAL_PC4, VAL_MAX, true},
        {"Select PC+4 (data is max)",   0b10, VAL_MEM, VAL_ALU, VAL_MAX, VAL_MAX, true},

        // Test default case of result_src_wb_i (e.g., 2'b11)
        // Verilog `default: result_w_o = `DATA_WIDTH'('x);`
        // Verilator might represent 'x' as 0 if not forced otherwise by flags or specific handling.
        // We check that it's NOT one of the valid inputs if expect_defined_output is false.
        {"Invalid ResultSrc (11)",      0b11, VAL_MEM, VAL_ALU, VAL_PC4, VAL_ZERO /* Placeholder, actual 'x' behavior */, false}
    };

    int passed_count = 0;
    int total_defined_tests = 0;

    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name << std::endl;
        std::cout << "  Inputs: result_src=0b" << std::bitset<2>(tc.result_src)
                  << ", read_data=0x" << std::hex << tc.read_data_in
                  << ", alu_result=0x" << tc.alu_result_in
                  << ", pc_plus_4=0x" << tc.pc_plus_4_in << std::dec << std::endl;

        top->i_result_src_wb = tc.result_src;
        top->i_read_data_wb = tc.read_data_in;
        top->i_alu_result_wb = tc.alu_result_in;
        top->i_pc_plus_4_wb = tc.pc_plus_4_in;

        eval_wb(top, tfp);
        sim_time_wb++;

        bool current_pass = true;
        if (tc.expect_defined_output) {
            total_defined_tests++;
            if (top->o_result_w != tc.expected_result_w) {
                std::cout << "  FAIL: Result_W Mismatch." << std::endl;
                std::cout << "    Expected: 0x" << std::hex << tc.expected_result_w << std::dec << std::endl;
                std::cout << "    Got:      0x" << std::hex << top->o_result_w << std::dec << std::endl;
                current_pass = false;
            }
        } else { // Check for 'x' behavior (not matching any defined input path for this test case)
            if (top->o_result_w == tc.read_data_in && tc.result_src != 0b01) { // Check if it accidentally matched read_data
                std::cout << "  FAIL: Undefined ResultSrc case (0b11) unexpectedly matched ReadData input." << std::endl;
                std::cout << "    Got: 0x" << std::hex << top->o_result_w << std::dec << std::endl;
                current_pass = false;
            } else if (top->o_result_w == tc.alu_result_in && tc.result_src != 0b00) { // Check if it accidentally matched alu_result
                std::cout << "  FAIL: Undefined ResultSrc case (0b11) unexpectedly matched AluResult input." << std::endl;
                std::cout << "    Got: 0x" << std::hex << top->o_result_w << std::dec << std::endl;
                current_pass = false;
            } else if (top->o_result_w == tc.pc_plus_4_in && tc.result_src != 0b10) { // Check if it accidentally matched pc_plus_4
                std::cout << "  FAIL: Undefined ResultSrc case (0b11) unexpectedly matched PC+4 input." << std::endl;
                std::cout << "    Got: 0x" << std::hex << top->o_result_w << std::dec << std::endl;
                current_pass = false;
            } else {
                 std::cout << "  INFO: Undefined ResultSrc (0b11). Got: 0x" << std::hex << top->o_result_w << std::dec
                           << " (Expected 'x'-driven behavior, not matching valid inputs)." << std::endl;
                 // If Verilator consistently drives 'x' to 0, this might pass if inputs are non-zero.
                 // If Verilator drives 'x' to a random-like value, this check is more robust.
                 // A more definitive check for 'x' would require Verilator-specific features or DPI.
            }
        }

        if (tc.expect_defined_output) { // Only count defined behavior tests towards pass/fail strict count
            if (current_pass) {
                std::cout << "  PASS" << std::endl;
                passed_count++;
            } else {
                std::cout << "  FAILED" << std::endl;
            }
        } else if (current_pass) { // For !expect_defined_output, current_pass means it didn't match known inputs
            std::cout << "  PASS (undefined case handled as expected)" << std::endl;
            // Do not increment passed_count here for the main defined test counter
        } else { // !expect_defined_output && !current_pass
            std::cout << "  FAILED (undefined case unexpectedly matched an input)" << std::endl;
        }
    }

    std::cout << "\nWriteback Stage Testbench Finished." << std::endl;
    if (total_defined_tests > 0) {
        std::cout << "Passed " << passed_count << "/" << total_defined_tests << " defined behavior tests." << std::endl;
    } else {
        std::cout << "No defined behavior tests were executed." << std::endl;
    }


    if (tfp) tfp->close();
    delete top;
    // Exit status based on defined behavior tests only
    return (total_defined_tests == 0 || passed_count == total_defined_tests) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/execute_tb.cpp ---
// tests/unit/execute_tb.cpp
#include "Vexecute_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <string>
#include <map>
#include <bitset>

// C++ Constants (mirroring .svh files for testbench use)

// From common/alu_defines.svh
const int ALU_CONTROL_WIDTH_EX_TB = 4; // Suffix to avoid clash if alu.cpp linked
const uint8_t ALU_OP_ADD_EX_TB  = 0b0000;
const uint8_t ALU_OP_SUB_EX_TB  = 0b0001;
const uint8_t ALU_OP_SLL_EX_TB  = 0b0010;
const uint8_t ALU_OP_SLT_EX_TB  = 0b0011;
const uint8_t ALU_OP_SLTU_EX_TB = 0b0100;
const uint8_t ALU_OP_XOR_EX_TB  = 0b0101;
const uint8_t ALU_OP_SRL_EX_TB  = 0b0110;
const uint8_t ALU_OP_SRA_EX_TB  = 0b0111;
const uint8_t ALU_OP_OR_EX_TB   = 0b1000;
const uint8_t ALU_OP_AND_EX_TB  = 0b1001;

// From common/control_signals_defines.svh
enum AluASrcSelCppExTb {
    ALU_A_SRC_RS1_EX_TB,
    ALU_A_SRC_PC_EX_TB,
    ALU_A_SRC_ZERO_EX_TB
};

enum PcTargetSrcSelCppExTb {
    PC_TARGET_SRC_PC_PLUS_IMM_EX_TB,
    PC_TARGET_SRC_ALU_JALR_EX_TB
};

// From common/riscv_opcodes.svh (funct3 codes)
// For R-Type (funct3 can vary, but for ADD/SUB it's 000)
const uint8_t FUNCT3_ADD_SUB_EX_TB = 0b000;
// For I-Type
const uint8_t FUNCT3_ADDI_EX_TB    = 0b000;
// For U-Type (LUI/AUIPC - funct3 not critical for EX logic itself, but passed)
const uint8_t FUNCT3_LUI_AUIPC_EX_TB = 0b000; // Example, often not specifically checked in EX
// For Branches
const uint8_t FUNCT3_BEQ_EX_TB  = 0b000;
const uint8_t FUNCT3_BNE_EX_TB  = 0b001;
const uint8_t FUNCT3_BLT_EX_TB  = 0b100;
const uint8_t FUNCT3_BGE_EX_TB  = 0b101;
const uint8_t FUNCT3_BLTU_EX_TB = 0b110;
const uint8_t FUNCT3_BGEU_EX_TB = 0b111;
// For JALR
const uint8_t FUNCT3_JALR_EX_TB    = 0b000;
// For Store (e.g. SW)
const uint8_t FUNCT3_SW_EX_TB      = 0b010;
// Add other specific funct3 codes if needed for detailed tests


// Forwarding MUX select codes
const uint8_t FWD_NONE_EX_TB   = 0b00;
const uint8_t FWD_MEM_WB_EX_TB = 0b01; // From MEM/WB (RdW) -> EX
const uint8_t FWD_EX_MEM_EX_TB = 0b10; // From EX/MEM (RdM) -> EX

vluint64_t sim_time_execute_tb = 0;

void eval_execute(Vexecute_tb* dut, VerilatedVcdC* tfp) {
    dut->eval();
    if (tfp) tfp->dump(sim_time_execute_tb);
}

// Test case structure
struct ExecuteTestCase {
    std::string name;
    // --- Inputs to Execute Stage (simulating outputs of ID/EX register) ---
    bool     reg_write_e_i;
    uint8_t  result_src_e_i; // 00:ALU, 01:Mem, 10:PC+4
    bool     mem_write_e_i;
    bool     jump_e_i;
    bool     branch_e_i;
    bool     alu_src_e_i;     // For ALU OpB: 0=Reg_Rs2, 1=Imm
    uint8_t  alu_control_e_i; // 4-bit ALU operation
    uint8_t  funct3_e_i;      // 3-bit funct3 (from instruction, used for branches, memory ops)
    AluASrcSelCppExTb op_a_sel_e_i;    // Selects original source for ALU OpA
    PcTargetSrcSelCppExTb pc_target_src_sel_e_i; // Selects how PC_Target is calculated

    uint64_t pc_e_i;
    uint64_t pc_plus_4_e_i;
    uint64_t rs1_data_e_i;    // Data from RF/forwarding for Rs1
    uint64_t rs2_data_e_i;    // Data from RF/forwarding for Rs2
    uint64_t imm_ext_e_i;     // Sign-extended immediate
    uint8_t  rd_addr_e_i;     // Destination register address

    // Forwarding inputs
    uint64_t forward_data_mem_i; // Data from MEM stage (EX/MEM reg output) for forwarding
    uint64_t forward_data_wb_i;  // Data from WB stage (MEM/WB reg output) for forwarding
    uint8_t  forward_a_e_i;      // Control for OpA forwarding MUX
    uint8_t  forward_b_e_i;      // Control for OpB forwarding MUX

    // --- Expected Outputs from Execute Stage ---
    // To EX/MEM Register
    bool     exp_reg_write_m;
    uint8_t  exp_result_src_m;
    bool     exp_mem_write_m;
    uint64_t exp_alu_result_m;
    uint64_t exp_rs2_data_m;   // Original rs2_data_e_i value passed through
    uint8_t  exp_rd_addr_m;
    uint64_t exp_pc_plus_4_m;
    uint8_t  exp_funct3_m;     // Pipelined funct3

    // To PC Update Logic
    bool     exp_pc_src_e;       // PCSrcE: 1 if branch/jump taken
    uint64_t exp_pc_target_addr_e; // PCTargetE: target address
};


int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vexecute_tb* top = new Vexecute_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_execute.vcd");

    std::cout << "Starting Execute Stage Testbench (Corrected)" << std::endl;
    top->rst_n = 1; // For combinational DUT, rst_n is not strictly for logic, but good for sim init
    top->clk = 0;   // Provide a clock for VCD tracing, though execute stage is combinational

    std::vector<ExecuteTestCase> test_cases = {
        // --- Test Case 1: R-Type ADD (no forwarding) ---
        {   "R-Type ADD, no fwd",
            true, 0b00, false, false, false, false, ALU_OP_ADD_EX_TB, FUNCT3_ADD_SUB_EX_TB, ALU_A_SRC_RS1_EX_TB, PC_TARGET_SRC_PC_PLUS_IMM_EX_TB,
            0x100, 0x104, 10, 20, 0xBADBEEF, 3,
            0, 0, FWD_NONE_EX_TB, FWD_NONE_EX_TB,
            true, 0b00, false, 30, 20, 3, 0x104, FUNCT3_ADD_SUB_EX_TB,
            false, 0x100 + 0xBADBEEF // pc_target_addr is pc_e_i + imm_ext_e_i by default for non-JALR target_sel
        },
        // --- Test Case 2: I-Type ADDI (no forwarding) ---
        {   "I-Type ADDI, no fwd",
            true, 0b00, false, false, false, true, ALU_OP_ADD_EX_TB, FUNCT3_ADDI_EX_TB, ALU_A_SRC_RS1_EX_TB, PC_TARGET_SRC_PC_PLUS_IMM_EX_TB,
            0x200, 0x204, 50, 0xCCC, 15, 6,
            0, 0, FWD_NONE_EX_TB, FWD_NONE_EX_TB,
            true, 0b00, false, 65, 0xCCC, 6, 0x204, FUNCT3_ADDI_EX_TB,
            false, 0x200 + 15
        },
        // --- Test Case 3: LUI (OpA=Zero, OpB=Imm) ---
        {   "LUI U-Type",
            true, 0b00, false, false, false, true, ALU_OP_ADD_EX_TB, FUNCT3_LUI_AUIPC_EX_TB, ALU_A_SRC_ZERO_EX_TB, PC_TARGET_SRC_PC_PLUS_IMM_EX_TB,
            0x300, 0x304, 0xAAA, 0xBBB, 0xFFFFFFFFABCD0000ULL, 5,
            0,0,FWD_NONE_EX_TB,FWD_NONE_EX_TB,
            true,0b00,false,0xFFFFFFFFABCD0000ULL,0xBBB,5,0x304,FUNCT3_LUI_AUIPC_EX_TB,
            false, 0x300 + 0xFFFFFFFFABCD0000ULL
        },
        // --- Test Case 4: AUIPC (OpA=PC, OpB=Imm) ---
        {   "AUIPC U-Type",
            true, 0b00, false, false, false, true, ALU_OP_ADD_EX_TB, FUNCT3_LUI_AUIPC_EX_TB, ALU_A_SRC_PC_EX_TB, PC_TARGET_SRC_PC_PLUS_IMM_EX_TB,
            0x400, 0x404, 0xAAA, 0xBBB, 0x12300000ULL, 1,
            0,0,FWD_NONE_EX_TB,FWD_NONE_EX_TB,
            true,0b00,false, 0x400 + 0x12300000ULL,0xBBB,1,0x404,FUNCT3_LUI_AUIPC_EX_TB,
            false, 0x400 + 0x12300000ULL
        },
        // --- Test Case 5: Forwarding EX/MEM -> OpA for ADD ---
        {   "R-Type ADD, FwdA from EX/MEM",
            true, 0b00, false, false, false, false, ALU_OP_ADD_EX_TB, FUNCT3_ADD_SUB_EX_TB, ALU_A_SRC_RS1_EX_TB, PC_TARGET_SRC_PC_PLUS_IMM_EX_TB,
            0x100, 0x104, 10/*old rs1_data_e_i, will be overridden by fwd*/, 20, 0, 5,
            0x55/*fwd_mem_data*/, 0x66/*fwd_wb_data, not used*/, FWD_EX_MEM_EX_TB, FWD_NONE_EX_TB,
            true, 0b00, false, 0x55 + 20, 20, 5, 0x104, FUNCT3_ADD_SUB_EX_TB,
            false, 0x100 + 0
        },
        // --- Test Case 6: Forwarding MEM/WB -> OpB for ADD (OpB is reg, not imm) ---
        {   "R-Type ADD, FwdB from MEM/WB",
            true, 0b00, false, false, false, false, ALU_OP_ADD_EX_TB, FUNCT3_ADD_SUB_EX_TB, ALU_A_SRC_RS1_EX_TB, PC_TARGET_SRC_PC_PLUS_IMM_EX_TB,
            0x100, 0x104, 10, 20/*old rs2_data_e_i, will be overridden*/, 0, 5,
            0x88/*fwd_mem_data, not used*/, 0x77/*fwd_wb_data*/, FWD_NONE_EX_TB, FWD_MEM_WB_EX_TB,
            true, 0b00, false, 10 + 0x77, 20, 5, 0x104, FUNCT3_ADD_SUB_EX_TB,
            false, 0x100 + 0
        },
        // --- Test Case 7: BEQ Taken (ALU SUB, Zero=1) ---
        {   "BEQ Branch Taken",
            false,0b00,false,false,true,false,ALU_OP_SUB_EX_TB,FUNCT3_BEQ_EX_TB,ALU_A_SRC_RS1_EX_TB,PC_TARGET_SRC_PC_PLUS_IMM_EX_TB,
            0x800,0x804,100,100,0x40/*offset*/,0,
            0,0,FWD_NONE_EX_TB,FWD_NONE_EX_TB,
            false,0b00,false,0/*ALU result 100-100=0*/,100,0,0x804,FUNCT3_BEQ_EX_TB,
            true, 0x800 + 0x40
        },
        // --- Test Case 8: BLT Not Taken (ALU SLT, Res=0) ---
        {   "BLT Not Taken",
            false,0b00,false,false,true,false,ALU_OP_SLT_EX_TB,FUNCT3_BLT_EX_TB,ALU_A_SRC_RS1_EX_TB,PC_TARGET_SRC_PC_PLUS_IMM_EX_TB,
            0x800,0x804,200,100,0x40,0, // rs1(200) not < rs2(100), so SLT res=0
            0,0,FWD_NONE_EX_TB,FWD_NONE_EX_TB,
            false,0b00,false,0/*ALU result*/,100,0,0x804,FUNCT3_BLT_EX_TB,
            false, 0x800 + 0x40
        },
        // --- Test Case 9: JALR ---
        {   "JALR Jump",
            true,0b10/*ResultSrc=PC+4*/,false,true,false,true,ALU_OP_ADD_EX_TB,FUNCT3_JALR_EX_TB,ALU_A_SRC_RS1_EX_TB,PC_TARGET_SRC_ALU_JALR_EX_TB,
            0x500,0x504,0x1000/*rs1_data*/,0xCCC/*rs2_data not used*/,0x80/*imm*/,1,
            0,0,FWD_NONE_EX_TB,FWD_NONE_EX_TB,
            true,0b10,false,0x1000+0x80,0xCCC,1,0x504,FUNCT3_JALR_EX_TB,
            true, (0x1000+0x80) & ~1ULL
        },
        // --- Test Case 10: Store instruction (SW) ---
        {   "SW (Store Word)",
            false, 0b00, true, false, false, true, ALU_OP_ADD_EX_TB, FUNCT3_SW_EX_TB, ALU_A_SRC_RS1_EX_TB, PC_TARGET_SRC_PC_PLUS_IMM_EX_TB,
            0xA00, 0xA04, 0x100/*base_addr_rs1*/, 0xDEADBEEF/*data_to_store_rs2*/, 0x8/*offset_imm*/, 0/*rd not written for SW*/,
            0, 0, FWD_NONE_EX_TB, FWD_NONE_EX_TB,
            false, 0b00, true, 0x100 + 0x8/*eff_addr*/, 0xDEADBEEF/*data_to_store*/, 0, 0xA04, FUNCT3_SW_EX_TB,
            false, 0xA00 + 0x8
        },
    };

    int passed_count = 0;
    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name << std::endl;

        // Apply inputs from test case
        top->i_reg_write_e = tc.reg_write_e_i;
        top->i_result_src_e = tc.result_src_e_i;
        top->i_mem_write_e = tc.mem_write_e_i;
        top->i_jump_e = tc.jump_e_i;
        top->i_branch_e = tc.branch_e_i;
        top->i_alu_src_e = tc.alu_src_e_i;
        top->i_alu_control_e = tc.alu_control_e_i;
        top->i_funct3_e = tc.funct3_e_i;
        top->i_op_a_sel_e = static_cast<uint8_t>(tc.op_a_sel_e_i);
        top->i_pc_target_src_sel_e = static_cast<uint8_t>(tc.pc_target_src_sel_e_i);
        top->i_pc_e = tc.pc_e_i;
        top->i_pc_plus_4_e = tc.pc_plus_4_e_i;
        top->i_rs1_data_e = tc.rs1_data_e_i;
        top->i_rs2_data_e = tc.rs2_data_e_i;
        top->i_imm_ext_e = tc.imm_ext_e_i;
        top->i_rd_addr_e = tc.rd_addr_e_i;
        top->i_forward_data_mem = tc.forward_data_mem_i;
        top->i_forward_data_wb = tc.forward_data_wb_i;
        top->i_forward_a_e = tc.forward_a_e_i;
        top->i_forward_b_e = tc.forward_b_e_i;

        eval_execute(top, tfp); // Evaluate combinational logic
        sim_time_execute_tb++;    // Increment VCD time for each test case

        bool current_pass = true;
        // Check all outputs
        if(top->o_reg_write_m != tc.exp_reg_write_m) { std::cout << "  FAIL o_reg_write_m Exp=" << tc.exp_reg_write_m << " Got=" << (int)top->o_reg_write_m << std::endl; current_pass = false; }
        if(top->o_result_src_m != tc.exp_result_src_m) { std::cout << "  FAIL o_result_src_m Exp=" << (int)tc.exp_result_src_m << " Got=" << (int)top->o_result_src_m << std::endl; current_pass = false; }
        if(top->o_mem_write_m != tc.exp_mem_write_m) { std::cout << "  FAIL o_mem_write_m Exp=" << tc.exp_mem_write_m << " Got=" << (int)top->o_mem_write_m << std::endl; current_pass = false; }
        if(top->o_alu_result_m != tc.exp_alu_result_m) { std::cout << "  FAIL o_alu_result_m Exp=0x" << std::hex << tc.exp_alu_result_m << " Got=0x" << top->o_alu_result_m << std::dec << std::endl; current_pass = false; }
        if(top->o_rs2_data_m != tc.exp_rs2_data_m) { std::cout << "  FAIL o_rs2_data_m Exp=0x" << std::hex << tc.exp_rs2_data_m << " Got=0x" << top->o_rs2_data_m << std::dec << std::endl; current_pass = false; }
        if(top->o_rd_addr_m != tc.exp_rd_addr_m) { std::cout << "  FAIL o_rd_addr_m Exp=" << (int)tc.exp_rd_addr_m << " Got=" << (int)top->o_rd_addr_m << std::endl; current_pass = false; }
        if(top->o_pc_plus_4_m != tc.exp_pc_plus_4_m) { std::cout << "  FAIL o_pc_plus_4_m Exp=0x" << std::hex << tc.exp_pc_plus_4_m << " Got=0x" << top->o_pc_plus_4_m << std::dec << std::endl; current_pass = false; }
        if(top->o_funct3_m != tc.exp_funct3_m) { std::cout << "  FAIL o_funct3_m Exp=" << (int)tc.exp_funct3_m << " Got=" << (int)top->o_funct3_m << std::endl; current_pass = false; }
        if(top->o_pc_src_e != tc.exp_pc_src_e) { std::cout << "  FAIL o_pc_src_e Exp=" << tc.exp_pc_src_e << " Got=" << (int)top->o_pc_src_e << std::endl; current_pass = false; }
        if(top->o_pc_target_addr_e != tc.exp_pc_target_addr_e) { std::cout << "  FAIL o_pc_target_addr_e Exp=0x" << std::hex << tc.exp_pc_target_addr_e << " Got=0x" << top->o_pc_target_addr_e << std::dec << std::endl; current_pass = false; }

        if (current_pass) {
            std::cout << "  PASS" << std::endl;
            passed_count++;
        } else {
            std::cout << "  FAILED" << std::endl;
        }
    }

    std::cout << "\nExecute Stage Testbench Finished. Passed " << passed_count << "/" << test_cases.size() << " tests." << std::endl;

    if (tfp) tfp->close();
    delete top;
    return (passed_count == test_cases.size()) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/CMakeLists.txt ---

#----------------------------------------------------------------------------------------------------------------------
# Base components
#----------------------------------------------------------------------------------------------------------------------

add_verilator_test(
    alu
    ${CMAKE_SOURCE_DIR}/rtl/core/alu.sv
)

add_verilator_test(
    instruction_memory_tb
    ${CMAKE_SOURCE_DIR}/rtl/core/instruction_memory.sv
    ${CMAKE_SOURCE_DIR}/tests/unit/instruction_memory_tb.sv
)

add_verilator_test(
    data_memory_tb
    ${CMAKE_SOURCE_DIR}/rtl/core/data_memory.sv
    ${CMAKE_SOURCE_DIR}/tests/unit/data_memory_tb.sv
)

add_verilator_test(
    register_file_tb
    ${CMAKE_SOURCE_DIR}/rtl/core/register_file.sv
    ${CMAKE_SOURCE_DIR}/tests/unit/register_file_tb.sv
)

add_verilator_test(
    immediate_generator_tb
    ${CMAKE_SOURCE_DIR}/rtl/core/immediate_generator.sv
    ${CMAKE_SOURCE_DIR}/tests/unit/immediate_generator_tb.sv
)


#----------------------------------------------------------------------------------------------------------------------
# Pipeline stages
#----------------------------------------------------------------------------------------------------------------------

add_verilator_test(
    control_unit_tb
    ${CMAKE_SOURCE_DIR}/rtl/core/control_unit.sv
    ${CMAKE_SOURCE_DIR}/tests/unit/control_unit_tb.sv
)

add_verilator_test(
    fetch_tb
    ${CMAKE_SOURCE_DIR}/rtl/core/fetch.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/instruction_memory.sv
    ${CMAKE_SOURCE_DIR}/tests/unit/fetch_tb.sv
)

# add_verilator_test(
#     decode_tb
#     ${CMAKE_SOURCE_DIR}/rtl/core/decode.sv
#     ${CMAKE_SOURCE_DIR}/rtl/core/control_unit.sv
#     ${CMAKE_SOURCE_DIR}/rtl/core/register_file.sv
#     ${CMAKE_SOURCE_DIR}/rtl/core/immediate_generator.sv
#     ${CMAKE_SOURCE_DIR}/tests/unit/decode_tb.sv
# )

# add_verilator_test(
#     execute_tb # Top Verilog testbench module and .cpp file name
#     # Source files needed
#     ${CMAKE_SOURCE_DIR}/rtl/core/execute.sv
#     ${CMAKE_SOURCE_DIR}/rtl/core/alu.sv         # execute instantiates alu
#     # common defines are included via -I${RTL_INCLUDE_PATH}
#     ${CMAKE_SOURCE_DIR}/tests/unit/execute_tb.sv # The Verilog testbench wrapper
# )

# add_verilator_test(
#     writeback_stage_tb
#     ${CMAKE_SOURCE_DIR}/rtl/core/writeback_stage.sv
#     ${CMAKE_SOURCE_DIR}/tests/unit/writeback_stage_tb.sv
# )

# add_verilator_test(
#     memory_stage_tb
#     ${CMAKE_SOURCE_DIR}/rtl/core/memory_stage.sv
#     ${CMAKE_SOURCE_DIR}/rtl/core/data_memory.sv
#     ${CMAKE_SOURCE_DIR}/tests/unit/memory_stage_tb.sv
# )

#----------------------------------------------------------------------------------------------------------------------
# Pipeline control
#----------------------------------------------------------------------------------------------------------------------

# add_verilator_test(
#     pipeline_control_tb
#     ${CMAKE_SOURCE_DIR}/rtl/core/pipeline_control.sv
#     ${CMAKE_SOURCE_DIR}/tests/unit/pipeline_control_tb.sv
# )

#----------------------------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------------------------

add_verilator_test(
    pipeline_tb
    # RTL files for the entire pipeline
    ${CMAKE_SOURCE_DIR}/rtl/pipeline.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/fetch.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/decode.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/execute.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/memory_stage.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/writeback_stage.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/pipeline_control.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/alu.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/control_unit.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/data_memory.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/immediate_generator.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/instruction_memory.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/register_file.sv
    # The Verilog testbench wrapper
    ${CMAKE_SOURCE_DIR}/tests/unit/pipeline_tb.sv
)


--- File: tests/unit/decode_tb.cpp ---
// tests/unit/decode_tb.cpp
#include "Vdecode_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <string>
#include <map>
#include <bitset>
#include <optional>

// MANUALLY DEFINED C++ CONSTANTS (mirroring .svh files)

// From common/alu_defines.svh
const int ALU_CONTROL_WIDTH_CPP = 4;
const uint8_t ALU_OP_ADD_CPP  = 0b0000;
const uint8_t ALU_OP_SUB_CPP  = 0b0001;
const uint8_t ALU_OP_SLL_CPP  = 0b0010;
const uint8_t ALU_OP_SLT_CPP  = 0b0011;
const uint8_t ALU_OP_SLTU_CPP = 0b0100;
const uint8_t ALU_OP_XOR_CPP  = 0b0101;
const uint8_t ALU_OP_SRL_CPP  = 0b0110;
const uint8_t ALU_OP_SRA_CPP  = 0b0111;
const uint8_t ALU_OP_OR_CPP   = 0b1000;
const uint8_t ALU_OP_AND_CPP  = 0b1001;

// From common/control_signals_defines.svh
enum AluASrcSelCppTb { // Renamed to avoid potential conflicts if enums are also in Verilator headers
    ALU_A_SRC_RS1_TB,
    ALU_A_SRC_PC_TB,
    ALU_A_SRC_ZERO_TB
};

enum PcTargetSrcSelCppTb {
    PC_TARGET_SRC_PC_PLUS_IMM_TB,
    PC_TARGET_SRC_ALU_JALR_TB
};

// From common/riscv_opcodes.svh
// Opcodes
const uint8_t OPCODE_LUI_CPP        = 0b0110111;
const uint8_t OPCODE_AUIPC_CPP      = 0b0010111;
const uint8_t OPCODE_JAL_CPP        = 0b1101111;
const uint8_t OPCODE_JALR_CPP       = 0b1100111;
const uint8_t OPCODE_BRANCH_CPP     = 0b1100011;
const uint8_t OPCODE_LOAD_CPP       = 0b0000011;
const uint8_t OPCODE_STORE_CPP      = 0b0100011;
const uint8_t OPCODE_OP_IMM_CPP   = 0b0010011;
const uint8_t OPCODE_OP_CPP         = 0b0110011;

// Funct3 for OP_IMM & OP (examples)
const uint8_t FUNCT3_ADDI_CPP       = 0b000;
const uint8_t FUNCT3_SLLI_CPP       = 0b001;
const uint8_t FUNCT3_SLTI_CPP       = 0b010;
const uint8_t FUNCT3_SLTIU_CPP      = 0b011;
const uint8_t FUNCT3_XORI_CPP       = 0b100;
const uint8_t FUNCT3_SRLI_SRAI_CPP  = 0b101;
const uint8_t FUNCT3_ORI_CPP        = 0b110;
const uint8_t FUNCT3_ANDI_CPP       = 0b111;
// Funct3 for BRANCH (examples)
const uint8_t FUNCT3_BEQ_CPP        = 0b000;


const uint32_t NOP_INSTRUCTION = 0x00000013; // addi x0, x0, 0

vluint64_t sim_time = 0; // Changed from sim_time_decode to avoid conflicts if other TBs use sim_time

void tick(Vdecode_tb* dut, VerilatedVcdC* tfp) {
    dut->clk = 0;
    dut->eval();
    if (tfp) tfp->dump(sim_time);
    sim_time++;
    dut->clk = 1;
    dut->eval();
    if (tfp) tfp->dump(sim_time);
    sim_time++;
}

void reset_dut(Vdecode_tb* dut, VerilatedVcdC* tfp) {
    dut->rst_n = 0;
    dut->i_if_id_stall_d = 0;
    dut->i_if_id_flush_d = 0;
    dut->i_instr_f = NOP_INSTRUCTION;
    dut->i_pc_f = 0;
    dut->i_pc_plus_4_f = 4;
    dut->i_wb_write_en = 0;
    dut->i_wb_rd_addr = 0;
    dut->i_wb_rd_data = 0;
    for (int i = 0; i < 5; ++i) tick(dut, tfp); // Hold reset for a few cycles
    dut->rst_n = 1;
    tick(dut, tfp); // One tick out of reset
}

void set_reg(Vdecode_tb* dut, VerilatedVcdC* tfp, uint8_t reg_addr, uint64_t data) {
    if (reg_addr == 0) return; // Cannot write to x0
    dut->i_wb_write_en = 1;
    dut->i_wb_rd_addr = reg_addr;
    dut->i_wb_rd_data = data;
    // Write occurs on posedge clk within this tick
    tick(dut, tfp);
    dut->i_wb_write_en = 0;
    // It's good practice to let signals propagate after write_en goes low,
    // though for this specific RF design, the next tick in the main loop will handle negedge read.
}

uint8_t get_opcode_cpp(uint32_t instr) { return instr & 0x7F; }
uint8_t get_rd_cpp(uint32_t instr) { return (instr >> 7) & 0x1F; }
uint8_t get_funct3_cpp(uint32_t instr) { return (instr >> 12) & 0x07; }
uint8_t get_rs1_cpp(uint32_t instr) { return (instr >> 15) & 0x1F; }
uint8_t get_rs2_cpp(uint32_t instr) { return (instr >> 20) & 0x1F; }

struct ExpectedControls {
    bool        reg_write;
    uint8_t     result_src;
    bool        mem_write;
    bool        jump;
    bool        branch;
    bool        alu_src_b; // For Operand B
    uint8_t     alu_control;
    AluASrcSelCppTb op_a_sel;
    PcTargetSrcSelCppTb pc_target_sel;
};

struct DecodeTestCase {
    std::string name;
    uint32_t    instruction;
    uint64_t    pc_val;
    std::map<uint8_t, uint64_t> initial_regs;
    ExpectedControls controls;
    std::optional<uint64_t> expected_rs1_data;
    std::optional<uint64_t> expected_rs2_data;
    std::optional<uint64_t> expected_imm_ext;
};


int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vdecode_tb* top = new Vdecode_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99); // Trace 99 levels of hierarchy
    tfp->open("tb_decode.vcd");

    std::cout << "Starting Decode Stage Testbench (Comprehensive)" << std::endl;

    std::vector<DecodeTestCase> test_cases = {
        // NOP
        {
            "NOP (addi x0,x0,0)", NOP_INSTRUCTION, 0x0, {},
            {true, 0b00, false, false, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            0, std::nullopt, 0 // rs1 is x0, so data is 0. rs2 not used by ADDI. imm is 0.
        },
        // R-Type
        {
            "ADD x3,x1,x2", 0x002081B3, 0x100, {{1,10},{2,20}}, // x1=10, x2=20 => x3=30
            {true, 0b00, false, false, false, false, ALU_OP_ADD_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            10, 20, std::nullopt // rs1=10, rs2=20. No imm.
        },
        {
            "SUB x4,x1,x0", 0x40008233, 0x104, {{1,50}},      // x1=50, x0=0 => x4=50
            {true, 0b00, false, false, false, false, ALU_OP_SUB_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            50, 0, std::nullopt // rs1=50, rs2 (x0) = 0. No imm.
        },
         {
            "SLL x5,x1,x2 (shamt=5)", 0x002092B3, 0x108, {{1,0x1},{2,0x5}},
            {true, 0b00, false, false, false, false, ALU_OP_SLL_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            0x1, 0x5, std::nullopt // rs1=1, rs2=5 (shamt). No imm.
        },
        // I-Type Arithmetic
        {
            "ADDI x1,x2,-10", 0xFF610093, 0x200, {{2,100}},   // x2=100, imm=-10 => x1=90
            {true, 0b00, false, false, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            100, std::nullopt, 0xFFFFFFFFFFFFFFF6ULL // rs1=100. rs2 not used. imm = -10.
        },
        {
            "SLLI x8,x1,5", 0x00509413, 0x220, {{1,0x2}},    // x1=2, shamt=5 => x8=64 (0x40)
            {true, 0b00, false, false, false, true, ALU_OP_SLL_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            0x2, std::nullopt, 0x5 // rs1=2. rs2 not used for SLLI. imm_ext is shamt=5.
        },
        {
            "SRAI x10,x1,2", 0x4020D513, 0x228, {{1,0xFFFFFFFFFFFFFFFCULL}}, // x1=-4, shamt=2 => x10=-1
            {true, 0b00, false, false, false, true, ALU_OP_SRA_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            0xFFFFFFFFFFFFFFFCULL, std::nullopt, 0x2 // rs1=-4. rs2 not used for SRAI. imm_ext is shamt=2.
        },
        // U-Type
        {
            "LUI x5,0xABCD0", 0xABCD02B7, 0x300, {}, // imm=0xABCD0 => x5=0xABCD0000 (sign ext if MSB of imm is 1)
            {true, 0b00, false, false, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_ZERO_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            std::nullopt, std::nullopt, 0xFFFFFFFFABCD0000ULL // rs1 not used (OpA is ZERO). rs2 not used. imm is U-type.
        },
        {
            "AUIPC x6,0x1", 0x00001317, 0x304, {},   // pc=0x304, imm=0x1 => x6=0x304 + 0x1000 = 0x1304
            {true, 0b00, false, false, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_PC_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            std::nullopt, std::nullopt, 0x1000ULL // rs1 not used (OpA is PC). rs2 not used. imm is U-type.
        },
        // Load
        {
            "LW x7,12(x1)", 0x00C0A383, 0x400, {{1,0x1000}}, // x1=0x1000, offset=12. rd=x7
            {true, 0b01, false, false, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            0x1000, std::nullopt, 0xC // rs1=0x1000 (base addr). rs2 not used. imm=offset.
        },
        // // Store - Corrected test case as per previous discussion <--- fails, need to fix
        // {
        //     "SW x7,16(x5)", 0x0110A823, 0x404, {{5,0x2000},{7,0xDEADBEEF}}, // rs1=x5 (base), rs2=x7 (data)
        //     {false,0b00, true, false, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
        //     0x2000, 0xDEADBEEF, 0x10 // rs1_data_d is from x5 (base), rs2_data_d is from x7 (data to store). imm=offset.
        // },
        // Branch
        {
            "BEQ x1,x0,+8 (taken)", 0x00008463, 0x500, {{1,0}}, // x1=0, x0=0. offset=8. Target=0x508
            {false,0b00, false, false, true, false, ALU_OP_SUB_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            0, 0, 0x8 // rs1 (x1)=0, rs2 (x0)=0. imm=offset.
        },
        // Jumps
        {
            "JAL x1,+16", 0x010000EF, 0x600, {}, // rd=x1 (PC+4). Target=PC+16=0x610
            {true, 0b10, false, true, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_PC_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            std::nullopt, std::nullopt, 0x10 // rs1 not used (OpA is PC). rs2 not used. imm=J-offset.
        },
        {
            "JALR x1,x2,32", 0x020100E7, 0x604, {{2,0x1000}}, // rd=x1 (PC+4). Target=(x2+32)&~1 = (0x1000+0x20)&~1 = 0x1020
            {true, 0b10, false, true, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_ALU_JALR_TB},
            0x1000, std::nullopt, 0x20 // rs1 (x2)=0x1000. rs2 not used. imm=I-offset.
        }
    };

    int passed_count = 0;
    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name << std::endl;
        std::cout << "  Instruction: 0x" << std::hex << tc.instruction << ", PC: 0x" << tc.pc_val << std::dec << std::endl;

        reset_dut(top, tfp);

        // Initialize registers based on the test case
        for(const auto& reg_pair : tc.initial_regs) {
            set_reg(top, tfp, reg_pair.first, reg_pair.second);
        }

        // Set up inputs for the IF/ID register
        top->i_instr_f = tc.instruction;
        top->i_pc_f = tc.pc_val;
        top->i_pc_plus_4_f = tc.pc_val + 4;
        top->i_if_id_stall_d = 0;
        top->i_if_id_flush_d = 0;
        top->eval();

        // --- Clock Cycle 1 ---
        // Posedge: IF/ID register latches i_instr_f, i_pc_f, i_pc_plus_4_f.
        //          Outputs of IF/ID (instr_id_val, pc_id_val, pc_plus_4_id_val) update.
        //          These values propagate to the Decode stage.
        //          In decode.sv, rs1_addr_instr and rs2_addr_instr update based on new instr_id_val.
        // Negedge (conceptually at the end of clk=0 period of this tick):
        //          Register file rs1_data_o/rs2_data_o are NOT yet updated with data for *this* instruction,
        //          as their read addresses (rs1_addr_i, rs2_addr_i) only just got updated.
        //          They would reflect data for addresses present *before* this instruction was latched.
        tick(top, tfp);
        // For debugging:
        // std::cout << "  After Tick 1 (IF/ID latch): " << std::endl;
        // std::cout << "    o_instr_id: 0x" << std::hex << top->o_instr_id << std::dec << std::endl;
        // std::cout << "    o_rs1_addr_d: " << (int)top->o_rs1_addr_d << ", o_rs2_addr_d: " << (int)top->o_rs2_addr_d << std::endl;

        // --- Clock Cycle 2 ---
        // Negedge (at the start of clk=0 period of this tick):
        //          Register file now performs read using rs1_addr_i and rs2_addr_i that were set
        //          by the current instruction (latched in IF/ID in the previous cycle).
        //          rs1_data_o and rs2_data_o outputs of register_file update with correct data.
        // Posedge: Decode stage's combinational logic (control_unit, immediate_generator)
        //          processes the now-stable rs1_data_o, rs2_data_o, and other inputs.
        //          All outputs of the Decode stage (o_rs1_data_d, o_control_signals, etc.) become stable.
        tick(top, tfp);
        // For debugging:
        // std::cout << "  After Tick 2 (Decode process): " << std::endl;
        // std::cout << "    o_rs1_data_d: 0x" << std::hex << top->o_rs1_data_d << std::dec << std::endl;
        // std::cout << "    o_rs2_data_d: 0x" << std::hex << top->o_rs2_data_d << std::dec << std::endl;


        // Now perform checks on the stable outputs of the Decode stage
        bool current_pass = true;
        uint8_t instr_opcode = get_opcode_cpp(tc.instruction);
        uint8_t instr_rd  = get_rd_cpp(tc.instruction);
        uint8_t instr_rs1 = get_rs1_cpp(tc.instruction);
        uint8_t instr_rs2 = get_rs2_cpp(tc.instruction);
        uint8_t instr_funct3 = get_funct3_cpp(tc.instruction);

        // Check Control Signals
        if(top->o_reg_write_d != tc.controls.reg_write) {std::cout << "  FAIL: RegWrite_D. Exp=" << tc.controls.reg_write << " Got=" << (int)top->o_reg_write_d << std::endl; current_pass=false;}
        if(top->o_result_src_d != tc.controls.result_src) {std::cout << "  FAIL: ResultSrc_D. Exp=" << (int)tc.controls.result_src << " Got=" << (int)top->o_result_src_d << std::endl; current_pass=false;}
        if(top->o_mem_write_d != tc.controls.mem_write) {std::cout << "  FAIL: MemWrite_D. Exp=" << tc.controls.mem_write << " Got=" << (int)top->o_mem_write_d << std::endl; current_pass=false;}
        if(top->o_jump_d != tc.controls.jump) {std::cout << "  FAIL: Jump_D. Exp=" << tc.controls.jump << " Got=" << (int)top->o_jump_d << std::endl; current_pass=false;}
        if(top->o_branch_d != tc.controls.branch) {std::cout << "  FAIL: Branch_D. Exp=" << tc.controls.branch << " Got=" << (int)top->o_branch_d << std::endl; current_pass=false;}
        if(top->o_alu_src_d != tc.controls.alu_src_b) {std::cout << "  FAIL: AluSrc_B_D (alu_src_d). Exp=" << tc.controls.alu_src_b << " Got=" << (int)top->o_alu_src_d << std::endl; current_pass=false;}
        if(top->o_alu_control_d != tc.controls.alu_control) {std::cout << "  FAIL: AluControl_D. Exp=0b" << std::bitset<ALU_CONTROL_WIDTH_CPP>(tc.controls.alu_control) << " Got=0b" << std::bitset<ALU_CONTROL_WIDTH_CPP>(top->o_alu_control_d) << std::endl; current_pass=false;}
        if(top->o_op_a_sel_d != static_cast<uint8_t>(tc.controls.op_a_sel)) {std::cout << "  FAIL: OpASel_D. Exp=" << (int)tc.controls.op_a_sel << " Got=" << (int)top->o_op_a_sel_d << std::endl; current_pass=false;}
        if(top->o_pc_target_src_sel_d != static_cast<uint8_t>(tc.controls.pc_target_sel)) {std::cout << "  FAIL: PcTargetSel_D. Exp=" << (int)tc.controls.pc_target_sel << " Got=" << (int)top->o_pc_target_src_sel_d << std::endl; current_pass=false;}
        if(top->o_funct3_d != instr_funct3) {std::cout << "  FAIL: Funct3_D. Exp=0b" << std::bitset<3>(instr_funct3) << " Got=0b" << std::bitset<3>(top->o_funct3_d) << std::endl; current_pass=false;}

        // Check PC values (latched from IF/ID)
        if(top->o_pc_d != tc.pc_val) {std::cout << "  FAIL: PC_D. Exp=0x" << std::hex << tc.pc_val << " Got=0x" << top->o_pc_d << std::dec << std::endl; current_pass=false;}
        if(top->o_pc_plus_4_d != (tc.pc_val + 4)) {std::cout << "  FAIL: PCPlus4_D. Exp=0x" << std::hex << (tc.pc_val + 4) << " Got=0x" << top->o_pc_plus_4_d << std::dec << std::endl; current_pass=false;}

        // Check Register Addresses (extracted from instruction)
        if(top->o_rd_addr_d != instr_rd) {std::cout << "  FAIL: RdAddr_D. Exp=" << (int)instr_rd << " Got=" << (int)top->o_rd_addr_d << std::endl; current_pass=false;}
        if(top->o_rs1_addr_d != instr_rs1) {std::cout << "  FAIL: Rs1Addr_D. Exp=" << (int)instr_rs1 << " Got=" << (int)top->o_rs1_addr_d << std::endl; current_pass=false;}
        if(top->o_rs2_addr_d != instr_rs2) {std::cout << "  FAIL: Rs2Addr_D. Exp=" << (int)instr_rs2 << " Got=" << (int)top->o_rs2_addr_d << std::endl; current_pass=false;}

        // Check rs1_data_d
        if (tc.expected_rs1_data.has_value()) {
            uint64_t expected_val_rs1 = (instr_rs1 == 0) ? 0 : tc.expected_rs1_data.value();
            if (top->o_rs1_data_d != expected_val_rs1) {
                std::cout << "  FAIL: Rs1Data_D. Exp=0x" << std::hex << expected_val_rs1 << " Got=0x" << top->o_rs1_data_d << std::dec << std::endl;
                current_pass = false;
            }
        }
        // Check rs2_data_d
        if (tc.expected_rs2_data.has_value()) {
            uint64_t expected_val_rs2 = (instr_rs2 == 0 && instr_opcode != OPCODE_STORE_CPP) ? 0 : tc.expected_rs2_data.value();
             // For STORE, rs2_data_d is the data to be stored, read from register rs2.
             // It should be tc.expected_rs2_data.value() even if rs2 is x0 (though storing x0 is unusual).
             // For non-STORE instructions, if rs2 is x0, data should be 0.
            if (instr_opcode == OPCODE_STORE_CPP) { // Ensure store takes the direct expected value
                expected_val_rs2 = tc.expected_rs2_data.value();
            }


            if (top->o_rs2_data_d != expected_val_rs2) {
                std::cout << "  FAIL: Rs2Data_D. Exp=0x" << std::hex << expected_val_rs2 << " Got=0x" << top->o_rs2_data_d << " (Instr rs2: " << (int)instr_rs2 << ")" << std::dec << std::endl;
                current_pass = false;
            }
        }
        // Check imm_ext_d
        if (tc.expected_imm_ext.has_value()) {
            if (top->o_imm_ext_d != tc.expected_imm_ext.value()) {
                std::cout << "  FAIL: ImmExt_D. Exp=0x" << std::hex << tc.expected_imm_ext.value() << " Got=0x" << top->o_imm_ext_d << std::dec << std::endl;
                current_pass = false;
            }
        }

        if (current_pass) {
            std::cout << "  PASS" << std::endl;
            passed_count++;
        } else {
            std::cout << "  FAILED" << std::endl;
        }
    }

    std::cout << "\nDecode Stage Testbench Finished. Passed " << passed_count << "/" << test_cases.size() << " test cases." << std::endl;
    if (tfp) tfp->close();
    delete top;
    return (passed_count == test_cases.size()) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/register_file_tb.sv ---
`include "common/defines.svh"

module register_file_tb (
    input  logic clk,
    input  logic rst_n,

    // Inputs to Register File
    // Read Port 1
    input  logic [`REG_ADDR_WIDTH-1:0] i_rs1_addr,
    // Read Port 2
    input  logic [`REG_ADDR_WIDTH-1:0] i_rs2_addr,
    // Write Port
    input  logic                       i_rd_write_en_wb,
    input  logic [`REG_ADDR_WIDTH-1:0] i_rd_addr_wb,
    input  logic [`DATA_WIDTH-1:0]     i_rd_data_wb,

    // Outputs from Register File
    output logic [`DATA_WIDTH-1:0]     o_rs1_data,
    output logic [`DATA_WIDTH-1:0]     o_rs2_data
);

    register_file u_register_file (
        .clk               (clk),
        .rst_n             (rst_n),
        .rs1_addr_i        (i_rs1_addr),
        .rs1_data_o        (o_rs1_data),
        .rs2_addr_i        (i_rs2_addr),
        .rs2_data_o        (o_rs2_data),
        .rd_write_en_wb_i  (i_rd_write_en_wb),
        .rd_addr_wb_i      (i_rd_addr_wb),
        .rd_data_wb_i      (i_rd_data_wb)
    );

endmodule


--- File: tests/unit/pipeline_tb.cpp ---
// tests/unit/pipeline_tb.cpp
#include "Vpipeline_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"
#include <iostream>
#include <iomanip>
#include <vector>

vluint64_t sim_time = 0;

void tick(Vpipeline_tb* dut, VerilatedVcdC* tfp) {
    dut->clk = 0;
    dut->eval();
    if (tfp) tfp->dump(sim_time);
    sim_time++;

    dut->clk = 1;
    dut->eval();
    if (tfp) tfp->dump(sim_time);
    sim_time++;
}

void reset_pipeline(Vpipeline_tb* dut, VerilatedVcdC* tfp, int cycles = 5) {
    std::cout << "Resetting pipeline..." << std::endl;
    dut->rst_n = 0;
    for (int i = 0; i < cycles; ++i) {
        tick(dut, tfp);
    }
    dut->rst_n = 1;
    tick(dut, tfp); // First tick out of reset
    std::cout << "Pipeline reset complete." << std::endl;
}

void print_debug_info(Vpipeline_tb* dut, int cycle_num) {
    std::cout << "Cycle " << std::setw(3) << std::dec << cycle_num << ": "
              << "PC_F=0x" << std::hex << std::setw(8) << std::setfill('0') << dut->debug_pc_f_o
              << " Instr_F=0x" << std::setw(8) << std::setfill('0') << dut->debug_instr_f_o;

    if (dut->debug_reg_write_wb_o) {
        std::cout << " | WB: x" << std::dec << std::setw(2) << std::setfill(' ') << (int)dut->debug_rd_addr_wb_o
                  << " <= 0x" << std::hex << std::setw(16) << std::setfill('0') << dut->debug_result_w_o;
    } else {
        std::cout << " | WB: NoWrite";
    }
    std::cout << std::setfill(' ') << std::dec << std::endl;
}

void print_regs(Vpipeline_tb* dut) {
    // Accessing internal signals of the register file.
    // This requires Verilator to make them accessible.
    // If regs is not directly accessible, you might need `/* verilator public */`
    // or use more complex DPI/VPI methods for general access.
    // For this example, we assume Verilator makes them available via hierarchical path
    // or that we have added `debug_rf_xN` outputs to pipeline_tb.sv.
    std::cout << "  Registers: "
              << "x1=0x" << std::hex << dut->debug_rf_x1
              << " x2=0x" << dut->debug_rf_x2
              << " x3=0x" << dut->debug_rf_x3
              << " x4=0x" << dut->debug_rf_x4
              << std::dec << std::endl;
}


int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vpipeline_tb* top = new Vpipeline_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("pipeline_tb.vcd");

    std::cout << "Pipeline Testbench Started" << std::endl;

    reset_pipeline(top, tfp);

    // Run for a number of cycles to see instructions propagate
    // Program:
    // 0: addi x1, x0, 1
    // 4: addi x2, x0, 2
    // 8: addi x3, x0, 3
    // C: addi x4, x0, 4

    // Pipeline depth is 5 stages.
    // After 5 cycles, the first instruction should reach WB.
    // After 5+3 = 8 cycles, all 4 instructions should have completed WB.
    // Let's run for ~15 cycles to see everything clear.
    int num_cycles_to_run = 15;

    for (int i = 0; i < num_cycles_to_run; ++i) {
        tick(top, tfp);
        print_debug_info(top, sim_time / 2); // sim_time increments twice per tick
        if (i > 3 && (i % 2 == 0)) { // Print regs periodically after a few instructions might have written back
            print_regs(top);
        }
    }

    std::cout << "\nFinal Register Values after " << num_cycles_to_run << " cycles:" << std::endl;
    print_regs(top);

    // Basic checks (manual verification based on VCD and print_regs for now)
    bool pass = true;
    if (top->debug_rf_x1 != 1) {
        std::cout << "FAIL: x1 expected 1, got 0x" << std::hex << top->debug_rf_x1 << std::dec << std::endl;
        pass = false;
    }
    if (top->debug_rf_x2 != 2) {
        std::cout << "FAIL: x2 expected 2, got 0x" << std::hex << top->debug_rf_x2 << std::dec << std::endl;
        pass = false;
    }
    if (top->debug_rf_x3 != 3) {
        std::cout << "FAIL: x3 expected 3, got 0x" << std::hex << top->debug_rf_x3 << std::dec << std::endl;
        pass = false;
    }
     if (top->debug_rf_x4 != 4) {
        std::cout << "FAIL: x4 expected 4, got 0x" << std::hex << top->debug_rf_x4 << std::dec << std::endl;
        pass = false;
    }


    std::cout << "\nPipeline Testbench Finished." << std::endl;
    if (tfp) tfp->close();
    delete top;

    if (pass) {
        std::cout << "Basic ADDI test sequence: PASS" << std::endl;
        return EXIT_SUCCESS;
    } else {
        std::cout << "Basic ADDI test sequence: FAIL" << std::endl;
        return EXIT_FAILURE;
    }
}


--- File: tests/unit/instruction_memory_tb.cpp ---
// tests/unit/instruction_memory_tb.cpp
#include "Vinstruction_memory_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h" // Optional: if we want VCD for this simple test

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <string>

// Ожидаемые значения из instruction_memory.sv initial block
const uint32_t DEFAULT_NOP_INSTR = 0x00000013;
const uint32_t INSTR_MEM_0 = 0x00100093; // addi x1, x0, 1
const uint32_t INSTR_MEM_1 = 0x00200113; // addi x2, x0, 2
const uint32_t INSTR_MEM_2 = 0x00308193; // addi x3, x1, 3
const uint32_t INSTR_MEM_3 = 0x00110213; // addi x4, x2, 1

const int ROM_SIZE_INSTR = 256; // Должно соответствовать ROM_SIZE в instruction_memory.sv

vluint64_t sim_time_imem = 0; // Отдельное время для этого теста

void eval_imem(Vinstruction_memory_tb* dut, VerilatedVcdC* tfp) {
    dut->eval();
    if (tfp) {
        tfp->dump(sim_time_imem);
    }
    // sim_time_imem++; // Для комбинационного теста время можно не инкрементировать на каждом eval
}

struct ImemTestCase {
    std::string name;
    uint64_t    address;
    uint32_t    expected_instruction;
    bool        expect_defined_behavior; // true if address is within ROM and behavior is defined
};

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vinstruction_memory_tb* top = new Vinstruction_memory_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_instruction_memory.vcd");

    std::cout << "Starting Instruction Memory Testbench" << std::endl;

    std::vector<ImemTestCase> test_cases = {
        {"Read Addr 0 (Instr 0)",       0x00, INSTR_MEM_0, true},
        {"Read Addr 4 (Instr 1)",       0x04, INSTR_MEM_1, true},
        {"Read Addr 8 (Instr 2)",       0x08, INSTR_MEM_2, true},
        {"Read Addr 12 (Instr 3)",      0x0C, INSTR_MEM_3, true},
        {"Read Addr 16 (Uninit, NOP)",  0x10, DEFAULT_NOP_INSTR, true},
        {"Read Addr last valid (NOP)",  (uint64_t)((ROM_SIZE_INSTR - 1) * 4), DEFAULT_NOP_INSTR, true},
        // Тесты для адресов немного за пределами инициализированных, но внутри ROM_SIZE
        {"Read Addr 20 (Uninit, NOP)",  0x14, DEFAULT_NOP_INSTR, true},
        {"Read Addr 0x3F8 (last in ROM)",0x3F8, DEFAULT_NOP_INSTR, true}, // (255*4)
        {"Read Addr 0x3FC (last in ROM)",0x3FC, DEFAULT_NOP_INSTR, true}, // (255*4) -> (256-1)*4

        // Тесты на граничные условия (за пределами ROM)
        // Поведение здесь зависит от Verilator/SystemVerilog для out-of-bounds array access.
        // Verilator может выдать предупреждение или ошибку, или вернуть 'x.
        // Мы ожидаем, что это не приведет к падению симуляции, но значение может быть неопределенным.
        // Для `logic` неинициализированные биты обычно 'x'.
        // Если instruction_memory.sv не обрабатывает out-of-bounds, то это undefined behavior.
        // Мы пометим expect_defined_behavior = false для таких случаев.
        {"Read Addr Out of Bounds High", (uint64_t)(ROM_SIZE_INSTR * 4), 0x0, false}, // Адрес сразу за памятью
        {"Read Addr Very High",          0xFFFFFFFFFFFFFFFCULL,          0x0, false}  // Очень большой адрес
    };

    int passed_count = 0;
    int total_defined_tests = 0;

    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name << std::endl;
        std::cout << "  Address: 0x" << std::hex << tc.address << std::dec << std::endl;

        top->i_address = tc.address;
        eval_imem(top, tfp);
        sim_time_imem++; // Инкрементируем время для каждого тестового случая в VCD

        bool current_pass = true;
        if (tc.expect_defined_behavior) {
            total_defined_tests++;
            if (top->o_instruction != tc.expected_instruction) {
                std::cout << "  FAIL: Instruction Mismatch." << std::endl;
                std::cout << "    Expected: 0x" << std::hex << tc.expected_instruction << std::dec << std::endl;
                std::cout << "    Got:      0x" << std::hex << top->o_instruction << std::dec << std::endl;
                current_pass = false;
            }
        } else {
            // Для неопределенного поведения мы не делаем строгую проверку значения,
            // но убеждаемся, что симуляция не упала (это делается самим фактом выполнения).
            // Можно проверить, что значение содержит 'x', если Verilator так делает.
            // Verilator часто инициализирует 'x' как 0 при преобразовании в uint32_t, если нет явной обработки.
            // Для простоты, просто логируем, что это тест на "неопределенное поведение".
            std::cout << "  INFO: Testing out-of-bounds read. Got: 0x" << std::hex << top->o_instruction << std::dec << ". Behavior might be undefined by DUT." << std::endl;
            // Если бы мы хотели проверить на 'x', это было бы сложнее без DPI или анализа сигнала как строки.
        }

        if (current_pass && tc.expect_defined_behavior) {
            std::cout << "  PASS" << std::endl;
            passed_count++;
        } else if (!tc.expect_defined_behavior) {
            // Считаем тесты на неопределенное поведение "пройденными", если симуляция не упала.
            // Это больше для проверки устойчивости, чем для проверки корректности значения.
             std::cout << "  INFO: Out-of-bounds test case executed." << std::endl;
        } else {
             std::cout << "  FAILED" << std::endl;
        }
    }

    std::cout << "\nInstruction Memory Testbench Finished." << std::endl;
    std::cout << "Passed " << passed_count << "/" << total_defined_tests << " defined behavior tests." << std::endl;

    if (tfp) tfp->close();
    delete top;
    // Успех, если все тесты с ожидаемым поведением прошли
    return (passed_count == total_defined_tests) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/control_unit_tb.sv ---
`include "common/defines.svh"
`include "common/alu_defines.svh"
`include "common/immediate_types.svh"
`include "common/control_signals_defines.svh"

module control_unit_tb (
    // Inputs to control_unit
    input  logic [6:0] i_op,
    input  logic [2:0] i_funct3,
    input  logic       i_funct7_5,

    // Outputs from control_unit
    output logic       o_reg_write_d,
    output logic [1:0] o_result_src_d,
    output logic       o_mem_write_d,
    output logic       o_jump_d,
    output logic       o_branch_d,
    output logic       o_alu_src_d,
    output logic [`ALU_CONTROL_WIDTH-1:0] o_alu_control_d,
    output immediate_type_e o_imm_type_d,
    output logic [2:0] o_funct3_d,
    output alu_a_src_sel_e o_op_a_sel_d,
    output pc_target_src_sel_e o_pc_target_src_sel_d
);

    control_unit u_control_unit (
        .op                (i_op),
        .funct3            (i_funct3),
        .funct7_5          (i_funct7_5),

        .reg_write_d_o     (o_reg_write_d),
        .result_src_d_o    (o_result_src_d),
        .mem_write_d_o     (o_mem_write_d),
        .jump_d_o          (o_jump_d),
        .branch_d_o        (o_branch_d),
        .alu_src_d_o       (o_alu_src_d),
        .alu_control_d_o   (o_alu_control_d),
        .imm_type_d_o      (o_imm_type_d),
        .funct3_d_o        (o_funct3_d),
        .op_a_sel_d_o      (o_op_a_sel_d),
        .pc_target_src_sel_d_o (o_pc_target_src_sel_d)
    );

endmodule


--- File: tests/unit/fetch_tb.sv ---
`include "common/defines.svh"

module fetch_tb (
    input  logic clk,
    input  logic rst_n,

    // Inputs to control fetch stage behavior
    input  logic                       i_stall_f,
    input  logic                       i_pc_src_e,
    input  logic [`DATA_WIDTH-1:0]     i_pc_target_e,
    input  logic                       i_stall_d,
    input  logic                       i_flush_d,

    // Outputs from IF/ID register (to observe)
    output logic [`INSTR_WIDTH-1:0]    o_instr_id,
    output logic [`DATA_WIDTH-1:0]     o_pc_plus_4_id,
    output logic [`DATA_WIDTH-1:0]     o_pc_id,
    output logic [`DATA_WIDTH-1:0]     o_current_pc_f // For observing PC in fetch stage itself
);

    logic [`INSTR_WIDTH-1:0]    instr_f_val;
    logic [`DATA_WIDTH-1:0]     pc_plus_4_f_val;
    logic [`DATA_WIDTH-1:0]     pc_f_val;

    fetch u_fetch (
        .clk            (clk),
        .rst_n          (rst_n),
        .stall_f        (i_stall_f),
        .pc_src_e       (i_pc_src_e),
        .pc_target_e    (i_pc_target_e),
        .instr_f_o      (instr_f_val),
        .pc_plus_4_f_o  (pc_plus_4_f_val),
        .pc_f_o         (pc_f_val)
    );

    if_id_register u_if_id_register (
        .clk            (clk),
        .rst_n          (rst_n),
        .stall_d        (i_stall_d),
        .flush_d        (i_flush_d),
        .instr_f_i      (instr_f_val),
        .pc_plus_4_f_i  (pc_plus_4_f_val),
        .pc_f_i         (pc_f_val),
        .instr_id_o     (o_instr_id),
        .pc_plus_4_id_o (o_pc_plus_4_id),
        .pc_id_o        (o_pc_id)
    );

    assign o_current_pc_f = pc_f_val;

endmodule


--- File: tests/unit/register_file_tb.cpp ---
// tests/unit/register_file_tb.cpp
#include "Vregister_file_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <string>

vluint64_t sim_time_regfile = 0;

// Определяем один полный тактовый цикл: negedge -> posedge
// Чтение происходит на negedge, запись на posedge.
void step_clk_regfile(Vregister_file_tb* dut, VerilatedVcdC* tfp) {
    // ---- ФАЗА 1: CLK LOW (negedge) ----
    dut->clk = 0;
    dut->eval(); // Обновляются выходы RF (rs1_data_o, rs2_data_o) на основе адресов, поданных до этого
    if (tfp) tfp->dump(sim_time_regfile);
    sim_time_regfile++;

    // ---- ФАЗА 2: CLK HIGH (posedge) ----
    dut->clk = 1;
    dut->eval(); // Происходит запись в RF, если rd_write_en_wb_i активен
    if (tfp) tfp->dump(sim_time_regfile);
    sim_time_regfile++;
}

void reset_regfile(Vregister_file_tb* dut, VerilatedVcdC* tfp) {
    dut->rst_n = 0;
    // Установить входы в безопасное состояние во время сброса
    dut->i_rs1_addr = 0;
    dut->i_rs2_addr = 0;
    dut->i_rd_write_en_wb = 0;
    dut->i_rd_addr_wb = 0;
    dut->i_rd_data_wb = 0;

    // Пропустить несколько тактов с активным сбросом
    for (int i = 0; i < 3; ++i) {
        step_clk_regfile(dut, tfp);
    }
    dut->rst_n = 1;
    dut->eval(); // Применить rst_n = 1
    step_clk_regfile(dut, tfp); // Один такт после снятия сброса для стабилизации
    std::cout << "DUT Register File Reset" << std::endl;
}

struct RegFileTestCase {
    std::string name;
    // Действия перед проверкой чтения (могут быть множественные записи)
    std::vector<std::tuple<uint8_t, uint64_t, bool>> writes_before_read; // rd_addr, rd_data, write_enable

    // Адреса для чтения
    uint8_t  rs1_addr_check;
    uint8_t  rs2_addr_check;

    // Ожидаемые данные чтения (после всех записей и одного negedge для чтения)
    uint64_t expected_rs1_data;
    uint64_t expected_rs2_data;
};


int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vregister_file_tb* top = new Vregister_file_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_register_file.vcd");

    std::cout << "Starting Register File Testbench" << std::endl;

    std::vector<RegFileTestCase> test_cases = {
        {
            "Reset Check (Read x1, x2 after reset)",
            {}, // No writes
            1, 2, 0x0, 0x0 // Expect 0 from x1, x2 after reset
        },
        {
            "Write x1, Read x1",
            {{1, 0xABCD, true}}, // Write 0xABCD to x1
            1, 0, 0xABCD, 0x0 // Read x1, read x0
        },
        {
            "Write x5, x10; Read x5, x10",
            {{5, 0x12345, true}, {10, 0x6789A, true}},
            5, 10, 0x12345, 0x6789A
        },
        {
            "Write x0 (ignored), Read x0, x1",
            {{0, 0xFFFF, true}, {1, 0x1111, true}}, // Attempt write to x0
            0, 1, 0x0, 0x1111 // Expect x0=0, x1=0x1111
        },
        {
            "Write Disabled, Read x3",
            {{3, 0xBAD, false}}, // Write disabled
            3, 0, 0x0, 0x0 // Expect x3 to be 0 (from reset)
        },
        {
            "Sequential Writes to same reg, Read last",
            {{2, 0x100, true}, {2, 0x200, true}},
            2, 0, 0x200, 0x0
        },
        {
            "Read two different written regs",
            {{7, 0x777, true}, {15, 0xFFF, true}},
            7, 15, 0x777, 0xFFF
        },
        // // Тест на "запись в первой половине, чтение во второй" (write x1, read x1 in same conceptual cycle)
        // // В нашем RF: запись по posedge, чтение по negedge.
        // // Если мы выставим write_en, rd_addr, rd_data И rs1_addr (равный rd_addr) одновременно,
        // // то на negedge этого же такта мы прочитаем СТАРОЕ значение,
        // // а новое будет записано на posedge.
        // // Чтобы прочитать НОВОЕ значение, нужен следующий negedge.
        {
            "Write x1 (valA), then setup read x1, check old val, then check new val",
            {{1, 0xAAAA, true}}, // x1 = 0xAAAA after this set of operations + 1st tick
            1, 0, 0xAAAA, 0 // Прочитаем 0xAAAA на negedge после записи
        }
        // // Более сложный тест для read-during-write:
        // // 1. Записать начальное значение в x1 (e.g. 0x1111)
        // // 2. В одном такте: настроить запись нового значения в x1 (e.g. 0x2222) И настроить чтение x1
        // // 3. На negedge этого такта, o_rs1_data должно быть 0x1111 (старое).
        // // 4. На следующем negedge, o_rs1_data должно быть 0x2222 (новое).
    };


    int passed_count = 0;
    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name << std::endl;
        reset_regfile(top, tfp); // Сбрасываем RF перед каждым набором операций

        // Выполняем предварительные записи
        for (const auto& write_op : tc.writes_before_read) {
            top->i_rd_addr_wb = std::get<0>(write_op);
            top->i_rd_data_wb = std::get<1>(write_op);
            top->i_rd_write_en_wb = std::get<2>(write_op);
            std::cout << "  Setup Write: Addr=" << (int)top->i_rd_addr_wb
                      << ", Data=0x" << std::hex << top->i_rd_data_wb
                      << ", WE=" << (int)top->i_rd_write_en_wb << std::dec << std::endl;
            step_clk_regfile(top, tfp); // Запись происходит на posedge этого такта
        }
        // Сбрасываем сигналы записи после всех операций записи, чтобы они не влияли на чтение
        top->i_rd_write_en_wb = 0;
        top->i_rd_addr_wb = 0; // Можно не сбрасывать, если write_en=0
        top->i_rd_data_wb = 0; // Можно не сбрасывать

        // Устанавливаем адреса для чтения
        top->i_rs1_addr = tc.rs1_addr_check;
        top->i_rs2_addr = tc.rs2_addr_check;
        std::cout << "  Setup Read: rs1_addr=" << (int)top->i_rs1_addr
                  << ", rs2_addr=" << (int)top->i_rs2_addr << std::endl;

        // Данные чтения будут доступны на выходах o_rs1_data, o_rs2_data
        // ПОСЛЕ negedge следующего тактового импульса (или текущего, если адреса уже были установлены).
        // Сделаем один полный такт, чтобы чтение по negedge произошло.
        step_clk_regfile(top, tfp);
        // После этого step_clk_regfile, на выходах o_rs1_data и o_rs2_data должны быть актуальные значения

        bool current_pass = true;
        if (top->o_rs1_data != tc.expected_rs1_data) {
            std::cout << "  FAIL: RS1 Data Mismatch." << std::endl;
            std::cout << "    rs1_addr=" << (int)tc.rs1_addr_check << std::endl;
            std::cout << "    Expected: 0x" << std::hex << tc.expected_rs1_data << std::dec << std::endl;
            std::cout << "    Got:      0x" << std::hex << top->o_rs1_data << std::dec << std::endl;
            current_pass = false;
        }
        if (top->o_rs2_data != tc.expected_rs2_data) {
            std::cout << "  FAIL: RS2 Data Mismatch." << std::endl;
            std::cout << "    rs2_addr=" << (int)tc.rs2_addr_check << std::endl;
            std::cout << "    Expected: 0x" << std::hex << tc.expected_rs2_data << std::dec << std::endl;
            std::cout << "    Got:      0x" << std::hex << top->o_rs2_data << std::dec << std::endl;
            current_pass = false;
        }

        if (current_pass) {
            std::cout << "  PASS" << std::endl;
            passed_count++;
        } else {
            std::cout << "  FAILED" << std::endl;
        }
    }
     // Тест на чтение во время записи (read-during-write)
    std::cout << "\nRunning Test: Read-during-write x1" << std::endl;
    reset_regfile(top, tfp);
    // 1. Записать начальное значение в x1
    top->i_rd_addr_wb = 1; top->i_rd_data_wb = 0x1111; top->i_rd_write_en_wb = 1;
    step_clk_regfile(top, tfp); // x1 = 0x1111
    top->i_rd_write_en_wb = 0; // Снять WE

    // 2. Настроить чтение x1 и одновременно запись нового значения в x1
    top->i_rs1_addr = 1; // Читаем x1
    top->i_rs2_addr = 0; // Читаем x0
    top->i_rd_addr_wb = 1; // Пишем в x1
    top->i_rd_data_wb = 0x2222; // Новое значение
    top->i_rd_write_en_wb = 1;  // Разрешить запись

    // 3. Первый такт после установки:
    // clk=0 (negedge): rs1_data_o читает значение *до* записи 0x2222. Должно быть 0x1111.
    // clk=1 (posedge): 0x2222 записывается в regs[1].
    top->clk = 0; top->eval(); if(tfp) tfp->dump(sim_time_regfile); sim_time_regfile++;
    bool pass_rdw1 = (top->o_rs1_data == 0x1111);
    std::cout << "  Read-during-write (cycle 1 negedge): rs1_addr=1, read_data=0x" << std::hex << top->o_rs1_data << ". Expected 0x1111." << std::dec << std::endl;

    top->clk = 1; top->eval(); if(tfp) tfp->dump(sim_time_regfile); sim_time_regfile++;
    // Запись 0x2222 произошла

    top->i_rd_write_en_wb = 0; // Снять WE для следующего чтения

    // 4. Второй такт:
    // clk=0 (negedge): rs1_data_o читает новое значение 0x2222.
    top->clk = 0; top->eval(); if(tfp) tfp->dump(sim_time_regfile); sim_time_regfile++;
    bool pass_rdw2 = (top->o_rs1_data == 0x2222);
    std::cout << "  Read-during-write (cycle 2 negedge): rs1_addr=1, read_data=0x" << std::hex << top->o_rs1_data << ". Expected 0x2222." << std::dec << std::endl;

    top->clk = 1; top->eval(); if(tfp) tfp->dump(sim_time_regfile); sim_time_regfile++;


    if (pass_rdw1 && pass_rdw2) {
        std::cout << "  Read-during-write: PASS" << std::endl;
        passed_count++;
        test_cases.emplace_back(); // "Фиктивный" успешный тест для общего счетчика
    } else {
        std::cout << "  Read-during-write: FAILED" << std::endl;
        test_cases.emplace_back(); // "Фиктивный" проваленный тест
    }


    std::cout << "\nRegister File Testbench Finished. Passed " << passed_count << "/" << test_cases.size() << " tests." << std::endl;

    if (tfp) tfp->close();
    delete top;
    return (passed_count == test_cases.size()) ? EXIT_SUCCESS : EXIT_FAILURE;
}


