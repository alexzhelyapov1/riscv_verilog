--- File: rtl/common/control_signals_defines.svh ---
`ifndef CONTROL_SIGNALS_DEFINES_SVH
`define CONTROL_SIGNALS_DEFINES_SVH


typedef enum logic [1:0] {
    ALU_A_SRC_RS1,
    ALU_A_SRC_PC,
    ALU_A_SRC_ZERO
} alu_a_src_sel_e;

typedef enum logic [0:0] {
    PC_TARGET_SRC_PC_PLUS_IMM,
    PC_TARGET_SRC_ALU_JALR
} pc_target_src_sel_e;


`endif


--- File: rtl/common/riscv_opcodes.svh ---
`ifndef RISCV_OPCODES_SVH
`define RISCV_OPCODES_SVH

`define OPCODE_LUI        7'b0110111
`define OPCODE_AUIPC      7'b0010111
`define OPCODE_JAL        7'b1101111
`define OPCODE_JALR       7'b1100111
`define OPCODE_BRANCH     7'b1100011
`define OPCODE_LOAD       7'b0000011
`define OPCODE_STORE      7'b0100011
`define OPCODE_OP_IMM   7'b0010011
`define OPCODE_OP         7'b0110011
`define OPCODE_MISC_MEM 7'b0001111
`define OPCODE_SYSTEM     7'b1110011

`define FUNCT3_ADDI       3'b000
`define FUNCT3_ADD_SUB    3'b000
`define FUNCT3_SLLI       3'b001
`define FUNCT3_SLL        3'b001
`define FUNCT3_SLTI       3'b010
`define FUNCT3_SLT        3'b010
`define FUNCT3_SLTIU      3'b011
`define FUNCT3_SLTU       3'b011
`define FUNCT3_XORI       3'b100
`define FUNCT3_XOR        3'b100
`define FUNCT3_SRLI_SRAI  3'b101
`define FUNCT3_SRL_SRA    3'b101
`define FUNCT3_ORI        3'b110
`define FUNCT3_OR         3'b110
`define FUNCT3_ANDI       3'b111
`define FUNCT3_AND        3'b111

`define FUNCT3_BEQ        3'b000
`define FUNCT3_BNE        3'b001
`define FUNCT3_BLT        3'b100
`define FUNCT3_BGE        3'b101
`define FUNCT3_BLTU       3'b110
`define FUNCT3_BGEU       3'b111

`define FUNCT3_LB         3'b000
`define FUNCT3_LH         3'b001
`define FUNCT3_LW         3'b010
`define FUNCT3_LD         3'b011
`define FUNCT3_LBU        3'b100
`define FUNCT3_LHU        3'b101
`define FUNCT3_LWU        3'b110

`define FUNCT3_SB         3'b000
`define FUNCT3_SH         3'b001
`define FUNCT3_SW         3'b010
`define FUNCT3_SD         3'b011

`define FUNCT3_JALR       3'b000
`define FUNCT7_5_SUB_ALT  1'b1
`define FUNCT7_5_ADD_MAIN 1'b0


`endif


--- File: rtl/common/defines.svh ---
`ifndef COMMON_DEFINES_SVH
`define COMMON_DEFINES_SVH

`define DATA_WIDTH 64
`define INSTR_WIDTH 32
`define REG_ADDR_WIDTH 5
`define PC_RESET_VALUE 64'h00000000
`define NOP_INSTRUCTION 32'h00000013

`endif


--- File: rtl/common/immediate_types.svh ---
`ifndef IMMEDIATE_TYPES_SVH
`define IMMEDIATE_TYPES_SVH

typedef enum logic [2:0] {
    IMM_TYPE_NONE, // For R-type or when immediate is not used by ALU operand B or for address calculation
    IMM_TYPE_I,    // I-type (ADDI, LW, JALR)
    IMM_TYPE_S,    // S-type (SW)
    IMM_TYPE_B,    // B-type (Branches)
    IMM_TYPE_U,    // U-type (LUI, AUIPC)
    IMM_TYPE_J,     // J-type (JAL)
    IMM_TYPE_ISHIFT // SLLI, SRLI, SRAI
} immediate_type_e;

`endif


--- File: rtl/common/pipeline_types.svh ---
`ifndef PIPELINE_TYPES_SVH
`define PIPELINE_TYPES_SVH

`include "common/defines.svh"
`include "common/alu_defines.svh"
`include "common/control_signals_defines.svh"
`include "common/immediate_types.svh"

typedef struct packed {
    logic [`INSTR_WIDTH-1:0]    instr;
    logic [`DATA_WIDTH-1:0]     pc;
    logic [`DATA_WIDTH-1:0]     pc_plus_4;
} if_id_data_t;

typedef struct packed {
    logic                       reg_write;
    logic [1:0]                 result_src;
    logic                       mem_write;
    logic                       jump;
    logic                       branch;
    logic                       alu_src;
    logic [`ALU_CONTROL_WIDTH-1:0] alu_control;
    alu_a_src_sel_e             op_a_sel;
    pc_target_src_sel_e         pc_target_src_sel;
    logic [2:0]                 funct3;

    logic [`DATA_WIDTH-1:0]     pc;
    logic [`DATA_WIDTH-1:0]     pc_plus_4;
    logic [`DATA_WIDTH-1:0]     rs1_data;
    logic [`DATA_WIDTH-1:0]     rs2_data;
    logic [`DATA_WIDTH-1:0]     imm_ext;

    logic [`REG_ADDR_WIDTH-1:0] rs1_addr;
    logic [`REG_ADDR_WIDTH-1:0] rs2_addr;
    logic [`REG_ADDR_WIDTH-1:0] rd_addr;
} id_ex_data_t;

typedef struct packed {
    logic                       reg_write;
    logic [1:0]                 result_src;
    logic                       mem_write;
    logic [2:0]                 funct3;

    logic [`DATA_WIDTH-1:0]     alu_result;
    logic [`DATA_WIDTH-1:0]     rs2_data;
    logic [`DATA_WIDTH-1:0]     pc_plus_4;

    logic [`REG_ADDR_WIDTH-1:0] rd_addr;
} ex_mem_data_t;

typedef struct packed {
    logic                       reg_write;
    logic [1:0]                 result_src;

    logic [`DATA_WIDTH-1:0]     read_data_mem;
    logic [`DATA_WIDTH-1:0]     alu_result;
    logic [`DATA_WIDTH-1:0]     pc_plus_4;

    logic [`REG_ADDR_WIDTH-1:0] rd_addr;
} mem_wb_data_t;

typedef struct packed {
    logic                       reg_write_en;
    logic [`REG_ADDR_WIDTH-1:0] rd_addr;
    logic [`DATA_WIDTH-1:0]     result_to_rf;
} rf_write_data_t;


typedef struct packed {
    logic       stall_f;
    logic       stall_d;
    logic       flush_d;
    logic       flush_e;
    logic [1:0] forward_a_e;
    logic [1:0] forward_b_e;
} hazard_control_t;


localparam if_id_data_t NOP_IF_ID_DATA = '{
    instr:      32'b0,
    pc:         `PC_RESET_VALUE,
    pc_plus_4:  `PC_RESET_VALUE + 4
};

localparam id_ex_data_t NOP_ID_EX_DATA = '{
    reg_write:          1'b0,
    result_src:         2'b00,
    mem_write:          1'b0,
    jump:               1'b0,
    branch:             1'b0,
    alu_src:            1'b0,
    alu_control:        `ALU_OP_ADD,
    op_a_sel:           ALU_A_SRC_RS1,
    pc_target_src_sel:  PC_TARGET_SRC_PC_PLUS_IMM,
    funct3:             3'b000,
    pc:                 `PC_RESET_VALUE,
    pc_plus_4:          `PC_RESET_VALUE + 4,
    rs1_data:           `DATA_WIDTH'(0),
    rs2_data:           `DATA_WIDTH'(0),
    imm_ext:            `DATA_WIDTH'(0),
    rs1_addr:           `REG_ADDR_WIDTH'(0),
    rs2_addr:           `REG_ADDR_WIDTH'(0),
    rd_addr:            `REG_ADDR_WIDTH'(0)
};

localparam ex_mem_data_t NOP_EX_MEM_DATA = '{
    reg_write:          1'b0,
    result_src:         2'b00,
    mem_write:          1'b0,
    funct3:             3'b000,
    alu_result:         `DATA_WIDTH'(0),
    rs2_data:           `DATA_WIDTH'(0),
    pc_plus_4:          `PC_RESET_VALUE + 4,
    rd_addr:            `REG_ADDR_WIDTH'(0)
};

localparam mem_wb_data_t NOP_MEM_WB_DATA = '{
    reg_write:          1'b0,
    result_src:         2'b00,
    read_data_mem:      `DATA_WIDTH'(0),
    alu_result:         `DATA_WIDTH'(0),
    pc_plus_4:          `PC_RESET_VALUE + 4,
    rd_addr:            `REG_ADDR_WIDTH'(0)
};

`endif


--- File: rtl/common/alu_defines.svh ---
`ifndef ALU_DEFINES_SVH
`define ALU_DEFINES_SVH

`define ALU_CONTROL_WIDTH 4

`define ALU_OP_ADD  4'b0000 // Addition
`define ALU_OP_SUB  4'b0001 // Subtraction
`define ALU_OP_SLL  4'b0010 // Shift Left Logical
`define ALU_OP_SLT  4'b0011 // Set Less Than (Signed)
`define ALU_OP_SLTU 4'b0100 // Set Less Than (Unsigned)
`define ALU_OP_XOR  4'b0101 // XOR
`define ALU_OP_SRL  4'b0110 // Shift Right Logical
`define ALU_OP_SRA  4'b0111 // Shift Right Arithmetic
`define ALU_OP_OR   4'b1000 // OR
`define ALU_OP_AND  4'b1001 // AND

`endif


--- File: rtl/core/control_unit.sv ---
`include "common/defines.svh"
`include "common/alu_defines.svh"
`include "common/immediate_types.svh"
`include "common/riscv_opcodes.svh"
`include "common/control_signals_defines.svh"

module control_unit (
    input  logic [6:0] op,
    input  logic [2:0] funct3,
    input  logic       funct7_5,

    output logic       reg_write_d_o,
    output logic [1:0] result_src_d_o,
    output logic       mem_write_d_o,
    output logic       jump_d_o,
    output logic       branch_d_o,
    output logic       alu_src_d_o,
    output logic [`ALU_CONTROL_WIDTH-1:0] alu_control_d_o,
    output immediate_type_e imm_type_d_o,
    output logic [2:0] funct3_d_o,
    output alu_a_src_sel_e op_a_sel_d_o,
    output pc_target_src_sel_e pc_target_src_sel_d_o
);

    assign funct3_d_o = funct3;

    always_comb begin
        reg_write_d_o   = 1'b0;
        result_src_d_o  = 2'b00;
        mem_write_d_o   = 1'b0;
        jump_d_o        = 1'b0;
        branch_d_o      = 1'b0;
        alu_src_d_o     = 1'b0;
        alu_control_d_o = `ALU_OP_ADD;
        imm_type_d_o    = IMM_TYPE_NONE;
        op_a_sel_d_o    = ALU_A_SRC_RS1;
        pc_target_src_sel_d_o = PC_TARGET_SRC_PC_PLUS_IMM;

        case (op)
            `OPCODE_LUI: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b1;
                imm_type_d_o    = IMM_TYPE_U;
                op_a_sel_d_o    = ALU_A_SRC_ZERO;
                alu_control_d_o = `ALU_OP_ADD;
                result_src_d_o  = 2'b00;
            end
            `OPCODE_AUIPC: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b1;
                imm_type_d_o    = IMM_TYPE_U;
                op_a_sel_d_o    = ALU_A_SRC_PC;
                alu_control_d_o = `ALU_OP_ADD;
                result_src_d_o  = 2'b00;
            end
            `OPCODE_JAL: begin
                reg_write_d_o   = 1'b1;
                jump_d_o        = 1'b1;
                imm_type_d_o    = IMM_TYPE_J;
                result_src_d_o  = 2'b10;
                pc_target_src_sel_d_o = PC_TARGET_SRC_PC_PLUS_IMM;
                op_a_sel_d_o    = ALU_A_SRC_PC;
                alu_src_d_o     = 1'b1;
                alu_control_d_o = `ALU_OP_ADD;
            end
            `OPCODE_JALR: begin
                reg_write_d_o   = 1'b1;
                jump_d_o        = 1'b1;
                alu_src_d_o     = 1'b1;
                imm_type_d_o    = IMM_TYPE_I;
                op_a_sel_d_o    = ALU_A_SRC_RS1;
                alu_control_d_o = `ALU_OP_ADD;
                result_src_d_o  = 2'b10;
                pc_target_src_sel_d_o = PC_TARGET_SRC_ALU_JALR;
            end
            `OPCODE_BRANCH: begin
                branch_d_o      = 1'b1;
                alu_src_d_o     = 1'b0;
                op_a_sel_d_o    = ALU_A_SRC_RS1;
                imm_type_d_o    = IMM_TYPE_B;
                reg_write_d_o   = 1'b0;
                pc_target_src_sel_d_o = PC_TARGET_SRC_PC_PLUS_IMM;
                case (funct3)
                    `FUNCT3_BEQ:  alu_control_d_o = `ALU_OP_SUB;
                    `FUNCT3_BNE:  alu_control_d_o = `ALU_OP_SUB;
                    `FUNCT3_BLT:  alu_control_d_o = `ALU_OP_SLT;
                    `FUNCT3_BGE:  alu_control_d_o = `ALU_OP_SLT;
                    `FUNCT3_BLTU: alu_control_d_o = `ALU_OP_SLTU;
                    `FUNCT3_BGEU: alu_control_d_o = `ALU_OP_SLTU;
                    default:      alu_control_d_o = `ALU_OP_ADD;
                endcase
            end
            `OPCODE_LOAD: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b1;
                imm_type_d_o    = IMM_TYPE_I;
                op_a_sel_d_o    = ALU_A_SRC_RS1;
                alu_control_d_o = `ALU_OP_ADD;
                result_src_d_o  = 2'b01;
                mem_write_d_o   = 1'b0;
            end
            `OPCODE_STORE: begin
                alu_src_d_o     = 1'b1;
                imm_type_d_o    = IMM_TYPE_S;
                op_a_sel_d_o    = ALU_A_SRC_RS1;
                alu_control_d_o = `ALU_OP_ADD;
                mem_write_d_o   = 1'b1;
                reg_write_d_o   = 1'b0;
            end
            `OPCODE_OP_IMM: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b1;
                imm_type_d_o    = (funct3 == `FUNCT3_SLLI || funct3 == `FUNCT3_SRLI_SRAI) ? IMM_TYPE_ISHIFT : IMM_TYPE_I;
                op_a_sel_d_o    = ALU_A_SRC_RS1;
                result_src_d_o  = 2'b00;
                case (funct3)
                    `FUNCT3_ADDI:  alu_control_d_o = `ALU_OP_ADD;
                    `FUNCT3_SLTI:  alu_control_d_o = `ALU_OP_SLT;
                    `FUNCT3_SLTIU: alu_control_d_o = `ALU_OP_SLTU;
                    `FUNCT3_XORI:  alu_control_d_o = `ALU_OP_XOR;
                    `FUNCT3_ORI:   alu_control_d_o = `ALU_OP_OR;
                    `FUNCT3_ANDI:  alu_control_d_o = `ALU_OP_AND;
                    `FUNCT3_SLLI:  alu_control_d_o = `ALU_OP_SLL;
                    `FUNCT3_SRLI_SRAI: begin
                        if (funct7_5 == `FUNCT7_5_SUB_ALT) alu_control_d_o = `ALU_OP_SRA;
                        else                               alu_control_d_o = `ALU_OP_SRL;
                    end
                    default:       alu_control_d_o = `ALU_OP_ADD;
                endcase
            end
            `OPCODE_OP: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b0;
                op_a_sel_d_o    = ALU_A_SRC_RS1;
                imm_type_d_o    = IMM_TYPE_NONE;
                result_src_d_o  = 2'b00;
                case (funct3)
                    `FUNCT3_ADD_SUB: begin
                        if (funct7_5 == `FUNCT7_5_SUB_ALT) alu_control_d_o = `ALU_OP_SUB;
                        else                               alu_control_d_o = `ALU_OP_ADD;
                    end
                    `FUNCT3_SLL:   alu_control_d_o = `ALU_OP_SLL;
                    `FUNCT3_SLT:   alu_control_d_o = `ALU_OP_SLT;
                    `FUNCT3_SLTU:  alu_control_d_o = `ALU_OP_SLTU;
                    `FUNCT3_XOR:   alu_control_d_o = `ALU_OP_XOR;
                    `FUNCT3_SRL_SRA: begin
                        if (funct7_5 == `FUNCT7_5_SUB_ALT) alu_control_d_o = `ALU_OP_SRA;
                        else                               alu_control_d_o = `ALU_OP_SRL;
                    end
                    `FUNCT3_OR:    alu_control_d_o = `ALU_OP_OR;
                    `FUNCT3_AND:   alu_control_d_o = `ALU_OP_AND;
                    default:       alu_control_d_o = `ALU_OP_ADD;
                endcase
            end
        endcase
    end
endmodule


--- File: rtl/core/hazard_unit.sv ---
`include "common/defines.svh"

module hazard_unit (
    input  logic [`REG_ADDR_WIDTH-1:0] rs1_addr_ex_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rs2_addr_ex_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_ex_i,
    input  logic                       result_src_ex0_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rs1_addr_id_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rs2_addr_id_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_mem_i,
    input  logic                       reg_write_mem_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_wb_i,
    input  logic                       reg_write_wb_i,
    input  logic                       pc_src_ex_i,

    output logic [1:0]                 forward_a_ex_o,
    output logic [1:0]                 forward_b_ex_o,
    output logic                       stall_fetch_o,
    output logic                       stall_decode_o,
    output logic                       flush_decode_o,
    output logic                       flush_execute_o
);

    logic lw_stall_internal;

    always_comb begin
        if (reg_write_mem_i && (rd_addr_mem_i != `REG_ADDR_WIDTH'(0)) && (rd_addr_mem_i == rs1_addr_ex_i)) begin
            forward_a_ex_o = 2'b10;
        end else if (reg_write_wb_i && (rd_addr_wb_i != `REG_ADDR_WIDTH'(0)) && (rd_addr_wb_i == rs1_addr_ex_i)) begin
            forward_a_ex_o = 2'b01;
        end else begin
            forward_a_ex_o = 2'b00;
        end

        if (reg_write_mem_i && (rd_addr_mem_i != `REG_ADDR_WIDTH'(0)) && (rd_addr_mem_i == rs2_addr_ex_i)) begin
            forward_b_ex_o = 2'b10;
        end else if (reg_write_wb_i && (rd_addr_wb_i != `REG_ADDR_WIDTH'(0)) && (rd_addr_wb_i == rs2_addr_ex_i)) begin
            forward_b_ex_o = 2'b01;
        end else begin
            forward_b_ex_o = 2'b00;
        end

        lw_stall_internal = result_src_ex0_i &&
                            ( (rs1_addr_id_i == rd_addr_ex_i && rs1_addr_id_i != `REG_ADDR_WIDTH'(0) ) ||
                              (rs2_addr_id_i == rd_addr_ex_i && rs2_addr_id_i != `REG_ADDR_WIDTH'(0) ) );

        lw_stall_internal = result_src_ex0_i && (rd_addr_ex_i != `REG_ADDR_WIDTH'(0)) &&
                           ( (rs1_addr_id_i == rd_addr_ex_i) ||
                             (rs2_addr_id_i == rd_addr_ex_i) );

        stall_fetch_o  = lw_stall_internal;
        stall_decode_o = lw_stall_internal;

        flush_decode_o = pc_src_ex_i;
        flush_execute_o = lw_stall_internal || pc_src_ex_i;
    end

endmodule


--- File: rtl/core/alu.sv ---
`include "common/defines.svh"
`include "common/alu_defines.svh"

module alu (
    input  logic [`DATA_WIDTH-1:0]     operand_a,
    input  logic [`DATA_WIDTH-1:0]     operand_b,
    input  logic [`ALU_CONTROL_WIDTH-1:0] alu_control,
    output logic [`DATA_WIDTH-1:0]     result,
    output logic                       zero_flag
);

    logic [`DATA_WIDTH-1:0] result_comb;
    logic [5:0]             shift_amount;

    assign shift_amount = operand_b[5:0];

    always_comb begin
        result_comb = {`DATA_WIDTH{1'bx}};

        case (alu_control)
            `ALU_OP_ADD:  result_comb = operand_a + operand_b;
            `ALU_OP_SUB:  result_comb = operand_a - operand_b;
            `ALU_OP_SLL:  result_comb = operand_a << shift_amount;
            `ALU_OP_SLT:  result_comb = ($signed(operand_a) < $signed(operand_b)) ? {{`DATA_WIDTH-1{1'b0}}, 1'b1} : {`DATA_WIDTH{1'b0}};
            `ALU_OP_SLTU: result_comb = (operand_a < operand_b) ? {{`DATA_WIDTH-1{1'b0}}, 1'b1} : {`DATA_WIDTH{1'b0}};
            `ALU_OP_XOR:  result_comb = operand_a ^ operand_b;
            `ALU_OP_SRL:  result_comb = operand_a >> shift_amount;
            `ALU_OP_SRA:  result_comb = $signed(operand_a) >>> shift_amount;
            `ALU_OP_OR:   result_comb = operand_a | operand_b;
            `ALU_OP_AND:  result_comb = operand_a & operand_b;
            default:      result_comb = {`DATA_WIDTH{1'bx}};
        endcase
    end

    assign result = result_comb;
    assign zero_flag = (result_comb == {`DATA_WIDTH{1'b0}});

endmodule


--- File: rtl/core/memory_stage.sv ---
`include "common/pipeline_types.svh"

module memory_stage #(
    parameter string DATA_MEM_INIT_FILE_PARAM = ""
)(
    input  logic clk,
    input  logic rst_n,
    input  ex_mem_data_t           ex_mem_data_i,
    output mem_wb_data_t           mem_wb_data_o
);

    logic [`DATA_WIDTH-1:0] mem_read_data_internal;

    data_memory #(
        .DATA_MEM_INIT_FILE(DATA_MEM_INIT_FILE_PARAM)
    ) u_data_memory (
        .clk            (clk),
        .rst_n          (rst_n),
        .addr_i         (ex_mem_data_i.alu_result),
        .write_data_i   (ex_mem_data_i.rs2_data),
        .mem_write_en_i (ex_mem_data_i.mem_write),
        .funct3_i       (ex_mem_data_i.funct3),
        .read_data_o    (mem_read_data_internal)
    );

    assign mem_wb_data_o.reg_write      = ex_mem_data_i.reg_write;
    assign mem_wb_data_o.result_src     = ex_mem_data_i.result_src;
    assign mem_wb_data_o.read_data_mem  = mem_read_data_internal;
    assign mem_wb_data_o.alu_result     = ex_mem_data_i.alu_result;
    assign mem_wb_data_o.pc_plus_4      = ex_mem_data_i.pc_plus_4;
    assign mem_wb_data_o.rd_addr        = ex_mem_data_i.rd_addr;

endmodule


--- File: rtl/core/fetch.sv ---
`include "common/pipeline_types.svh"

module fetch #(
    parameter string INSTR_MEM_INIT_FILE_PARAM = "",
    parameter logic [`DATA_WIDTH-1:0] PC_INIT_VALUE_PARAM = `PC_RESET_VALUE
)(
    input  logic clk,
    input  logic rst_n,
    input  logic                       stall_f_i,
    input  logic                       pc_src_e_i,
    input  logic [`DATA_WIDTH-1:0]     pc_target_e_i,

    output if_id_data_t                if_id_data_o
);

    logic [`DATA_WIDTH-1:0] pc_reg;
    logic [`DATA_WIDTH-1:0] pc_next;
    logic [`DATA_WIDTH-1:0] pc_plus_4_temp;
    logic [`INSTR_WIDTH-1:0] instr_mem_data;

    instruction_memory #(
        .INSTR_MEM_INIT_FILE_PARAM(INSTR_MEM_INIT_FILE_PARAM)
    ) i_instr_mem (
        .address     (pc_reg),
        .instruction (instr_mem_data)
    );

    assign pc_plus_4_temp = pc_reg + 4;
    assign pc_next = pc_src_e_i ? pc_target_e_i : pc_plus_4_temp;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            pc_reg <= PC_INIT_VALUE_PARAM;
        end else if (!stall_f_i) begin
            pc_reg <= pc_next;
        end
    end

    assign if_id_data_o.instr      = instr_mem_data;
    assign if_id_data_o.pc         = pc_reg;
    assign if_id_data_o.pc_plus_4  = pc_plus_4_temp;

endmodule


--- File: rtl/core/writeback_stage.sv ---
`include "common/pipeline_types.svh"

module writeback_stage (
    input  mem_wb_data_t           mem_wb_data_i,
    output rf_write_data_t         rf_write_data_o
);
    logic [`DATA_WIDTH-1:0] result_selected_for_rf;

    always_comb begin
        case (mem_wb_data_i.result_src)
            2'b00:  result_selected_for_rf = mem_wb_data_i.alu_result;
            2'b01:  result_selected_for_rf = mem_wb_data_i.read_data_mem;
            2'b10:  result_selected_for_rf = mem_wb_data_i.pc_plus_4;
            default: result_selected_for_rf = `DATA_WIDTH'('x);
        endcase
    end

    assign rf_write_data_o.reg_write_en = mem_wb_data_i.reg_write;
    assign rf_write_data_o.rd_addr      = mem_wb_data_i.rd_addr;
    assign rf_write_data_o.result_to_rf = result_selected_for_rf;

endmodule


--- File: rtl/core/data_memory.sv ---

`include "common/defines.svh"
`include "common/riscv_opcodes.svh"

module data_memory #(
    parameter string DATA_MEM_INIT_FILE = ""
)(
    input  logic clk,
    input  logic rst_n,

    input  logic [`DATA_WIDTH-1:0]     addr_i,
    input  logic [`DATA_WIDTH-1:0]     write_data_i,
    input  logic                       mem_write_en_i,
    input  logic [2:0]                 funct3_i,

    output logic [`DATA_WIDTH-1:0]     read_data_o
);

    localparam MEM_ADDR_BITS = 10;
    localparam MEM_SIZE_BYTES = 1 << MEM_ADDR_BITS;
    localparam MEM_ADDR_WIDTH = $clog2(MEM_SIZE_BYTES);

    logic [7:0] mem [MEM_SIZE_BYTES-1:0];
    logic [`DATA_WIDTH-1:0] aligned_word_read_comb;
    logic [`DATA_WIDTH-1:0] temp_read_data_comb;

    always_comb begin
        temp_read_data_comb = `DATA_WIDTH'('x);
        aligned_word_read_comb = `DATA_WIDTH'('0);

        if (addr_i < MEM_SIZE_BYTES) begin
            logic [2:0] byte_offset_in_word = addr_i[2:0];
            logic [`DATA_WIDTH-1:0] current_aligned_word;

            for (int i = 0; i < (`DATA_WIDTH/8); i++) begin
                if (((addr_i & ~((`DATA_WIDTH/8) - 1)) + `DATA_WIDTH'(i)) < MEM_SIZE_BYTES) begin
                    current_aligned_word[(i*8) +: 8] = mem[(addr_i & ~((`DATA_WIDTH/8) - 1)) + `DATA_WIDTH'(i)];
                end else begin
                    current_aligned_word[(i*8) +: 8] = 8'h00;
                end
            end
            aligned_word_read_comb = current_aligned_word;

            case (funct3_i)
                `FUNCT3_LB: begin
                    temp_read_data_comb = {{(`DATA_WIDTH-8){aligned_word_read_comb[byte_offset_in_word*8 + 7]}}, aligned_word_read_comb[byte_offset_in_word*8 +: 8]};
                end
                `FUNCT3_LH: begin
                    temp_read_data_comb = {{(`DATA_WIDTH-16){aligned_word_read_comb[byte_offset_in_word*8 + 15]}}, aligned_word_read_comb[byte_offset_in_word*8 +: 16]};
                end
                `FUNCT3_LW: begin
                    temp_read_data_comb = {{(`DATA_WIDTH-32){aligned_word_read_comb[byte_offset_in_word*8 + 31]}}, aligned_word_read_comb[byte_offset_in_word*8 +: 32]};
                end
                `FUNCT3_LD: begin
                    temp_read_data_comb = aligned_word_read_comb;
                end
                `FUNCT3_LBU: begin
                    temp_read_data_comb = {{(`DATA_WIDTH-8){1'b0}}, aligned_word_read_comb[byte_offset_in_word*8 +: 8]};
                end
                `FUNCT3_LHU: begin
                    temp_read_data_comb = {{(`DATA_WIDTH-16){1'b0}}, aligned_word_read_comb[byte_offset_in_word*8 +: 16]};
                end
                `FUNCT3_LWU: begin
                    temp_read_data_comb = {{(`DATA_WIDTH-32){1'b0}}, aligned_word_read_comb[byte_offset_in_word*8 +: 32]};
                end
                default: temp_read_data_comb = `DATA_WIDTH'('x);
            endcase
        end else begin
             temp_read_data_comb = `DATA_WIDTH'('x);
        end
    end
    assign read_data_o = temp_read_data_comb;

    always_ff @(posedge clk) begin
        if (mem_write_en_i) begin

            case (funct3_i)
                `FUNCT3_SB: begin
                    if (addr_i < MEM_SIZE_BYTES) mem[addr_i] = write_data_i[7:0];
                end
                `FUNCT3_SH: begin
                    if (addr_i < MEM_SIZE_BYTES - 1) begin
                        mem[addr_i]   <= write_data_i[7:0];
                        mem[addr_i+1] <= write_data_i[15:8];
                    end
                end
                `FUNCT3_SW: begin
                    if (addr_i < MEM_SIZE_BYTES - 3) begin
                        for (int i = 0; i < 4; i++) begin
                            mem[addr_i+i] <= write_data_i[i*8 +: 8];
                        end
                    end
                end
                `FUNCT3_SD: begin
                     if (addr_i < MEM_SIZE_BYTES - 7) begin
                        for (int i = 0; i < (`DATA_WIDTH/8); i++) begin
                            mem[addr_i + `DATA_WIDTH'(i)] <= write_data_i[i*8 +: 8];
                        end
                    end
                end
                default: ;
            endcase
        end
    end

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (int i = 0; i < MEM_SIZE_BYTES; i++) begin
                mem[i] = 8'h00;
            end
        end
    end

    initial begin
        if (DATA_MEM_INIT_FILE != "") begin
            $readmemh(DATA_MEM_INIT_FILE, mem);
        end
    end

endmodule


--- File: rtl/core/execute.sv ---
`include "common/pipeline_types.svh"
`include "common/riscv_opcodes.svh"

module execute (
    input  id_ex_data_t            id_ex_data_i,
    input  logic [`DATA_WIDTH-1:0] forward_data_mem_i,
    input  logic [`DATA_WIDTH-1:0] forward_data_wb_i,
    input  logic [1:0]             forward_a_e_i,
    input  logic [1:0]             forward_b_e_i,

    output ex_mem_data_t           ex_mem_data_o,
    output logic                   pc_src_o,
    output logic [`DATA_WIDTH-1:0] pc_target_addr_o
);

    logic [`DATA_WIDTH-1:0] alu_operand_a_mux_out;
    logic [`DATA_WIDTH-1:0] alu_operand_a_final;
    logic [`DATA_WIDTH-1:0] alu_operand_b_mux_out;
    logic [`DATA_WIDTH-1:0] alu_operand_b_final;
    logic [`DATA_WIDTH-1:0] write_data_e;
    logic [`DATA_WIDTH-1:0] alu_result_internal;
    logic                   alu_zero_flag_internal;

    always_comb begin
        case (id_ex_data_i.op_a_sel)
            ALU_A_SRC_RS1:  alu_operand_a_mux_out = id_ex_data_i.rs1_data;
            ALU_A_SRC_PC:   alu_operand_a_mux_out = id_ex_data_i.pc;
            ALU_A_SRC_ZERO: alu_operand_a_mux_out = `DATA_WIDTH'(0);
            default:        alu_operand_a_mux_out = id_ex_data_i.rs1_data;
        endcase
    end

    always_comb begin
        case (forward_a_e_i)
            2'b00:  alu_operand_a_final = alu_operand_a_mux_out;
            2'b10:  alu_operand_a_final = forward_data_mem_i;
            2'b01:  alu_operand_a_final = forward_data_wb_i;
            default: alu_operand_a_final = alu_operand_a_mux_out;
        endcase
    end

    assign alu_operand_b_mux_out = id_ex_data_i.alu_src ? id_ex_data_i.imm_ext : id_ex_data_i.rs2_data;

    always_comb begin
        case (forward_b_e_i)
            2'b00:  write_data_e = alu_operand_b_mux_out;
            2'b10:  write_data_e = forward_data_mem_i;
            2'b01:  write_data_e = forward_data_wb_i;
            default: write_data_e = alu_operand_b_mux_out;
        endcase
        if (id_ex_data_i.alu_src) begin
            alu_operand_b_final = id_ex_data_i.imm_ext;
        end else begin
            alu_operand_b_final = write_data_e;
        end
    end

    alu u_alu (
        .operand_a   (alu_operand_a_final),
        .operand_b   (alu_operand_b_final),
        .alu_control (id_ex_data_i.alu_control),
        .result      (alu_result_internal),
        .zero_flag   (alu_zero_flag_internal)
    );

    logic [`DATA_WIDTH-1:0] target_addr_pc_plus_imm;
    logic [`DATA_WIDTH-1:0] target_addr_alu_jalr_masked;

    assign target_addr_pc_plus_imm = id_ex_data_i.pc + id_ex_data_i.imm_ext;
    assign target_addr_alu_jalr_masked = alu_result_internal & ~(`DATA_WIDTH'(1));
    assign pc_target_addr_o = (id_ex_data_i.pc_target_src_sel == PC_TARGET_SRC_ALU_JALR) ?
                               target_addr_alu_jalr_masked : target_addr_pc_plus_imm;

    logic take_branch;
    always_comb begin
        take_branch = 1'b0;
        if (id_ex_data_i.branch) begin
            case (id_ex_data_i.funct3)
                `FUNCT3_BEQ:  take_branch = alu_zero_flag_internal;
                `FUNCT3_BNE:  take_branch = ~alu_zero_flag_internal;
                `FUNCT3_BLT:  take_branch = alu_result_internal[0];
                `FUNCT3_BGE:  take_branch = ~alu_result_internal[0];
                `FUNCT3_BLTU: take_branch = alu_result_internal[0];
                `FUNCT3_BGEU: take_branch = ~alu_result_internal[0];
                default:      take_branch = 1'b0;
            endcase
        end
    end

    assign pc_src_o = (id_ex_data_i.jump) || (id_ex_data_i.branch && take_branch);
    assign ex_mem_data_o.reg_write  = id_ex_data_i.reg_write;
    assign ex_mem_data_o.result_src = id_ex_data_i.result_src;
    assign ex_mem_data_o.mem_write  = id_ex_data_i.mem_write;
    assign ex_mem_data_o.funct3     = id_ex_data_i.funct3;
    assign ex_mem_data_o.alu_result = alu_result_internal;
    assign ex_mem_data_o.rs2_data   = write_data_e;
    assign ex_mem_data_o.rd_addr    = id_ex_data_i.rd_addr;
    assign ex_mem_data_o.pc_plus_4  = id_ex_data_i.pc_plus_4;

endmodule


--- File: rtl/core/decode.sv ---
`include "common/pipeline_types.svh"
`include "common/riscv_opcodes.svh"

module decode (
    input  logic clk,
    input  logic rst_n,
    input  if_id_data_t     if_id_data_i,
    input  rf_write_data_t  writeback_data_i,

    output id_ex_data_t     id_ex_data_o,
    output logic [`REG_ADDR_WIDTH-1:0] rs1_addr_d_o,
    output logic [`REG_ADDR_WIDTH-1:0] rs2_addr_d_o
);

    logic [6:0] opcode;
    logic [`REG_ADDR_WIDTH-1:0] rs1_addr_instr;
    logic [`REG_ADDR_WIDTH-1:0] rs2_addr_instr;
    logic [`REG_ADDR_WIDTH-1:0] rd_addr_instr;
    logic [2:0] funct3_instr;
    logic       funct7_5_instr;

    immediate_type_e imm_type_sel_internal;
    logic [`DATA_WIDTH-1:0] rs1_data_from_rf;
    logic [`DATA_WIDTH-1:0] rs2_data_from_rf;
    logic [`DATA_WIDTH-1:0] imm_ext_internal;

    assign opcode         = if_id_data_i.instr[6:0];
    assign rd_addr_instr  = if_id_data_i.instr[11:7];
    assign funct3_instr   = if_id_data_i.instr[14:12];
    assign rs1_addr_instr = if_id_data_i.instr[19:15];
    assign rs2_addr_instr = if_id_data_i.instr[24:20];
    assign funct7_5_instr = if_id_data_i.instr[30];

    control_unit u_control_unit (
        .op                    (opcode),
        .funct3                (funct3_instr),
        .funct7_5              (funct7_5_instr),
        .reg_write_d_o         (id_ex_data_o.reg_write),
        .result_src_d_o        (id_ex_data_o.result_src),
        .mem_write_d_o         (id_ex_data_o.mem_write),
        .jump_d_o              (id_ex_data_o.jump),
        .branch_d_o            (id_ex_data_o.branch),
        .alu_src_d_o           (id_ex_data_o.alu_src),
        .alu_control_d_o       (id_ex_data_o.alu_control),
        .imm_type_d_o          (imm_type_sel_internal),
        .funct3_d_o            (id_ex_data_o.funct3),
        .op_a_sel_d_o          (id_ex_data_o.op_a_sel),
        .pc_target_src_sel_d_o (id_ex_data_o.pc_target_src_sel)
    );

    register_file u_register_file (
        .clk               (clk),
        .rst_n             (rst_n),
        .rs1_addr_i        (rs1_addr_instr),
        .rs1_data_o        (rs1_data_from_rf),
        .rs2_addr_i        (rs2_addr_instr),
        .rs2_data_o        (rs2_data_from_rf),
        .rd_write_en_wb_i  (writeback_data_i.reg_write_en),
        .rd_addr_wb_i      (writeback_data_i.rd_addr),
        .rd_data_wb_i      (writeback_data_i.result_to_rf)
    );

    immediate_generator u_immediate_generator (
        .instr_i           (if_id_data_i.instr),
        .imm_type_sel_i    (imm_type_sel_internal),
        .imm_ext_o         (imm_ext_internal)
    );

    assign id_ex_data_o.pc         = if_id_data_i.pc;
    assign id_ex_data_o.pc_plus_4  = if_id_data_i.pc_plus_4;
    assign id_ex_data_o.rs1_data   = rs1_data_from_rf;
    assign id_ex_data_o.rs2_data   = rs2_data_from_rf;
    assign id_ex_data_o.imm_ext    = imm_ext_internal;
    assign id_ex_data_o.rs1_addr   = rs1_addr_instr;
    assign id_ex_data_o.rs2_addr   = rs2_addr_instr;
    assign id_ex_data_o.rd_addr    = rd_addr_instr;
    assign rs1_addr_d_o = rs1_addr_instr;
    assign rs2_addr_d_o = rs2_addr_instr;

endmodule


--- File: rtl/core/immediate_generator.sv ---
`include "common/defines.svh"
`include "common/immediate_types.svh"

module immediate_generator (
    input  logic [`INSTR_WIDTH-1:0] instr_i,
    input  immediate_type_e         imm_type_sel_i,
    output logic [`DATA_WIDTH-1:0]  imm_ext_o
);

    logic [`DATA_WIDTH-1:0] imm_i_type;
    logic [`DATA_WIDTH-1:0] imm_s_type;
    logic [`DATA_WIDTH-1:0] imm_b_type;
    logic [`DATA_WIDTH-1:0] imm_u_type;
    logic [`DATA_WIDTH-1:0] imm_j_type;
    logic [`DATA_WIDTH-1:0] imm_ishift_type;

    assign imm_i_type = {{(`DATA_WIDTH-12){instr_i[31]}}, instr_i[31:20]};
    assign imm_s_type = {{(`DATA_WIDTH-12){instr_i[31]}}, instr_i[31:25], instr_i[11:7]};
    assign imm_b_type = {{(`DATA_WIDTH-13){instr_i[31]}}, instr_i[31], instr_i[7], instr_i[30:25], instr_i[11:8], 1'b0};
    assign imm_u_type = {{(`DATA_WIDTH-32){instr_i[31]}}, instr_i[31:12], 12'h000};
    assign imm_j_type = {{(`DATA_WIDTH-21){instr_i[31]}}, instr_i[31], instr_i[19:12], instr_i[20], instr_i[30:21], 1'b0};
    assign imm_ishift_type = `DATA_WIDTH'(instr_i[25:20]);

    always_comb begin
        case (imm_type_sel_i)
            IMM_TYPE_I:    imm_ext_o = imm_i_type;
            IMM_TYPE_S:    imm_ext_o = imm_s_type;
            IMM_TYPE_B:    imm_ext_o = imm_b_type;
            IMM_TYPE_U:    imm_ext_o = imm_u_type;
            IMM_TYPE_J:    imm_ext_o = imm_j_type;
            IMM_TYPE_ISHIFT: imm_ext_o = imm_ishift_type;
            IMM_TYPE_NONE: imm_ext_o = `DATA_WIDTH'(0);
            default:       imm_ext_o = `DATA_WIDTH'('x);
        endcase
    end

endmodule


--- File: rtl/core/register_file.sv ---
`include "common/defines.svh"

module register_file (
    input  logic clk,
    input  logic rst_n,
    input  logic [`REG_ADDR_WIDTH-1:0] rs1_addr_i,
    output logic [`DATA_WIDTH-1:0]     rs1_data_o,

    input  logic [`REG_ADDR_WIDTH-1:0] rs2_addr_i,
    output logic [`DATA_WIDTH-1:0]     rs2_data_o,

    input  logic                       rd_write_en_wb_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_wb_i,
    input  logic [`DATA_WIDTH-1:0]     rd_data_wb_i
);

    logic [`DATA_WIDTH-1:0] regs[31:0] /* verilator public */;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (int i = 0; i < 32; i++) begin
                regs[i] <= `DATA_WIDTH'(0);
            end
        end else begin
            if (rd_write_en_wb_i && (rd_addr_wb_i != `REG_ADDR_WIDTH'(0))) begin
                regs[rd_addr_wb_i] <= rd_data_wb_i;
            end
        end
    end

    logic [`DATA_WIDTH-1:0] rs1_data_from_array;
    assign rs1_data_from_array = (rs1_addr_i == `REG_ADDR_WIDTH'(0)) ? `DATA_WIDTH'(0) : regs[rs1_addr_i];

    logic [`DATA_WIDTH-1:0] rs2_data_from_array;
    assign rs2_data_from_array = (rs2_addr_i == `REG_ADDR_WIDTH'(0)) ? `DATA_WIDTH'(0) : regs[rs2_addr_i];

    assign rs1_data_o = (rd_write_en_wb_i && (rd_addr_wb_i != 0) && (rs1_addr_i == rd_addr_wb_i))
                        ? rd_data_wb_i
                        : rs1_data_from_array;

    assign rs2_data_o = (rd_write_en_wb_i && (rd_addr_wb_i != 0) && (rs2_addr_i == rd_addr_wb_i))
                        ? rd_data_wb_i
                        : rs2_data_from_array;

    initial begin
        for (int i = 0; i < 2**`REG_ADDR_WIDTH; i++) begin
            regs[i] = `DATA_WIDTH'b0;
        end
    end

endmodule


--- File: rtl/core/instruction_memory.sv ---
`include "common/defines.svh"

module instruction_memory (
    input  logic [`DATA_WIDTH-1:0] address,
    output logic [`INSTR_WIDTH-1:0] instruction
);

    parameter string INSTR_MEM_INIT_FILE_PARAM = "";
    localparam ROM_SIZE = 2**20;
    localparam ROM_ADDR_WIDTH = $clog2(ROM_SIZE);

    logic [`INSTR_WIDTH-1:0] mem[ROM_SIZE-1:0];
    logic [ROM_ADDR_WIDTH-1:0] mem_idx;

    initial begin
        for (int i = 0; i < ROM_SIZE; i++) begin
            mem[i] = `NOP_INSTRUCTION;
        end

        if (INSTR_MEM_INIT_FILE_PARAM != "") begin
            $readmemh(INSTR_MEM_INIT_FILE_PARAM, mem);
        end else begin
            mem[0] = 32'h00100093; // addi x1, x0, 1
            mem[1] = 32'h00200113; // addi x2, x0, 2
            mem[2] = 32'h00308193; // addi x3, x1, 3
            mem[3] = 32'h00110213; // addi x4, x2, 1
        end
    end

    assign mem_idx = address[ROM_ADDR_WIDTH+2-1:2];
    assign instruction = (mem_idx < ROM_SIZE) ?
                         mem[mem_idx] :
                         `NOP_INSTRUCTION;

endmodule


--- File: rtl/pipeline.sv ---
`default_nettype none
`timescale 1ns/1ps

`include "common/pipeline_types.svh"

module pipeline #(
    parameter string INSTR_MEM_INIT_FILE = "",
    parameter logic [`DATA_WIDTH-1:0] PC_START_ADDR = `PC_RESET_VALUE,
    parameter string DATA_MEM_INIT_FILE = ""
)(
    input  logic clk,
    input  logic rst_n,

    output logic [`DATA_WIDTH-1:0] debug_pc_f,
    output logic [`INSTR_WIDTH-1:0] debug_instr_f,
    output logic                   debug_reg_write_wb,
    output logic [`REG_ADDR_WIDTH-1:0] debug_rd_addr_wb,
    output logic [`DATA_WIDTH-1:0] debug_result_w
);

    if_id_data_t    if_id_data_q, if_id_data_d;
    id_ex_data_t    id_ex_data_q, id_ex_data_d;
    ex_mem_data_t   ex_mem_data_q, ex_mem_data_d;
    mem_wb_data_t   mem_wb_data_q, mem_wb_data_d;

    if_id_data_t    if_id_data_from_fetch;
    id_ex_data_t    id_ex_data_from_decode;
    ex_mem_data_t   ex_mem_data_from_execute;
    mem_wb_data_t   mem_wb_data_from_memory;
    rf_write_data_t rf_write_data_from_wb;

    logic                   pc_src_ex_o;
    logic [`DATA_WIDTH-1:0] pc_target_ex_o;

    // For hazard_unit
    logic [1:0] forward_a_ex_signal;
    logic [1:0] forward_b_ex_signal;
    logic       stall_fetch_signal;
    logic       stall_decode_signal;
    logic       flush_decode_signal;
    logic       flush_execute_signal;

    logic [`REG_ADDR_WIDTH-1:0] rs1_addr_id_signal;
    logic [`REG_ADDR_WIDTH-1:0] rs2_addr_id_signal;

    fetch #(
        .INSTR_MEM_INIT_FILE_PARAM(INSTR_MEM_INIT_FILE),
        .PC_INIT_VALUE_PARAM(PC_START_ADDR)
    ) u_fetch (
        .clk                (clk),
        .rst_n              (rst_n),
        .stall_f_i          (stall_fetch_signal),
        .pc_src_e_i         (pc_src_ex_o),
        .pc_target_e_i      (pc_target_ex_o),
        .if_id_data_o       (if_id_data_from_fetch)
    );

    decode u_decode (
        .clk                (clk),
        .rst_n              (rst_n),
        .if_id_data_i       (if_id_data_q),
        .writeback_data_i   (rf_write_data_from_wb),
        .id_ex_data_o       (id_ex_data_from_decode),
        .rs1_addr_d_o       (rs1_addr_id_signal),
        .rs2_addr_d_o       (rs2_addr_id_signal)
    );

    execute u_execute (
        .id_ex_data_i       (id_ex_data_q),
        .forward_data_mem_i (ex_mem_data_q.alu_result),
        .forward_data_wb_i  (rf_write_data_from_wb.result_to_rf),
        .forward_a_e_i      (forward_a_ex_signal),
        .forward_b_e_i      (forward_b_ex_signal),
        .ex_mem_data_o      (ex_mem_data_from_execute),
        .pc_src_o           (pc_src_ex_o),
        .pc_target_addr_o   (pc_target_ex_o)
    );

    memory_stage #(
        .DATA_MEM_INIT_FILE_PARAM(DATA_MEM_INIT_FILE)
    ) u_memory_stage (
        .clk                (clk),
        .rst_n              (rst_n),
        .ex_mem_data_i      (ex_mem_data_q),
        .mem_wb_data_o      (mem_wb_data_from_memory)
    );

    writeback_stage u_writeback_stage (
        .mem_wb_data_i      (mem_wb_data_q),
        .rf_write_data_o    (rf_write_data_from_wb)
    );

    hazard_unit u_hazard_unit (
        .rs1_addr_ex_i    (id_ex_data_q.rs1_addr),
        .rs2_addr_ex_i    (id_ex_data_q.rs2_addr),
        .rd_addr_ex_i     (id_ex_data_q.rd_addr),
        .result_src_ex0_i (id_ex_data_q.result_src[0]),

        .rs1_addr_id_i    (rs1_addr_id_signal),
        .rs2_addr_id_i    (rs2_addr_id_signal),

        .rd_addr_mem_i    (ex_mem_data_q.rd_addr),
        .reg_write_mem_i  (ex_mem_data_q.reg_write),

        .rd_addr_wb_i     (mem_wb_data_q.rd_addr),
        .reg_write_wb_i   (mem_wb_data_q.reg_write),

        .pc_src_ex_i      (pc_src_ex_o),

        .forward_a_ex_o   (forward_a_ex_signal),
        .forward_b_ex_o   (forward_b_ex_signal),
        .stall_fetch_o    (stall_fetch_signal),
        .stall_decode_o   (stall_decode_signal),
        .flush_decode_o   (flush_decode_signal),
        .flush_execute_o  (flush_execute_signal)
    );

    // IF/ID Register Logic
    always_comb begin
        if (flush_decode_signal) begin
            if_id_data_d = NOP_IF_ID_DATA;
        end else if (stall_decode_signal) begin
            if_id_data_d = if_id_data_q; // Keep current data
        end else begin
            if_id_data_d = if_id_data_from_fetch; // Latch new data
        end
    end
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            if_id_data_q <= NOP_IF_ID_DATA;
            if_id_data_q.pc <= PC_START_ADDR;
            if_id_data_q.pc_plus_4 <= PC_START_ADDR + 4;
        end else begin
            if_id_data_q <= if_id_data_d;
        end
    end

    // ID/EX Register Logic
    always_comb begin
        if (flush_execute_signal) begin
            id_ex_data_d = NOP_ID_EX_DATA;
        end else begin
            id_ex_data_d = id_ex_data_from_decode;
        end
    end
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            id_ex_data_q <= NOP_ID_EX_DATA;
            id_ex_data_q.pc <= PC_START_ADDR;
            id_ex_data_q.pc_plus_4 <= PC_START_ADDR + 4;
        end else begin
            id_ex_data_q <= id_ex_data_d;
        end
    end

    // EX/MEM Register Logic
    assign ex_mem_data_d = ex_mem_data_from_execute;
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            ex_mem_data_q <= NOP_EX_MEM_DATA;
        end else begin
            ex_mem_data_q <= ex_mem_data_d;
        end
    end

    // MEM/WB Register Logic
    assign mem_wb_data_d = mem_wb_data_from_memory;
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            mem_wb_data_q <= NOP_MEM_WB_DATA;
        end else begin
            mem_wb_data_q <= mem_wb_data_d;
        end
    end

    assign debug_pc_f         = if_id_data_from_fetch.pc;
    assign debug_instr_f      = if_id_data_from_fetch.instr;
    assign debug_reg_write_wb = rf_write_data_from_wb.reg_write_en;
    assign debug_rd_addr_wb   = rf_write_data_from_wb.rd_addr;
    assign debug_result_w     = rf_write_data_from_wb.result_to_rf;

endmodule


