--- File: rtl/common/control_signals_defines.svh ---
// rtl/common/control_signals_defines.svh
`ifndef CONTROL_SIGNALS_DEFINES_SVH
`define CONTROL_SIGNALS_DEFINES_SVH

// Selector for ALU Operand A
typedef enum logic [1:0] {
    ALU_A_SRC_RS1,   // Select RS1 data
    ALU_A_SRC_PC,    // Select PC
    ALU_A_SRC_ZERO   // Select constant Zero (for LUI: 0 + Imm)
    // ALU_A_SRC_FWD // Will be handled by forwarding logic, this selects the *original* source
} alu_a_src_sel_e;

// Selector for PC Target Address source in Execute stage
typedef enum logic [0:0] { // Only two main sources for now
    PC_TARGET_SRC_PC_PLUS_IMM, // Target = PC + Immediate (for Branch, JAL)
    PC_TARGET_SRC_ALU_JALR     // Target = (ALU_Result from RS1+Imm) & ~1 (for JALR)
} pc_target_src_sel_e;

`endif // CONTROL_SIGNALS_DEFINES_SVH


--- File: rtl/common/riscv_opcodes.svh ---
// rtl/common/riscv_opcodes.svh
`ifndef RISCV_OPCODES_SVH
`define RISCV_OPCODES_SVH

// Opcodes (bottom 7 bits of instruction)
`define OPCODE_LUI        7'b0110111 // Load Upper Immediate
`define OPCODE_AUIPC      7'b0010111 // Add Upper Immediate to PC
`define OPCODE_JAL        7'b1101111 // Jump and Link
`define OPCODE_JALR       7'b1100111 // Jump and Link Register
`define OPCODE_BRANCH     7'b1100011 // Conditional Branches (BEQ, BNE, etc.)
`define OPCODE_LOAD       7'b0000011 // Loads (LB, LH, LW, LD, LBU, LHU, LWU)
`define OPCODE_STORE      7'b0100011 // Stores (SB, SH, SW, SD)
`define OPCODE_OP_IMM   7'b0010011 // Immediate Arithmetic/Logic (ADDI, SLTI, etc.)
`define OPCODE_OP         7'b0110011 // Register-Register Arithmetic/Logic (ADD, SUB, etc.)
`define OPCODE_MISC_MEM 7'b0001111 // FENCE, FENCE.I
`define OPCODE_SYSTEM     7'b1110011 // ECALL, EBREAK, CSR instructions

// Funct3 codes for OP_IMM, OP, BRANCH, LOAD, STORE, JALR
// For OP_IMM & OP
`define FUNCT3_ADDI       3'b000 // ADDI
`define FUNCT3_ADD_SUB    3'b000 // ADD/SUB (OP)
`define FUNCT3_SLLI       3'b001 // SLLI (OP_IMM)
`define FUNCT3_SLL        3'b001 // SLL (OP)
`define FUNCT3_SLTI       3'b010 // SLTI (OP_IMM)
`define FUNCT3_SLT        3'b010 // SLT (OP)
`define FUNCT3_SLTIU      3'b011 // SLTIU (OP_IMM)
`define FUNCT3_SLTU       3'b011 // SLTU (OP)
`define FUNCT3_XORI       3'b100 // XORI (OP_IMM)
`define FUNCT3_XOR        3'b100 // XOR (OP)
`define FUNCT3_SRLI_SRAI  3'b101 // SRLI/SRAI (OP_IMM) - Distinguish by funct7
`define FUNCT3_SRL_SRA    3'b101 // SRL/SRA (OP)     - Distinguish by funct7
`define FUNCT3_ORI        3'b110 // ORI (OP_IMM)
`define FUNCT3_OR         3'b110 // OR (OP)
`define FUNCT3_ANDI       3'b111 // ANDI (OP_IMM)
`define FUNCT3_AND        3'b111 // AND (OP)

// For BRANCH
`define FUNCT3_BEQ        3'b000
`define FUNCT3_BNE        3'b001
`define FUNCT3_BLT        3'b100
`define FUNCT3_BGE        3'b101
`define FUNCT3_BLTU       3'b110
`define FUNCT3_BGEU       3'b111

// For LOAD
`define FUNCT3_LB         3'b000
`define FUNCT3_LH         3'b001
`define FUNCT3_LW         3'b010
`define FUNCT3_LD         3'b011 // RV64
`define FUNCT3_LBU        3'b100
`define FUNCT3_LHU        3'b101
`define FUNCT3_LWU        3'b110 // RV64

// For STORE
`define FUNCT3_SB         3'b000
`define FUNCT3_SH         3'b001
`define FUNCT3_SW         3'b010
`define FUNCT3_SD         3'b011 // RV64

// For JALR
`define FUNCT3_JALR       3'b000

// Funct7 codes (or relevant bits)
// For ADD/SUB and SRA/SRL distinction in OP and OP_IMM type instructions.
// For R-type (OP) and I-type shifts (OP_IMM), bit 5 of funct7 (instr[30]) is often used.
`define FUNCT7_5_SUB_ALT  1'b1 // For SUB, SRA, SRAI (funct7[5])
`define FUNCT7_5_ADD_MAIN 1'b0 // For ADD, SRL, SRLI (funct7[5])
// `define FUNCT7_SRL        7'b0000000 (SRL, SRLI, SRLW, SRLIW)
// `define FUNCT7_SRA        7'b0100000 (SRA, SRAI, SRAW, SRAIW)
// `define FUNCT7_ADD        7'b0000000
// `define FUNCT7_SUB        7'b0100000

`endif // RISCV_OPCODES_SVH


--- File: rtl/common/defines.svh ---
`ifndef COMMON_DEFINES_SVH
`define COMMON_DEFINES_SVH

`define DATA_WIDTH 64
`define INSTR_WIDTH 32
`define REG_ADDR_WIDTH 5

`endif


--- File: rtl/common/immediate_types.svh ---
// rtl/common/immediate_types.svh
`ifndef IMMEDIATE_TYPES_SVH
`define IMMEDIATE_TYPES_SVH

// Enum for selecting immediate type in immediate_generator
// This allows the control unit to specify exactly which format to use.
typedef enum logic [2:0] {
    IMM_TYPE_NONE, // For R-type or when immediate is not used by ALU operand B or for address calculation
    IMM_TYPE_I,    // I-type (ADDI, LW, JALR)
    IMM_TYPE_S,    // S-type (SW)
    IMM_TYPE_B,    // B-type (Branches)
    IMM_TYPE_U,    // U-type (LUI, AUIPC)
    IMM_TYPE_J,     // J-type (JAL)
    IMM_TYPE_ISHIFT // Новый тип для SLLI, SRLI, SRAI
} immediate_type_e;

`endif // IMMEDIATE_TYPES_SVH


--- File: rtl/common/alu_defines.svh ---
// rtl/common/alu_defines.svh
`ifndef ALU_DEFINES_SVH
`define ALU_DEFINES_SVH

`define ALU_CONTROL_WIDTH 4 // Needs 4 bits for ~10 operations

// Unified ALU Control Signals
// R-Type / I-Type Arithmetic
`define ALU_OP_ADD  4'b0000 // Addition
`define ALU_OP_SUB  4'b0001 // Subtraction
`define ALU_OP_SLL  4'b0010 // Shift Left Logical
`define ALU_OP_SLT  4'b0011 // Set Less Than (Signed)
`define ALU_OP_SLTU 4'b0100 // Set Less Than (Unsigned)
`define ALU_OP_XOR  4'b0101 // XOR
`define ALU_OP_SRL  4'b0110 // Shift Right Logical
`define ALU_OP_SRA  4'b0111 // Shift Right Arithmetic
`define ALU_OP_OR   4'b1000 // OR
`define ALU_OP_AND  4'b1001 // AND

// Potentially other operations for specific instructions if needed, e.g., pass Operand B
// `define ALU_OP_PASS_B 4'b1010 // Pass operand_b directly (e.g., for LUI if srcA is 0)
// For LUI, it's rd = imm. If ALU is used, srcA=0, srcB=imm, op=ADD. So ALU_OP_ADD works.
// For AUIPC, it's rd = pc + imm. srcA=PC, srcB=imm, op=ADD. So ALU_OP_ADD works.

`endif // ALU_DEFINES_SVH


--- File: rtl/core/control_unit.sv ---
// rtl/core/control_unit.sv
`include "common/defines.svh"
`include "common/alu_defines.svh"
`include "common/immediate_types.svh"
`include "common/riscv_opcodes.svh"
`include "common/control_signals_defines.svh" // New include

module control_unit (
    // Inputs from instruction
    input  logic [6:0] op,
    input  logic [2:0] funct3,
    input  logic       funct7_5,

    // Outputs: Control signals
    output logic       reg_write_d_o,
    output logic [1:0] result_src_d_o,
    output logic       mem_write_d_o,
    output logic       jump_d_o,
    output logic       branch_d_o,
    output logic       alu_src_d_o,      // Selects ALU operand B (Reg vs Imm)
    output logic [`ALU_CONTROL_WIDTH-1:0] alu_control_d_o,
    output immediate_type_e imm_type_d_o,
    output logic [2:0] funct3_d_o,             // Pass funct3 for branch logic in EX & mem access type in MEM
    output alu_a_src_sel_e op_a_sel_d_o,        // Selects ALU operand A source
    output pc_target_src_sel_e pc_target_src_sel_d_o // Selects PC target source for EX
);

    // Pass funct3 directly as it's needed in later stages
    assign funct3_d_o = funct3;

    always_comb begin
        // Initialize signals to a known "safe" or default state for each instruction type
        reg_write_d_o   = 1'b0;
        result_src_d_o  = 2'b00; // Default: Result from ALU
        mem_write_d_o   = 1'b0;
        jump_d_o        = 1'b0;
        branch_d_o      = 1'b0;
        alu_src_d_o     = 1'b0; // Default: ALU Operand B from Register File (rs2)
        alu_control_d_o = `ALU_OP_ADD; // Default ALU operation
        imm_type_d_o    = IMM_TYPE_NONE;
        op_a_sel_d_o    = ALU_A_SRC_RS1; // Default
        pc_target_src_sel_d_o = PC_TARGET_SRC_PC_PLUS_IMM; // Default

        case (op)
            `OPCODE_LUI: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b1; // Imm for OpB
                imm_type_d_o    = IMM_TYPE_U;
                op_a_sel_d_o    = ALU_A_SRC_ZERO; // ALU OpA = 0
                alu_control_d_o = `ALU_OP_ADD;    // ALU = 0 + Imm
                result_src_d_o  = 2'b00;
            end
            `OPCODE_AUIPC: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b1; // Imm for OpB
                imm_type_d_o    = IMM_TYPE_U;
                op_a_sel_d_o    = ALU_A_SRC_PC;   // ALU OpA = PC
                alu_control_d_o = `ALU_OP_ADD;    // ALU = PC + Imm
                result_src_d_o  = 2'b00;
            end
            `OPCODE_JAL: begin
                reg_write_d_o   = 1'b1;
                jump_d_o        = 1'b1;
                imm_type_d_o    = IMM_TYPE_J;
                result_src_d_o  = 2'b10;      // rd = PC+4
                pc_target_src_sel_d_o = PC_TARGET_SRC_PC_PLUS_IMM; // Target = PC + ImmJ
                // ALU might be idle or used by a separate adder for PC+Imm.
                // To keep ALU control consistent if it *were* used for target:
                op_a_sel_d_o    = ALU_A_SRC_PC; // If ALU calculated PC+ImmJ
                alu_src_d_o     = 1'b1;
                alu_control_d_o = `ALU_OP_ADD;
            end
            `OPCODE_JALR: begin
                reg_write_d_o   = 1'b1;
                jump_d_o        = 1'b1;
                alu_src_d_o     = 1'b1; // Imm for OpB
                imm_type_d_o    = IMM_TYPE_I;
                op_a_sel_d_o    = ALU_A_SRC_RS1;  // ALU OpA = RS1
                alu_control_d_o = `ALU_OP_ADD;    // ALU = RS1 + Imm (for target calculation)
                result_src_d_o  = 2'b10;      // rd = PC+4
                pc_target_src_sel_d_o = PC_TARGET_SRC_ALU_JALR; // Target from ALU result & ~1
            end
            `OPCODE_BRANCH: begin
                branch_d_o      = 1'b1;
                alu_src_d_o     = 1'b0; // OpB = RS2 for comparison
                op_a_sel_d_o    = ALU_A_SRC_RS1; // OpA = RS1 for comparison
                imm_type_d_o    = IMM_TYPE_B;    // For PC + ImmB target calculation
                reg_write_d_o   = 1'b0;
                pc_target_src_sel_d_o = PC_TARGET_SRC_PC_PLUS_IMM; // Target is PC+ImmB
                case (funct3)
                    `FUNCT3_BEQ:  alu_control_d_o = `ALU_OP_SUB;
                    `FUNCT3_BNE:  alu_control_d_o = `ALU_OP_SUB;
                    `FUNCT3_BLT:  alu_control_d_o = `ALU_OP_SLT;
                    `FUNCT3_BGE:  alu_control_d_o = `ALU_OP_SLT;
                    `FUNCT3_BLTU: alu_control_d_o = `ALU_OP_SLTU;
                    `FUNCT3_BGEU: alu_control_d_o = `ALU_OP_SLTU;
                    default:      alu_control_d_o = `ALU_OP_ADD; // Or some invalid op
                endcase
            end
            `OPCODE_LOAD: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b1; // Imm for OpB (offset)
                imm_type_d_o    = IMM_TYPE_I;
                op_a_sel_d_o    = ALU_A_SRC_RS1;  // OpA = RS1 (base address)
                alu_control_d_o = `ALU_OP_ADD;    // ALU = RS1 + offset (address calculation)
                result_src_d_o  = 2'b01;      // Result from Memory
                mem_write_d_o   = 1'b0;
            end
            `OPCODE_STORE: begin
                alu_src_d_o     = 1'b1; // Imm for OpB (offset)
                imm_type_d_o    = IMM_TYPE_S;
                op_a_sel_d_o    = ALU_A_SRC_RS1;  // OpA = RS1 (base address)
                alu_control_d_o = `ALU_OP_ADD;    // ALU = RS1 + offset (address calculation)
                mem_write_d_o   = 1'b1;
                reg_write_d_o   = 1'b0;
            end
            `OPCODE_OP_IMM: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b1; // Imm for OpB
                imm_type_d_o    = (funct3 == `FUNCT3_SLLI || funct3 == `FUNCT3_SRLI_SRAI) ? IMM_TYPE_ISHIFT : IMM_TYPE_I;
                op_a_sel_d_o    = ALU_A_SRC_RS1;
                result_src_d_o  = 2'b00;
                case (funct3)
                    `FUNCT3_ADDI:  alu_control_d_o = `ALU_OP_ADD;
                    `FUNCT3_SLTI:  alu_control_d_o = `ALU_OP_SLT;
                    `FUNCT3_SLTIU: alu_control_d_o = `ALU_OP_SLTU;
                    `FUNCT3_XORI:  alu_control_d_o = `ALU_OP_XOR;
                    `FUNCT3_ORI:   alu_control_d_o = `ALU_OP_OR;
                    `FUNCT3_ANDI:  alu_control_d_o = `ALU_OP_AND;
                    `FUNCT3_SLLI:  alu_control_d_o = `ALU_OP_SLL;
                    `FUNCT3_SRLI_SRAI: begin
                        if (funct7_5 == `FUNCT7_5_SUB_ALT) alu_control_d_o = `ALU_OP_SRA;
                        else                               alu_control_d_o = `ALU_OP_SRL;
                    end
                    default:       alu_control_d_o = `ALU_OP_ADD;
                endcase
            end
            `OPCODE_OP: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b0; // OpB = RS2
                op_a_sel_d_o    = ALU_A_SRC_RS1; // OpA = RS1
                imm_type_d_o    = IMM_TYPE_NONE;
                result_src_d_o  = 2'b00;
                case (funct3)
                    `FUNCT3_ADD_SUB: begin
                        if (funct7_5 == `FUNCT7_5_SUB_ALT) alu_control_d_o = `ALU_OP_SUB;
                        else                               alu_control_d_o = `ALU_OP_ADD;
                    end
                    `FUNCT3_SLL:   alu_control_d_o = `ALU_OP_SLL;
                    `FUNCT3_SLT:   alu_control_d_o = `ALU_OP_SLT;
                    `FUNCT3_SLTU:  alu_control_d_o = `ALU_OP_SLTU;
                    `FUNCT3_XOR:   alu_control_d_o = `ALU_OP_XOR;
                    `FUNCT3_SRL_SRA: begin
                        if (funct7_5 == `FUNCT7_5_SUB_ALT) alu_control_d_o = `ALU_OP_SRA;
                        else                               alu_control_d_o = `ALU_OP_SRL;
                    end
                    `FUNCT3_OR:    alu_control_d_o = `ALU_OP_OR;
                    `FUNCT3_AND:   alu_control_d_o = `ALU_OP_AND;
                    default:       alu_control_d_o = `ALU_OP_ADD;
                endcase
            end
            default: begin // NOP / Unknown
                // Default assignments from above cover this
            end
        endcase
    end
endmodule


--- File: rtl/core/ex_mem_register ---
// rtl/core/ex_mem_register.sv
`include "common/defines.svh"
// `include "common/alu_defines.svh" // Not strictly needed here

module ex_mem_register (
    input  logic clk,
    input  logic rst_n,

    // Inputs from Execute Stage
    input  logic       reg_write_e_i,
    input  logic [1:0] result_src_e_i,
    input  logic       mem_write_e_i,
    input  logic [`DATA_WIDTH-1:0] alu_result_e_i,
    input  logic [`DATA_WIDTH-1:0] rs2_data_e_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_e_i,
    input  logic [`DATA_WIDTH-1:0] pc_plus_4_e_i,
// change start
    input  logic [2:0] funct3_e_i,         // Input for pipelined funct3
// change end

    // Outputs to Memory Stage
    output logic       reg_write_m_o,
    output logic [1:0] result_src_m_o,
    output logic       mem_write_m_o,
    output logic [`DATA_WIDTH-1:0] alu_result_m_o,
    output logic [`DATA_WIDTH-1:0] rs2_data_m_o,
    output logic [`REG_ADDR_WIDTH-1:0] rd_addr_m_o,
    output logic [`DATA_WIDTH-1:0] pc_plus_4_m_o,
// change start
    output logic [2:0] funct3_m_o          // Output for pipelined funct3
// change end
);

    localparam CTL_NOP_REG_WRITE  = 1'b0;
    localparam CTL_NOP_MEM_WRITE  = 1'b0;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            reg_write_m_o    <= CTL_NOP_REG_WRITE;
            result_src_m_o   <= 2'b00;
            mem_write_m_o    <= CTL_NOP_MEM_WRITE;
            alu_result_m_o   <= {`DATA_WIDTH{1'b0}};
            rs2_data_m_o     <= {`DATA_WIDTH{1'b0}};
            rd_addr_m_o      <= {`REG_ADDR_WIDTH{1'b0}};
            pc_plus_4_m_o    <= {`DATA_WIDTH{1'b0}};
// change start
            funct3_m_o       <= 3'b000;
// change end
        end else begin
            reg_write_m_o    <= reg_write_e_i;
            result_src_m_o   <= result_src_e_i;
            mem_write_m_o    <= mem_write_e_i;
            alu_result_m_o   <= alu_result_e_i;
            rs2_data_m_o     <= rs2_data_e_i;
            rd_addr_m_o      <= rd_addr_e_i;
            pc_plus_4_m_o    <= pc_plus_4_e_i;
// change start
            funct3_m_o       <= funct3_e_i;
// change end
        end
    end
endmodule


--- File: rtl/core/alu.sv ---
// rtl/core/alu.sv
`include "common/defines.svh"
`include "common/alu_defines.svh" // Will use new defines

module alu (
    input  logic [`DATA_WIDTH-1:0]     operand_a,
    input  logic [`DATA_WIDTH-1:0]     operand_b,
    input  logic [`ALU_CONTROL_WIDTH-1:0] alu_control, // Unified control signal
    output logic [`DATA_WIDTH-1:0]     result,
    output logic                       zero_flag
);

    logic [`DATA_WIDTH-1:0] result_comb;
    logic [5:0]             shift_amount; // For RV64, shift by lower 6 bits of operand_b

    assign shift_amount = operand_b[5:0];

    always_comb begin
        result_comb = {`DATA_WIDTH{1'bx}}; // Default to 'x'

        case (alu_control)
            `ALU_OP_ADD:  result_comb = operand_a + operand_b;
            `ALU_OP_SUB:  result_comb = operand_a - operand_b;
            `ALU_OP_SLL:  result_comb = operand_a << shift_amount;
            `ALU_OP_SLT:  result_comb = ($signed(operand_a) < $signed(operand_b)) ? {{`DATA_WIDTH-1{1'b0}}, 1'b1} : {`DATA_WIDTH{1'b0}};
            `ALU_OP_SLTU: result_comb = (operand_a < operand_b) ? {{`DATA_WIDTH-1{1'b0}}, 1'b1} : {`DATA_WIDTH{1'b0}};
            `ALU_OP_XOR:  result_comb = operand_a ^ operand_b;
            `ALU_OP_SRL:  result_comb = operand_a >> shift_amount;
            `ALU_OP_SRA:  result_comb = $signed(operand_a) >>> shift_amount;
            `ALU_OP_OR:   result_comb = operand_a | operand_b;
            `ALU_OP_AND:  result_comb = operand_a & operand_b;
            // `ALU_OP_PASS_B: result_comb = operand_b; // If we had this explicit op
            default:      result_comb = {`DATA_WIDTH{1'bx}}; // Undefined operation
        endcase
    end

    assign result = result_comb;
    assign zero_flag = (result_comb == {`DATA_WIDTH{1'b0}});

endmodule


--- File: rtl/core/memory_stage.sv ---
// rtl/core/memory.sv (Memory Stage Logic)
`include "common/defines.svh"

module memory_stage ( // Changed module name to memory_stage to avoid conflict with data_memory if in same scope
    input  logic clk,
    input  logic rst_n,

    // Inputs from EX/MEM Register
    input  logic       reg_write_m_i,
    input  logic [1:0] result_src_m_i, // 00:ALU, 01:MemRead, 10:PC+4
    input  logic       mem_write_m_i,    // Enable for data memory write
    input  logic [2:0] funct3_m_i,       // For load/store type

    input  logic [`DATA_WIDTH-1:0]     alu_result_m_i, // Address for memory or result from ALU
    input  logic [`DATA_WIDTH-1:0]     rs2_data_m_i,   // Data to store in memory
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_m_i,
    input  logic [`DATA_WIDTH-1:0]     pc_plus_4_m_i,

    // Outputs to MEM/WB Register
    output logic       reg_write_w_o,
    output logic [1:0] result_src_w_o,
    // mem_write is consumed here

    output logic [`DATA_WIDTH-1:0]     read_data_w_o,  // Data read from memory
    output logic [`DATA_WIDTH-1:0]     alu_result_w_o, // ALU result passed through
    output logic [`REG_ADDR_WIDTH-1:0] rd_addr_w_o,
    output logic [`DATA_WIDTH-1:0]     pc_plus_4_w_o
);

    logic [`DATA_WIDTH-1:0] mem_read_data_internal;

    // Data Memory Instance
    data_memory u_data_memory (
        .clk            (clk),
        .rst_n          (rst_n),
        .addr_i         (alu_result_m_i),   // Address is ALU result
        .write_data_i   (rs2_data_m_i),     // Data to write is from rs2
        .mem_write_en_i (mem_write_m_i),    // Write enable
        .funct3_i       (funct3_m_i),       // For store type (SB/SH/SW/SD) and load type
        .read_data_o    (mem_read_data_internal) // Data read
    );

    // Pass through control signals
    assign reg_write_w_o  = reg_write_m_i;
    assign result_src_w_o = result_src_m_i;

    // Pass through data
    assign read_data_w_o  = mem_read_data_internal;
    assign alu_result_w_o = alu_result_m_i;
    assign rd_addr_w_o    = rd_addr_m_i;
    assign pc_plus_4_w_o  = pc_plus_4_m_i;

endmodule


--- File: rtl/core/memory.sv ---



--- File: rtl/core/fetch.sv ---
`include "common/defines.svh"

module fetch (
    input  logic clk,
    input  logic rst_n,

    // Control signals from Hazard Unit / Execute Stage
    input  logic                       stall_f,     // Stall PC and instruction fetch
    input  logic                       pc_src_e,    // Selects PC source (PC+4 or branch/jump target)
    input  logic [`DATA_WIDTH-1:0]     pc_target_e, // Branch/jump target address from EX stage

    // Outputs to IF/ID pipeline register
    output logic [`INSTR_WIDTH-1:0]    instr_f_o,
    output logic [`DATA_WIDTH-1:0]     pc_plus_4_f_o,
    output logic [`DATA_WIDTH-1:0]     pc_f_o          // Current PC fetched
);

    logic [`DATA_WIDTH-1:0] pc_reg;
    logic [`DATA_WIDTH-1:0] pc_next;
    logic [`DATA_WIDTH-1:0] pc_plus_4_temp;

    // Instruction Memory instance
    instruction_memory i_instr_mem (
        .address     (pc_reg),
        .instruction (instr_f_o)
    );

    // Adder for PC + 4
    assign pc_plus_4_temp = pc_reg + 4;

    // MUX for next PC selection
    assign pc_next = pc_src_e ? pc_target_e : pc_plus_4_temp;

    // PC Register
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            pc_reg <= {`DATA_WIDTH{1'b0}}; // Reset PC to 0
        end else if (!stall_f) begin // If not stalled, update PC
            pc_reg <= pc_next;
        end
        // If stalled (stall_f = 1), PC holds its value
    end

    assign pc_plus_4_f_o = pc_plus_4_temp;
    assign pc_f_o        = pc_reg; // Output current PC

endmodule


--- File: rtl/core/mem_wb_register.sv ---
// rtl/core/mem_wb_register.sv
`include "common/defines.svh"

module mem_wb_register (
    input  logic clk,
    input  logic rst_n,

    // Inputs from Memory Stage
    input  logic       reg_write_m_i,    // RegWriteW on diagram
    input  logic [1:0] result_src_m_i,   // ResultSrcW on diagram

    input  logic [`DATA_WIDTH-1:0]     read_data_m_i,  // ReadDataW on diagram
    input  logic [`DATA_WIDTH-1:0]     alu_result_m_i, // ALUResultW (passed from EX/MEM to MEM/WB)
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_m_i,    // RdW on diagram
    input  logic [`DATA_WIDTH-1:0]     pc_plus_4_m_i,  // PCPlus4W on diagram

    // Outputs to Writeback Stage
    output logic       reg_write_wb_o,
    output logic [1:0] result_src_wb_o,

    output logic [`DATA_WIDTH-1:0]     read_data_wb_o,
    output logic [`DATA_WIDTH-1:0]     alu_result_wb_o,
    output logic [`REG_ADDR_WIDTH-1:0] rd_addr_wb_o,
    output logic [`DATA_WIDTH-1:0]     pc_plus_4_wb_o
);

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            reg_write_wb_o  <= 1'b0;
            result_src_wb_o <= 2'b00; // Default to ALUResult path

            read_data_wb_o  <= {`DATA_WIDTH{1'b0}};
            alu_result_wb_o <= {`DATA_WIDTH{1'b0}};
            rd_addr_wb_o    <= {`REG_ADDR_WIDTH{1'b0}};
            pc_plus_4_wb_o  <= {`DATA_WIDTH{1'b0}};
        end else begin
            // No stall/flush inputs to this register in the P&H diagram for simplicity
            // Stalls usually handled before EX, flushes clear earlier stages.
            reg_write_wb_o  <= reg_write_m_i;
            result_src_wb_o <= result_src_m_i;

            read_data_wb_o  <= read_data_m_i;
            alu_result_wb_o <= alu_result_m_i;
            rd_addr_wb_o    <= rd_addr_m_i;
            pc_plus_4_wb_o  <= pc_plus_4_m_i;
        end
    end
endmodule


--- File: rtl/core/id_ex_register.sv ---
// rtl/core/id_ex_register.sv
`include "common/defines.svh"
`include "common/alu_defines.svh"
`include "common/control_signals_defines.svh" // New include

module id_ex_register (
    input  logic clk,
    input  logic rst_n,

    input  logic stall_e,
    input  logic flush_e,

    // Inputs from Decode Stage
    input  logic       reg_write_d_i,
    input  logic [1:0] result_src_d_i,
    input  logic       mem_write_d_i,
    input  logic       jump_d_i,
    input  logic       branch_d_i,
    input  logic       alu_src_d_i,
    input  logic [`ALU_CONTROL_WIDTH-1:0] alu_control_d_i,
    input  logic [2:0] funct3_d_i,
    input  alu_a_src_sel_e op_a_sel_d_i,
    input  pc_target_src_sel_e pc_target_src_sel_d_i,

    input  logic [`DATA_WIDTH-1:0]  pc_d_i,
    input  logic [`DATA_WIDTH-1:0]  pc_plus_4_d_i,
    input  logic [`DATA_WIDTH-1:0]  rs1_data_d_i,
    input  logic [`DATA_WIDTH-1:0]  rs2_data_d_i,
    input  logic [`DATA_WIDTH-1:0]  imm_ext_d_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rs1_addr_d_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rs2_addr_d_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_d_i,

    // Outputs to Execute Stage
    output logic       reg_write_e_o,
    output logic [1:0] result_src_e_o,
    output logic       mem_write_e_o,
    output logic       jump_e_o,
    output logic       branch_e_o,
    output logic       alu_src_e_o,
    output logic [`ALU_CONTROL_WIDTH-1:0] alu_control_e_o,
    output logic [2:0] funct3_e_o,
    output alu_a_src_sel_e op_a_sel_e_o,
    output pc_target_src_sel_e pc_target_src_sel_e_o,

    output logic [`DATA_WIDTH-1:0]  pc_e_o,
    output logic [`DATA_WIDTH-1:0]  pc_plus_4_e_o,
    output logic [`DATA_WIDTH-1:0]  rs1_data_e_o,
    output logic [`DATA_WIDTH-1:0]  rs2_data_e_o,
    output logic [`DATA_WIDTH-1:0]  imm_ext_e_o,
    output logic [`REG_ADDR_WIDTH-1:0] rs1_addr_e_o,
    output logic [`REG_ADDR_WIDTH-1:0] rs2_addr_e_o,
    output logic [`REG_ADDR_WIDTH-1:0] rd_addr_e_o
);

    localparam CTL_NOP_REG_WRITE  = 1'b0;
    localparam CTL_NOP_MEM_WRITE  = 1'b0;
    localparam CTL_NOP_JUMP       = 1'b0;
    localparam CTL_NOP_BRANCH     = 1'b0;
    localparam CTL_NOP_ALU_SRC    = 1'b0;
    localparam CTL_NOP_ALU_CTRL   = `ALU_OP_ADD;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            reg_write_e_o    <= CTL_NOP_REG_WRITE;
            result_src_e_o   <= 2'b00;
            mem_write_e_o    <= CTL_NOP_MEM_WRITE;
            jump_e_o         <= CTL_NOP_JUMP;
            branch_e_o       <= CTL_NOP_BRANCH;
            alu_src_e_o      <= CTL_NOP_ALU_SRC;
            alu_control_e_o  <= CTL_NOP_ALU_CTRL;
            funct3_e_o       <= 3'b000;
            op_a_sel_e_o     <= ALU_A_SRC_RS1;
            pc_target_src_sel_e_o <= PC_TARGET_SRC_PC_PLUS_IMM;

            pc_e_o           <= {`DATA_WIDTH{1'b0}};
            pc_plus_4_e_o    <= {`DATA_WIDTH{1'b0}};
            rs1_data_e_o     <= {`DATA_WIDTH{1'b0}};
            rs2_data_e_o     <= {`DATA_WIDTH{1'b0}};
            imm_ext_e_o      <= {`DATA_WIDTH{1'b0}};
            rs1_addr_e_o     <= {`REG_ADDR_WIDTH{1'b0}};
            rs2_addr_e_o     <= {`REG_ADDR_WIDTH{1'b0}};
            rd_addr_e_o      <= {`REG_ADDR_WIDTH{1'b0}};
        end else if (flush_e) begin
            reg_write_e_o    <= CTL_NOP_REG_WRITE;
            result_src_e_o   <= 2'b00;
            mem_write_e_o    <= CTL_NOP_MEM_WRITE;
            jump_e_o         <= CTL_NOP_JUMP;
            branch_e_o       <= CTL_NOP_BRANCH;
            alu_src_e_o      <= CTL_NOP_ALU_SRC;
            alu_control_e_o  <= CTL_NOP_ALU_CTRL;
            funct3_e_o       <= 3'b000;
            op_a_sel_e_o     <= ALU_A_SRC_RS1;
            pc_target_src_sel_e_o <= PC_TARGET_SRC_PC_PLUS_IMM;

            // Data fields are also NOP'd or zeroed
            pc_e_o           <= {`DATA_WIDTH{1'b0}};
            pc_plus_4_e_o    <= {`DATA_WIDTH{1'b0}};
            rs1_data_e_o     <= {`DATA_WIDTH{1'b0}};
            rs2_data_e_o     <= {`DATA_WIDTH{1'b0}};
            imm_ext_e_o      <= {`DATA_WIDTH{1'b0}};
            rs1_addr_e_o     <= {`REG_ADDR_WIDTH{1'b0}};
            rs2_addr_e_o     <= {`REG_ADDR_WIDTH{1'b0}};
            rd_addr_e_o      <= {`REG_ADDR_WIDTH{1'b0}};
        end else if (!stall_e) begin
            reg_write_e_o    <= reg_write_d_i;
            result_src_e_o   <= result_src_d_i;
            mem_write_e_o    <= mem_write_d_i;
            jump_e_o         <= jump_d_i;
            branch_e_o       <= branch_d_i;
            alu_src_e_o      <= alu_src_d_i;
            alu_control_e_o  <= alu_control_d_i;
            funct3_e_o       <= funct3_d_i;
            op_a_sel_e_o     <= op_a_sel_d_i;
            pc_target_src_sel_e_o <= pc_target_src_sel_d_i;

            pc_e_o           <= pc_d_i;
            pc_plus_4_e_o    <= pc_plus_4_d_i;
            rs1_data_e_o     <= rs1_data_d_i;
            rs2_data_e_o     <= rs2_data_d_i;
            imm_ext_e_o      <= imm_ext_d_i;
            rs1_addr_e_o     <= rs1_addr_d_i;
            rs2_addr_e_o     <= rs2_addr_d_i;
            rd_addr_e_o      <= rd_addr_d_i;
        end
        // If stalled (stall_e = 1) and not flushed, register holds its value
    end
endmodule


--- File: rtl/core/writeback_stage.sv ---
// rtl/core/writeback.sv
`include "common/defines.svh"

module writeback_stage ( // Renamed to writeback_stage for clarity
    // Inputs from MEM/WB Register
    input  logic [1:0] result_src_wb_i,   // Selects the source for writeback data

    input  logic [`DATA_WIDTH-1:0]     read_data_wb_i,  // Data read from memory
    input  logic [`DATA_WIDTH-1:0]     alu_result_wb_i, // Result from ALU
    input  logic [`DATA_WIDTH-1:0]     pc_plus_4_wb_i,  // PC+4 for JAL/JALR

    // Outputs that go to the Register File's write port
    // (These will be connected to register_file instance in the top pipeline module)
    output logic [`DATA_WIDTH-1:0]     result_w_o       // Data to be written to register file
);

    // MUX to select the data to be written back to the register file
    always_comb begin
        case (result_src_wb_i)
            2'b00:  result_w_o = alu_result_wb_i;    // Result from ALU
            2'b01:  result_w_o = read_data_wb_i;     // Data from memory
            2'b10:  result_w_o = pc_plus_4_wb_i;     // PC+4 for JAL/JALR
            default: result_w_o = `DATA_WIDTH'('x); // Should not happen with valid control
        endcase
    end

    // The following signals are also part of the Writeback "stage" conceptually,
    // but they are passed directly from MEM/WB to the register file in the top module:
    // - reg_write_wb_i (from MEM/WB) -> to register_file.rd_write_en_wb_i
    // - rd_addr_wb_i   (from MEM/WB) -> to register_file.rd_addr_wb_i

endmodule


--- File: rtl/core/pipeline_control.sv ---
// rtl/core/pipeline_control.sv
`include "common/defines.svh"
// `include "common/control_signals_defines.svh" // Если нужны enum для Forward MUX

module pipeline_control (
    // Inputs from IF/ID Stage (register addresses read in Decode)
    input  logic [`REG_ADDR_WIDTH-1:0] rs1_addr_d_i, // Rs1D on diagram
    input  logic [`REG_ADDR_WIDTH-1:0] rs2_addr_d_i, // Rs2D on diagram

    // Inputs from ID/EX Stage (destination register and control signals from Execute)
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_e_i,    // RdE
    input  logic                       reg_write_e_i,  // RegWriteE
    input  logic [1:0]                 result_src_e_i, // ResultSrcE (bit 0 indicates load if =1 for ResultSrc=MemRead)

    // Inputs from EX/MEM Stage
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_m_i,    // RdM
    input  logic                       reg_write_m_i,  // RegWriteM

    // Inputs from MEM/WB Stage (for forwarding, as per diagram)
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_w_i,    // RdW
    input  logic                       reg_write_w_i,  // RegWriteW

    // Input from Execute Stage indicating branch taken or jump
    input  logic                       pc_src_e_i,     // PCSrcE

    // Outputs to control the pipeline
    output logic                       stall_f_o,      // Stall PC and IF/ID input
    output logic                       stall_d_o,      // Stall IF/ID register (keep current values)
    output logic                       flush_d_o,      // Clear IF/ID register
    output logic                       flush_e_o,      // Clear ID/EX register

    output logic [1:0]                 forward_a_e_o,  // Forwarding MUX select for ALU OpA
                                                     // 00: No forward (from ID/EX rs1_data)
                                                     // 01: Forward from EX/MEM (ALUResultM or PCPlus4M if JAL/JALR was in EX)
                                                     // 10: Forward from MEM/WB (ResultW)
    output logic [1:0]                 forward_b_e_o   // Forwarding MUX select for ALU OpB
);

    // Internal signals for hazards
    logic load_use_hazard;

    // ** 1. Load-Use Hazard Detection & Stall Generation **
    // Stall if instruction in Decode uses a register that an instruction in Execute
    // is loading from memory.
    // ResultSrcE[0] is 1 if ResultSrcE is MEM_READ (01) or PC_PLUS_4 (10).
    // We are interested in MEM_READ (01). So ResultSrcE == 2'b01.
    // Let's assume ResultSrcE[0] = 1 implies a memory read for simplicity as per some diagrams,
    // OR more accurately, if (ResultSrcE == 2'b01) which means data from memory.
    // The diagram uses ResultSrcE0 (bit 0 of ResultSrcE).
    // If ResultSrcE = 01 (MemRead), then ResultSrcE[0] = 1.
    // If ResultSrcE = 10 (PC+4), then ResultSrcE[0] = 0. This is not a load.
    // So we need to be more specific: result_src_e_i == 2'b01 indicates a load.
    logic is_load_in_ex;
    assign is_load_in_ex = (result_src_e_i == 2'b01); // Data from memory for writeback

    assign load_use_hazard = is_load_in_ex && reg_write_e_i && (rd_addr_e_i != 0) &&
                             ((rd_addr_e_i == rs1_addr_d_i) || (rd_addr_e_i == rs2_addr_d_i));

    assign stall_f_o = load_use_hazard;
    assign stall_d_o = load_use_hazard; // Stall IF/ID, which means ID stage also stalls.

    // ** 2. Flush Generation **
    // FlushD: Clear IF/ID register if branch taken in EX or if load-use stall bubbles EX.
    // FlushE: Clear ID/EX register if branch taken in EX or if load-use stall.
    // The diagram says: FlushD = PCSrcE
    //                 FlushE = lwStall | PCSrcE
    assign flush_d_o = pc_src_e_i;
    assign flush_e_o = load_use_hazard || pc_src_e_i;


    // ** 3. Forwarding Logic **
    // ForwardAE / ForwardBE
    // Priority:
    // 1. EX/MEM hazard (if RegWriteE and RdE matches Rs1D/Rs2D)
    // 2. MEM/WB hazard (if RegWriteM and RdM matches Rs1D/Rs2D, and not covered by EX/MEM forward)
    // 3. (Diagram also shows WB/?? hazard if RegWriteW and RdW matches)

    // Forward for Operand A (rs1_addr_d_i)
    always_comb begin
        forward_a_e_o = 2'b00; // Default

        // EX/MEM Hazard (data from instruction currently in MEM stage)
        if (reg_write_m_i && (rd_addr_m_i != 0) && (rd_addr_m_i == rs1_addr_d_i)) begin
            forward_a_e_o = 2'b10; // P&H diagram code for RdM path
        end
        // MEM/WB Hazard (data from instruction currently in WB stage)
        // This path is taken only if the EX/MEM hazard doesn't apply to this rs1.
        else if (reg_write_w_i && (rd_addr_w_i != 0) && (rd_addr_w_i == rs1_addr_d_i)) begin
            forward_a_e_o = 2'b01; // P&H diagram code for RdW path
        end
    end

    // Forward for Operand B (rs2_addr_d_i)
    always_comb begin
        forward_b_e_o = 2'b00; // Default

        if (reg_write_m_i && (rd_addr_m_i != 0) && (rd_addr_m_i == rs2_addr_d_i)) begin
            forward_b_e_o = 2'b10;
        end
        else if (reg_write_w_i && (rd_addr_w_i != 0) && (rd_addr_w_i == rs2_addr_d_i)) begin
            forward_b_e_o = 2'b01;
        end
    end

    // The diagram also shows ForwardAE/BE signals from EX stage (RdE).
    // This would be for an instruction in EX forwarding its result to a *subsequent* cycle's EX stage,
    // which is effectively what the reg_write_m_i/rd_addr_m_i path handles (as this instruction moves to MEM).
    // The diagram text "if ((Rs1E == RdM) & RegWriteM)..." means Rs1 of *current EX* vs Rd of *instr in MEM*.
    // The diagram text "if ((Rs1E == RdW) & RegWriteW)..." means Rs1 of *current EX* vs Rd of *instr in WB*.
    // There is no explicit "Rs1E == RdE" forwarding in the text snippet on the diagram for ForwardAE/BE.
    // However, if an ALU op in EX immediately needs its own result (not possible in simple pipeline)
    // or if there's a very tight loop not handled by these, more forwarding might be needed.
    // The standard P&H 5-stage forwarding covers EX/MEM->EX and MEM/WB->EX.

endmodule


--- File: rtl/core/if_id_register.sv ---
`include "common/defines.svh"

module if_id_register (
    input  logic clk,
    input  logic rst_n,

    // Control signals from Hazard Unit
    input  logic stall_d, // Stall: keeps current values
    input  logic flush_d, // Flush: clears register (outputs NOP-like values)

    // Data inputs from Fetch Stage
    input  logic [`INSTR_WIDTH-1:0] instr_f_i,
    input  logic [`DATA_WIDTH-1:0]  pc_plus_4_f_i,
    input  logic [`DATA_WIDTH-1:0]  pc_f_i,          // Current PC from Fetch

    // Data outputs to Decode Stage
    output logic [`INSTR_WIDTH-1:0] instr_id_o,
    output logic [`DATA_WIDTH-1:0]  pc_plus_4_id_o,
    output logic [`DATA_WIDTH-1:0]  pc_id_o           // Current PC to Decode
);

    // NOP instruction (addi x0, x0, 0) for RISC-V
    localparam NOP_INSTRUCTION = `INSTR_WIDTH'h00000013;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            instr_id_o     <= NOP_INSTRUCTION;
            pc_plus_4_id_o <= {`DATA_WIDTH{1'b0}};
            pc_id_o        <= {`DATA_WIDTH{1'b0}};
        end else if (flush_d) begin
            instr_id_o     <= NOP_INSTRUCTION; // Flush with NOP
            pc_plus_4_id_o <= {`DATA_WIDTH{1'b0}}; // Or a defined "safe" PC+4
            pc_id_o        <= {`DATA_WIDTH{1'b0}}; // Or a defined "safe" PC
        end else if (!stall_d) begin // If not stalled and not flushed, pass inputs
            instr_id_o     <= instr_f_i;
            pc_plus_4_id_o <= pc_plus_4_f_i;
            pc_id_o        <= pc_f_i;
        end
        // If stalled (stall_d = 1) and not flushed, register holds its value
    end

endmodule


--- File: rtl/core/data_memory.sv ---
// rtl/core/data_memory.sv
`include "common/defines.svh"
`include "common/riscv_opcodes.svh" // For FUNCT3 defines (LB, LH, LW, etc.)

module data_memory (
    input  logic clk,
    input  logic rst_n,

    input  logic [`DATA_WIDTH-1:0]     addr_i,        // Address from ALU result
    input  logic [`DATA_WIDTH-1:0]     write_data_i,  // Data from RS2 (for stores)
    input  logic                       mem_write_en_i,  // From MemWriteM control signal
    input  logic [2:0]                 funct3_i,      // To determine load/store type (size and sign)

    output logic [`DATA_WIDTH-1:0]     read_data_o    // Data read from memory (for loads)
);

    // Parameter for memory size (e.g., 2^10 = 1024 words of 64-bit)
    // Addresses are byte addresses.
    localparam MEM_ADDR_BITS = 10; // For 1KB of byte-addressable memory (2^10 bytes)
    localparam MEM_SIZE_BYTES = 1 << MEM_ADDR_BITS;
    localparam MEM_SIZE_WORDS = MEM_SIZE_BYTES / (`DATA_WIDTH/8);

    // Byte-addressable memory array. Each element is a byte.
    logic [7:0] mem [MEM_SIZE_BYTES-1:0];
    logic [`DATA_WIDTH-1:0] aligned_word_read;
    logic [`DATA_WIDTH-1:0] temp_read_data;

    // For faster simulation, Verilator might prefer word-oriented memory if operations are word-aligned
    // but byte-addressable is more general for LB/SB etc.

    // Read logic (combinational read based on address)
    // Handles different load types based on funct3
    logic [`DATA_WIDTH-1:0] read_data_aligned;
    always_comb begin
        // Default to 'x' or 0 if address is out of bounds (not explicitly handled here for simplicity)
        read_data_aligned = `DATA_WIDTH'('0);
        if (addr_i < MEM_SIZE_BYTES) begin
            // Read a full 64-bit word aligned to 8 bytes for simplicity first
            // This assumes addr_i is mostly aligned for LW/LD. Unaligned access is complex.
            // For byte/half access, we need to pick correct bytes from the word.
            // Let's read the 8 bytes starting at the (potentially unaligned) address.
            // This is a simplification; real unaligned access is more involved.
            // We'll handle alignment and byte picking for loads.
            // For simplicity, assume addr_i is aligned for word/double-word access.
            // For byte/half, addr_i can be unaligned within the word.

            // Construct the 64-bit value from individual bytes
            // This handles potential unaligned reads across word boundaries if MEM_SIZE_BYTES is large enough
            // and if addr_i + 7 does not exceed MEM_SIZE_BYTES-1.
            // For simplicity, let's assume we read an aligned 64-bit word first, then extract.
            logic [`DATA_WIDTH-1:0] fetched_word;
            logic [2:0] byte_offset_in_word = addr_i[2:0]; // Lower 3 bits for byte offset within a 64-bit word
            logic [MEM_ADDR_BITS-1:3] word_addr_idx;

            // Read the 8 bytes that form the 64-bit chunk containing addr_i
            // This is still a simplification, proper unaligned access over physical memory is hard
            for (int i = 0; i < (`DATA_WIDTH/8); i++) begin
                if ((addr_i + i) < MEM_SIZE_BYTES) begin
                    fetched_word[i*8 +: 8] = mem[addr_i + i];
                end else begin
                    fetched_word[i*8 +: 8] = 8'h00; // Out of bounds byte
                end
            end
            // The above loop is not quite right for constructing the word based on addr_i alignment
            // Let's re-think: fetch the aligned word, then select based on offset and funct3.
            temp_read_data = `DATA_WIDTH'('x);
            word_addr_idx = addr_i[MEM_ADDR_BITS-1:3]; // Index for 64-bit words if mem was word array

            // More correct byte-wise construction for an aligned read:
            for (int i = 0; i < (`DATA_WIDTH/8); i++) begin
                 // addr_i & ~7 ensures we start at an 8-byte boundary for the read
                if (( (addr_i & ~(`DATA_WIDTH/8 - 1)) + i) < MEM_SIZE_BYTES) begin
                    aligned_word_read[(i*8) +: 8] = mem[(addr_i & ~(`DATA_WIDTH/8 - 1)) + i];
                end else begin
                    aligned_word_read[(i*8) +: 8] = 8'h00;
                end
            end


            case (funct3_i)
                `FUNCT3_LB: begin // Load Byte (signed)
                    temp_read_data = {{(`DATA_WIDTH-8){aligned_word_read[byte_offset_in_word*8 + 7]}}, aligned_word_read[byte_offset_in_word*8 +: 8]};
                end
                `FUNCT3_LH: begin // Load Half-word (signed)
                    temp_read_data = {{(`DATA_WIDTH-16){aligned_word_read[byte_offset_in_word*8 + 15]}}, aligned_word_read[byte_offset_in_word*8 +: 16]};
                end
                `FUNCT3_LW: begin // Load Word (signed, 32-bit)
                    temp_read_data = {{(`DATA_WIDTH-32){aligned_word_read[byte_offset_in_word*8 + 31]}}, aligned_word_read[byte_offset_in_word*8 +: 32]};
                end
                `FUNCT3_LD: begin // Load Double-word (64-bit)
                    temp_read_data = aligned_word_read; // Assumes addr_i is 8-byte aligned for LD
                end
                `FUNCT3_LBU: begin // Load Byte (unsigned)
                    temp_read_data = {{(`DATA_WIDTH-8){1'b0}}, aligned_word_read[byte_offset_in_word*8 +: 8]};
                end
                `FUNCT3_LHU: begin // Load Half-word (unsigned)
                    temp_read_data = {{(`DATA_WIDTH-16){1'b0}}, aligned_word_read[byte_offset_in_word*8 +: 16]};
                end
                `FUNCT3_LWU: begin // Load Word (unsigned, 32-bit into 64-bit)
                    temp_read_data = {{(`DATA_WIDTH-32){1'b0}}, aligned_word_read[byte_offset_in_word*8 +: 32]};
                end
                default: temp_read_data = `DATA_WIDTH'('x); // Should not happen for load opcodes
            endcase
            read_data_aligned = temp_read_data;
        end
    end
    assign read_data_o = read_data_aligned;

    // Write logic (synchronous write on positive clock edge)
    always_ff @(posedge clk) begin
        if (mem_write_en_i && addr_i < MEM_SIZE_BYTES) begin
            case (funct3_i)
                `FUNCT3_SB: begin // Store Byte
                    if (addr_i < MEM_SIZE_BYTES) mem[addr_i] = write_data_i[7:0];
                end
                `FUNCT3_SH: begin // Store Half-word
                    if ((addr_i + 1) < MEM_SIZE_BYTES) begin // Check bounds for 2 bytes
                        mem[addr_i]   = write_data_i[7:0];
                        mem[addr_i+1] = write_data_i[15:8];
                    end
                end
                `FUNCT3_SW: begin // Store Word (32-bit)
                    if ((addr_i + 3) < MEM_SIZE_BYTES) begin // Check bounds for 4 bytes
                        for (int i = 0; i < 4; i++) begin
                            mem[addr_i+i] = write_data_i[i*8 +: 8];
                        end
                    end
                end
                `FUNCT3_SD: begin // Store Double-word (64-bit)
                    if ((addr_i + 7) < MEM_SIZE_BYTES) begin // Check bounds for 8 bytes
                        for (int i = 0; i < (`DATA_WIDTH/8); i++) begin
                            mem[addr_i+i] = write_data_i[i*8 +: 8];
                        end
                    end
                end
                default: ; // No action for other funct3 values during store
            endcase
        end
    end

    // Optional: Initialize memory on reset (for simulation)
    initial begin
        if (rst_n) begin // Wait for reset to de-assert if this initial block runs at time 0
            for (int i = 0; i < MEM_SIZE_BYTES; i++) begin
                mem[i] = 8'h00;
            end
        end
    end
    // Better reset handling:
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (int i = 0; i < MEM_SIZE_BYTES; i++) begin
                mem[i] = 8'h00;
            end
        end
    end

endmodule


--- File: rtl/core/execute.sv ---
// rtl/core/execute.sv
`include "common/defines.svh"
`include "common/alu_defines.svh"
`include "common/riscv_opcodes.svh" // For FUNCT3 defines for branches
`include "common/control_signals_defines.svh"

module execute (
    // Inputs from ID/EX Register
    input  logic       reg_write_e_i,
    input  logic [1:0] result_src_e_i,
    input  logic       mem_write_e_i,
    input  logic       jump_e_i,
    input  logic       branch_e_i,
    input  logic       alu_src_e_i,      // Selects ALU Operand B (0: Reg_Rs2, 1: Imm)
    input  logic [`ALU_CONTROL_WIDTH-1:0] alu_control_e_i,
    input  logic [2:0] funct3_e_i,                // Pipelined funct3 from instruction
    input  alu_a_src_sel_e op_a_sel_e_i,       // Selects ALU Operand A's original source (RS1, PC, Zero)
    input  pc_target_src_sel_e pc_target_src_sel_e_i, // Selects PC Target calculation method

    input  logic [`DATA_WIDTH-1:0]  pc_e_i,
    input  logic [`DATA_WIDTH-1:0]  pc_plus_4_e_i,
    input  logic [`DATA_WIDTH-1:0]  rs1_data_e_i,   // Data from RF for Rs1 (before forwarding)
    input  logic [`DATA_WIDTH-1:0]  rs2_data_e_i,   // Data from RF for Rs2 (before forwarding)
    input  logic [`DATA_WIDTH-1:0]  imm_ext_e_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_e_i,

    // Inputs for Forwarding (from later stages, routed by top pipeline module)
    input  logic [`DATA_WIDTH-1:0]     forward_data_mem_i, // Data from EX/MEM output for forwarding
    input  logic [`DATA_WIDTH-1:0]     forward_data_wb_i,  // Data from MEM/WB output for forwarding
    input  logic [1:0]                 forward_a_e_i,      // Control for OpA forwarding MUX
    input  logic [1:0]                 forward_b_e_i,      // Control for OpB forwarding MUX

    // Outputs to EX/MEM Register
    output logic       reg_write_m_o,
    output logic [1:0] result_src_m_o,
    output logic       mem_write_m_o,
    output logic [`DATA_WIDTH-1:0] alu_result_m_o,
    output logic [`DATA_WIDTH-1:0] rs2_data_m_o,    // Original rs2_data_e_i passed through (for SW/SD)
    output logic [`REG_ADDR_WIDTH-1:0] rd_addr_m_o,
    output logic [`DATA_WIDTH-1:0] pc_plus_4_m_o,
    output logic [2:0] funct3_m_o,          // Pipelined funct3 passed through for memory stage

    // Outputs to Fetch Stage/PC update logic
    output logic       pc_src_e_o,           // PCSrcE: 1 if branch/jump taken
    output logic [`DATA_WIDTH-1:0] pc_target_addr_e_o // PCTargetE: target address
);

    logic [`DATA_WIDTH-1:0] alu_operand_a_mux_out; // Output of MUX for OpA source (PC, RS1, ZERO)
    logic [`DATA_WIDTH-1:0] alu_operand_a;         // Final Operand A after forwarding
    logic [`DATA_WIDTH-1:0] alu_operand_b_mux_out; // Output of MUX for OpB source (RS2, Imm)
    logic [`DATA_WIDTH-1:0] alu_operand_b;         // Final Operand B after forwarding

    logic [`DATA_WIDTH-1:0] alu_result_internal;
    logic                   alu_zero_flag_internal;

    // ALU Operand A Source MUX (selects original source before forwarding)
    always_comb begin
        case (op_a_sel_e_i)
            ALU_A_SRC_RS1:  alu_operand_a_mux_out = rs1_data_e_i;
            ALU_A_SRC_PC:   alu_operand_a_mux_out = pc_e_i;
            ALU_A_SRC_ZERO: alu_operand_a_mux_out = `DATA_WIDTH'(0);
            default:        alu_operand_a_mux_out = rs1_data_e_i; // Default to RS1 to be safe
        endcase
    end

    // ALU Operand A Forwarding MUX (selects final value for ALU Operand A)
    always_comb begin
        case (forward_a_e_i)
            2'b00:  alu_operand_a = alu_operand_a_mux_out; // No forward
            2'b10:  alu_operand_a = forward_data_mem_i;  // Forward from EX/MEM stage output
            2'b01:  alu_operand_a = forward_data_wb_i;   // Forward from MEM/WB stage output
            default: alu_operand_a = alu_operand_a_mux_out; // Should not happen with valid forward signals
        endcase
    end

    // ALU Operand B Source MUX (selects original source: Reg_Rs2 or Immediate)
    assign alu_operand_b_mux_out = alu_src_e_i ? imm_ext_e_i : rs2_data_e_i;

    // ALU Operand B Forwarding MUX (selects final value for ALU Operand B)
    always_comb begin
        if (alu_src_e_i) begin // If Operand B is an Immediate, no forwarding is applied to it
            alu_operand_b = imm_ext_e_i;
        end else begin // Operand B is from a register (rs2_data_e_i), forwarding might apply
            case (forward_b_e_i)
                2'b00:  alu_operand_b = alu_operand_b_mux_out; // No forward (use rs2_data_e_i)
                2'b10:  alu_operand_b = forward_data_mem_i;  // Forward from EX/MEM stage output
                2'b01:  alu_operand_b = forward_data_wb_i;   // Forward from MEM/WB stage output
                default: alu_operand_b = alu_operand_b_mux_out; // Should not happen
            endcase
        end
    end

    // ALU Instance
    alu u_alu (
        .operand_a   (alu_operand_a),
        .operand_b   (alu_operand_b),
        .alu_control (alu_control_e_i),
        .result      (alu_result_internal),
        .zero_flag   (alu_zero_flag_internal)
    );

    // PC Target Address Calculation
    logic [`DATA_WIDTH-1:0] target_addr_pc_plus_imm;
    logic [`DATA_WIDTH-1:0] target_addr_alu_jalr_masked;

    assign target_addr_pc_plus_imm = pc_e_i + imm_ext_e_i; // For JAL and Branches
    // For JALR: target = (ALU result of RS1 + Imm) & ~1
    // The ALU computes RS1 + Imm when op_a_sel_e_i = ALU_A_SRC_RS1, alu_src_e_i = 1 (Imm), alu_control_e_i = ADD
    // This result (alu_result_internal) is then masked.
    assign target_addr_alu_jalr_masked = alu_result_internal & ~(`DATA_WIDTH'(1));

    assign pc_target_addr_e_o = (pc_target_src_sel_e_i == PC_TARGET_SRC_ALU_JALR) ?
                                target_addr_alu_jalr_masked : target_addr_pc_plus_imm;

    // Branch Condition Logic
    logic take_branch;
    always_comb begin
        take_branch = 1'b0;
        if (branch_e_i) begin // Only if it's a branch instruction
            case (funct3_e_i) // Use pipelined funct3 to determine branch type
                `FUNCT3_BEQ:  take_branch = alu_zero_flag_internal;  // Taken if (rs1 - rs2) == 0
                `FUNCT3_BNE:  take_branch = ~alu_zero_flag_internal; // Taken if (rs1 - rs2) != 0
                `FUNCT3_BLT:  take_branch = alu_result_internal[0];  // Taken if SLT result is 1 (rs1 < rs2 signed)
                `FUNCT3_BGE:  take_branch = ~alu_result_internal[0]; // Taken if SLT result is 0 (rs1 >= rs2 signed)
                `FUNCT3_BLTU: take_branch = alu_result_internal[0];  // Taken if SLTU result is 1 (rs1 < rs2 unsigned)
                `FUNCT3_BGEU: take_branch = ~alu_result_internal[0]; // Taken if SLTU result is 0 (rs1 >= rs2 unsigned)
                default:      take_branch = 1'b0; // Should not occur for valid branch funct3
            endcase
        end
    end

    // PCSrcE signal: Controls MUX for next PC in Fetch stage
    assign pc_src_e_o = (jump_e_i) || (branch_e_i && take_branch);

    // Pass-through signals to EX/MEM Register
    assign reg_write_m_o  = reg_write_e_i;
    assign result_src_m_o = result_src_e_i;
    assign mem_write_m_o  = mem_write_e_i;
    assign alu_result_m_o = alu_result_internal; // Result of ALU operation
    assign rs2_data_m_o   = rs2_data_e_i;   // Original RS2 data (e.g., for Store instructions)
    assign rd_addr_m_o    = rd_addr_e_i;
    assign pc_plus_4_m_o  = pc_plus_4_e_i;
    assign funct3_m_o     = funct3_e_i;     // Pass funct3 for Memory stage (load/store type)

endmodule


--- File: rtl/core/decode.sv ---
// rtl/core/decode.sv
`include "common/defines.svh"
`include "common/immediate_types.svh"
`include "common/alu_defines.svh" // For ALU_CONTROL_WIDTH
`include "common/control_signals_defines.svh"

module decode (
    // Inputs from IF/ID Register
    input  logic [`INSTR_WIDTH-1:0] instr_id_i,
    input  logic [`DATA_WIDTH-1:0]  pc_id_i,
    input  logic [`DATA_WIDTH-1:0]  pc_plus_4_id_i,

    // Inputs from Writeback Stage (for register file write)
    input  logic                       rd_write_en_wb_i,
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_wb_i,
    input  logic [`DATA_WIDTH-1:0]     rd_data_wb_i,

    // Clock and Reset
    input  logic clk,
    input  logic rst_n,

    // Outputs to ID/EX Register
    // Control Signals
    output logic       reg_write_d_o,
    output logic [1:0] result_src_d_o,
    output logic       mem_write_d_o,
    output logic       jump_d_o,
    output logic       branch_d_o,
    output logic       alu_src_d_o,
    output logic [`ALU_CONTROL_WIDTH-1:0] alu_control_d_o, // Unified ALU control
    output logic [2:0] funct3_d_o,
    output alu_a_src_sel_e op_a_sel_d_o,
    output pc_target_src_sel_e pc_target_src_sel_d_o,

    // Data
    output logic [`DATA_WIDTH-1:0]  pc_d_o,
    output logic [`DATA_WIDTH-1:0]  pc_plus_4_d_o,
    output logic [`DATA_WIDTH-1:0]  rs1_data_d_o,
    output logic [`DATA_WIDTH-1:0]  rs2_data_d_o,
    output logic [`DATA_WIDTH-1:0]  imm_ext_d_o,

    // Register addresses (for hazard unit)
    output logic [`REG_ADDR_WIDTH-1:0] rs1_addr_d_o,
    output logic [`REG_ADDR_WIDTH-1:0] rs2_addr_d_o,
    output logic [`REG_ADDR_WIDTH-1:0] rd_addr_d_o
);

    // Instruction fields
    logic [6:0] opcode;
    logic [`REG_ADDR_WIDTH-1:0] rs1_addr_instr;
    logic [`REG_ADDR_WIDTH-1:0] rs2_addr_instr;
    logic [`REG_ADDR_WIDTH-1:0] rd_addr_instr;
    logic [2:0] funct3;
    logic       funct7_5;

    // Intermediate signals
    immediate_type_e imm_type_sel_internal;

    // Decompose instruction
    assign opcode         = instr_id_i[6:0];
    assign rd_addr_instr  = instr_id_i[11:7];
    assign funct3         = instr_id_i[14:12];
    assign rs1_addr_instr = instr_id_i[19:15];
    assign rs2_addr_instr = instr_id_i[24:20];
    assign funct7_5       = instr_id_i[30]; // Bit 5 of funct7

    // Control Unit instance
    control_unit u_control_unit (
        .op                (opcode),
        .funct3            (funct3),
        .funct7_5          (funct7_5),

        .reg_write_d_o     (reg_write_d_o),
        .result_src_d_o    (result_src_d_o),
        .mem_write_d_o     (mem_write_d_o),
        .jump_d_o          (jump_d_o),
        .branch_d_o        (branch_d_o),
        .alu_src_d_o       (alu_src_d_o),
        .alu_control_d_o   (alu_control_d_o), // Now unified
        .imm_type_d_o      (imm_type_sel_internal),
        .funct3_d_o        (funct3_d_o), // Connect to new output from CU
        .op_a_sel_d_o      (op_a_sel_d_o),
        .pc_target_src_sel_d_o (pc_target_src_sel_d_o)
    );

    // Register File instance
    register_file u_register_file (
        .clk               (clk),
        .rst_n             (rst_n),
        .rs1_addr_i        (rs1_addr_instr),
        .rs1_data_o        (rs1_data_d_o),
        .rs2_addr_i        (rs2_addr_instr),
        .rs2_data_o        (rs2_data_d_o),
        .rd_write_en_wb_i  (rd_write_en_wb_i),
        .rd_addr_wb_i      (rd_addr_wb_i),
        .rd_data_wb_i      (rd_data_wb_i)
    );

    // Immediate Generator instance
    immediate_generator u_immediate_generator (
        .instr_i           (instr_id_i),
        .imm_type_sel_i    (imm_type_sel_internal),
        .imm_ext_o         (imm_ext_d_o)
    );

    // Pass through PC values
    assign pc_d_o        = pc_id_i;
    assign pc_plus_4_d_o = pc_plus_4_id_i;

    // Pass through register addresses for hazard detection and forwarding
    assign rs1_addr_d_o  = rs1_addr_instr;
    assign rs2_addr_d_o  = rs2_addr_instr;
    assign rd_addr_d_o   = rd_addr_instr;

endmodule


--- File: rtl/core/immediate_generator.sv ---
// rtl/core/immediate_generator.sv
`include "common/defines.svh"
`include "common/immediate_types.svh"

module immediate_generator (
    input  logic [`INSTR_WIDTH-1:0] instr_i,
    input  immediate_type_e         imm_type_sel_i, // Selects the type of immediate to generate
    output logic [`DATA_WIDTH-1:0]  imm_ext_o      // Sign-extended immediate value
);

    logic [`DATA_WIDTH-1:0] imm_i_type;
    logic [`DATA_WIDTH-1:0] imm_s_type;
    logic [`DATA_WIDTH-1:0] imm_b_type;
    logic [`DATA_WIDTH-1:0] imm_u_type;
    logic [`DATA_WIDTH-1:0] imm_j_type;
    logic [`DATA_WIDTH-1:0] imm_ishift_type;

    // I-type immediate: instr[31:20] (12 bits)
    assign imm_i_type = {{(`DATA_WIDTH-12){instr_i[31]}}, instr_i[31:20]};

    // S-type immediate: instr[31:25], instr[11:7] (12 bits)
    assign imm_s_type = {{(`DATA_WIDTH-12){instr_i[31]}}, instr_i[31:25], instr_i[11:7]};

    // B-type immediate: {instr[31], instr[7], instr[30:25], instr[11:8], 1'b0} (13 bits)
    // Sign-extended from original bit 12 (instr[31]) of the conceptual 13-bit immediate.
    assign imm_b_type = {{(`DATA_WIDTH-13){instr_i[31]}}, instr_i[31], instr_i[7], instr_i[30:25], instr_i[11:8], 1'b0};

    // U-type immediate: {instr[31:12], 12'b0} (32 bits)
    // Sign-extended from bit 31 of the effective 32-bit immediate. For RV64, this means sign-extend from bit 31 of the value.
    assign imm_u_type = {{(`DATA_WIDTH-32){instr_i[31]}}, instr_i[31:12], 12'h000};

    // J-type immediate: {instr[31], instr[19:12], instr[20], instr[30:21], 1'b0} (21 bits)
    // Sign-extended from original bit 20 (instr[31]) of the conceptual 21-bit immediate.
    assign imm_j_type = {{(`DATA_WIDTH-21){instr_i[31]}}, instr_i[31], instr_i[19:12], instr_i[20], instr_i[30:21], 1'b0};
    assign imm_ishift_type = `DATA_WIDTH'(instr_i[25:20]);

    always_comb begin
        case (imm_type_sel_i)
            IMM_TYPE_I:    imm_ext_o = imm_i_type;
            IMM_TYPE_S:    imm_ext_o = imm_s_type;
            IMM_TYPE_B:    imm_ext_o = imm_b_type;
            IMM_TYPE_U:    imm_ext_o = imm_u_type;
            IMM_TYPE_J:    imm_ext_o = imm_j_type;
            IMM_TYPE_ISHIFT: imm_ext_o = imm_ishift_type;
            IMM_TYPE_NONE: imm_ext_o = `DATA_WIDTH'(0); // Or 'x if preferred for non-existent immediates
            default:       imm_ext_o = `DATA_WIDTH'('x); // Should not happen with valid enum
        endcase
    end

endmodule


--- File: rtl/core/register_file.sv ---
// rtl/core/register_file.sv
`include "common/defines.svh"

module register_file (
    input  logic clk,
    input  logic rst_n,

    // Read Port 1
    input  logic [`REG_ADDR_WIDTH-1:0] rs1_addr_i,
    output logic [`DATA_WIDTH-1:0]     rs1_data_o, // Will become registered output

    // Read Port 2
    input  logic [`REG_ADDR_WIDTH-1:0] rs2_addr_i,
    output logic [`DATA_WIDTH-1:0]     rs2_data_o, // Will become registered output

    // Write Port (from Writeback stage)
    input  logic                       rd_write_en_wb_i, // RegWriteW
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_wb_i,    // RdW
    input  logic [`DATA_WIDTH-1:0]     rd_data_wb_i     // ResultW
);

    // 32 registers, each DATA_WIDTH bits wide
    // reg[0] is hardwired to zero
    logic [`DATA_WIDTH-1:0] regs[31:0];

    // Synchronous write on positive clock edge
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // Initialize all registers to 0 on reset
            for (int i = 0; i < 32; i++) begin
                regs[i] <= `DATA_WIDTH'(0);
            end
        end else begin
            if (rd_write_en_wb_i && (rd_addr_wb_i != `REG_ADDR_WIDTH'(0))) begin
                regs[rd_addr_wb_i] <= rd_data_wb_i;
            end
        end
    end

    // Synchronous read on negative clock edge for rs1_data_o and rs2_data_o
    always_ff @(negedge clk or negedge rst_n) begin
        if (!rst_n) begin
            rs1_data_o <= `DATA_WIDTH'(0);
            rs2_data_o <= `DATA_WIDTH'(0);
        end else begin
            // Reading register 0 always yields 0
            rs1_data_o <= (rs1_addr_i == `REG_ADDR_WIDTH'(0)) ? `DATA_WIDTH'(0) : regs[rs1_addr_i];
            rs2_data_o <= (rs2_addr_i == `REG_ADDR_WIDTH'(0)) ? `DATA_WIDTH'(0) : regs[rs2_addr_i];
        end
    end

    // For simulation, to observe register values (not synthesizable this way usually for direct tb access)
    // Or use DPI for more robust testbench access
`ifdef VERILATOR
    // Provide a way to dump registers for Verilator testing if needed
    // This is a simplification; direct access for writing/reading from testbench
    // might be complex or require specific Verilator features like public_flat.
`endif

endmodule


--- File: rtl/core/instruction_memory.sv ---
`include "common/defines.svh"

module instruction_memory (
    input  logic [`DATA_WIDTH-1:0] address,
    output logic [`INSTR_WIDTH-1:0] instruction
);

    localparam ROM_SIZE = 256; // Number of instructions
    logic [`INSTR_WIDTH-1:0] mem[ROM_SIZE-1:0];

    // In a real scenario, this would be loaded from a file (e.g., $readmemh)
    initial begin
        for (int i = 0; i < ROM_SIZE; i++) begin
            mem[i] = 32'h00000013; // NOP
        end
        // Add a few distinct instructions for testing later
        mem[0] = 32'h00100093; // addi x1, x0, 1
        mem[1] = 32'h00200113; // addi x2, x0, 2
        // mem[2] = 32'h00008067; // jalr x0, x1, 0 (effectively a jump to x1 content)
        //                        // This is a simplification; jalr needs rs1.
        //                        // Let's use simpler instructions for now.
        mem[2] = 32'h00308193; // addi x3, x1, 3
        mem[3] = 32'h00110213; // addi x4, x2, 1
    end

    assign instruction = (address[`DATA_WIDTH-1:2] < ROM_SIZE) ?
                     mem[address[`DATA_WIDTH-1:2]] :
                     `INSTR_WIDTH'('0);

endmodule


--- File: rtl/pipeline.sv ---
// rtl/pipeline.sv
`default_nettype none
`timescale 1ns/1ps

`include "common/defines.svh"
`include "common/alu_defines.svh"
`include "common/control_signals_defines.svh"
// `include "common/immediate_types.svh" // Not directly needed at top level, submodules use it
// `include "common/riscv_opcodes.svh"  // Not directly needed at top level

module pipeline (
    input  logic clk,
    input  logic rst_n,

    // Outputs for observing/testing (optional)
    output logic [`DATA_WIDTH-1:0] current_pc_debug, // Current PC from Fetch stage
    output logic [`INSTR_WIDTH-1:0] fetched_instr_debug // Instruction fetched
);

    // Signals between Fetch and IF/ID Register
    logic [`INSTR_WIDTH-1:0]    instr_f;
    logic [`DATA_WIDTH-1:0]     pc_f;
    logic [`DATA_WIDTH-1:0]     pc_plus_4_f;

    // Signals between IF/ID Register and Decode Stage
    logic [`INSTR_WIDTH-1:0]    instr_id;
    logic [`DATA_WIDTH-1:0]     pc_id;
    logic [`DATA_WIDTH-1:0]     pc_plus_4_id;

    // Signals between Decode Stage and ID/EX Register
    logic       reg_write_d;
    logic [1:0] result_src_d;
    logic       mem_write_d;
    logic       jump_d;
    logic       branch_d;
    logic       alu_src_d;
    logic [`ALU_CONTROL_WIDTH-1:0] alu_control_d;
    logic [2:0] funct3_d;
    alu_a_src_sel_e op_a_sel_d;
    pc_target_src_sel_e pc_target_src_sel_d;
    logic [`DATA_WIDTH-1:0]  rs1_data_d;
    logic [`DATA_WIDTH-1:0]  rs2_data_d;
    logic [`DATA_WIDTH-1:0]  imm_ext_d;
    logic [`REG_ADDR_WIDTH-1:0] rs1_addr_d; // To Hazard Unit
    logic [`REG_ADDR_WIDTH-1:0] rs2_addr_d; // To Hazard Unit
    logic [`REG_ADDR_WIDTH-1:0] rd_addr_d;  // To ID/EX

    // Signals between ID/EX Register and Execute Stage
    logic       reg_write_e;
    logic [1:0] result_src_e;
    logic       mem_write_e;
    logic       jump_e;
    logic       branch_e;
    logic       alu_src_e;
    logic [`ALU_CONTROL_WIDTH-1:0] alu_control_e;
    logic [2:0] funct3_e;
    alu_a_src_sel_e op_a_sel_e;
    pc_target_src_sel_e pc_target_src_sel_e;
    logic [`DATA_WIDTH-1:0]  pc_e;
    logic [`DATA_WIDTH-1:0]  pc_plus_4_e;
    logic [`DATA_WIDTH-1:0]  rs1_data_e;
    logic [`DATA_WIDTH-1:0]  rs2_data_e;
    logic [`DATA_WIDTH-1:0]  imm_ext_e;
    logic [`REG_ADDR_WIDTH-1:0] rs1_addr_e; // From ID/EX for Hazard Unit
    logic [`REG_ADDR_WIDTH-1:0] rs2_addr_e; // From ID/EX for Hazard Unit
    logic [`REG_ADDR_WIDTH-1:0] rd_addr_e;  // To Hazard Unit & EX/MEM

    // Signals from Execute Stage (to Hazard Unit & EX/MEM Register)
    logic       pc_src_from_ex;          // Output from Execute, PCSrcE on diagram
    logic [`DATA_WIDTH-1:0] pc_target_addr_from_ex; // Output from Execute, PCTargetE on diagram

    // Signals between Execute Stage and EX/MEM Register
    logic       reg_write_m_ex_out;      // RegWriteM from Execute
    logic [1:0] result_src_m_ex_out;   // ResultSrcM from Execute
    logic       mem_write_m_ex_out;      // MemWriteM from Execute
    logic [`DATA_WIDTH-1:0] alu_result_m_ex_out; // ALUResultM from Execute
    logic [`DATA_WIDTH-1:0] rs2_data_m_ex_out;   // WriteDataM from Execute (original rs2 data)
    logic [`REG_ADDR_WIDTH-1:0] rd_addr_m_ex_out;    // RdM from Execute
    logic [`DATA_WIDTH-1:0] pc_plus_4_m_ex_out;  // PCPlus4M from Execute
    logic [2:0] funct3_m_ex_out;         // Funct3 from Execute

    // Signals between EX/MEM Register and Memory Stage
    logic       reg_write_m;
    logic [1:0] result_src_m;
    logic       mem_write_m;
    logic [`DATA_WIDTH-1:0] alu_result_m;
    logic [`DATA_WIDTH-1:0] rs2_data_m;
    logic [`REG_ADDR_WIDTH-1:0] rd_addr_m;  // To Hazard Unit & MEM/WB
    logic [`DATA_WIDTH-1:0] pc_plus_4_m;
    logic [2:0] funct3_m;

    // Signals between Memory Stage and MEM/WB Register
    logic       reg_write_w_mem_out;
    logic [1:0] result_src_w_mem_out;
    logic [`DATA_WIDTH-1:0] read_data_w_mem_out;
    logic [`DATA_WIDTH-1:0] alu_result_w_mem_out;
    logic [`REG_ADDR_WIDTH-1:0] rd_addr_w_mem_out;
    logic [`DATA_WIDTH-1:0] pc_plus_4_w_mem_out;

    // Signals between MEM/WB Register and Writeback Stage
    logic       reg_write_wb;
    logic [1:0] result_src_wb;
    logic [`DATA_WIDTH-1:0] read_data_wb;
    logic [`DATA_WIDTH-1:0] alu_result_wb;
    logic [`REG_ADDR_WIDTH-1:0] rd_addr_wb;  // To Hazard Unit
    logic [`DATA_WIDTH-1:0] pc_plus_4_wb;

    // Signal from Writeback stage to Register File
    logic [`DATA_WIDTH-1:0] result_w;      // ResultW on diagram

    // Hazard Unit Control Signals
    logic stall_f;
    logic stall_d;
    logic flush_d;
    logic flush_e;
    logic [1:0] forward_a_e;
    logic [1:0] forward_b_e;

    // Assign debug outputs
    assign current_pc_debug = pc_f;
    assign fetched_instr_debug = instr_f;

    logic [`DATA_WIDTH-1:0] data_from_mem_stage_for_fwd;
    assign data_from_mem_stage_for_fwd = (result_src_m == 2'b01) ? read_data_w_mem_out : alu_result_m;

    // Instantiate Pipeline Stages and Registers

    // FETCH STAGE
    fetch u_fetch (
        .clk            (clk),
        .rst_n          (rst_n),
        .stall_f        (stall_f),          // From Hazard Unit
        .pc_src_e       (pc_src_from_ex),   // From Execute Stage
        .pc_target_e    (pc_target_addr_from_ex), // From Execute Stage
        .instr_f_o      (instr_f),
        .pc_f_o         (pc_f),
        .pc_plus_4_f_o  (pc_plus_4_f)
    );

    // IF/ID REGISTER
    if_id_register u_if_id_register (
        .clk            (clk),
        .rst_n          (rst_n),
        .stall_d        (stall_d),          // From Hazard Unit
        .flush_d        (flush_d),          // From Hazard Unit
        .instr_f_i      (instr_f),
        .pc_f_i         (pc_f),
        .pc_plus_4_f_i  (pc_plus_4_f),
        .instr_id_o     (instr_id),
        .pc_id_o        (pc_id),
        .pc_plus_4_id_o (pc_plus_4_id)
    );

    // DECODE STAGE
    // Register file write port is connected from MEM/WB register outputs
    decode u_decode (
        .clk                (clk),
        .rst_n              (rst_n),
        .instr_id_i         (instr_id),
        .pc_id_i            (pc_id),
        .pc_plus_4_id_i     (pc_plus_4_id),
        .rd_write_en_wb_i   (reg_write_wb),     // From MEM/WB (final write enable)
        .rd_addr_wb_i       (rd_addr_wb),       // From MEM/WB (final rd address)
        .rd_data_wb_i       (result_w),         // From Writeback MUX (final data to write)
        .reg_write_d_o      (reg_write_d),
        .result_src_d_o     (result_src_d),
        .mem_write_d_o      (mem_write_d),
        .jump_d_o           (jump_d),
        .branch_d_o         (branch_d),
        .alu_src_d_o        (alu_src_d),
        .alu_control_d_o    (alu_control_d),
        .funct3_d_o         (funct3_d),
        .op_a_sel_d_o       (op_a_sel_d),
        .pc_target_src_sel_d_o (pc_target_src_sel_d),
        .pc_d_o             (pc_id),            // pc_d_o is just pc_id_i passed through
        .pc_plus_4_d_o      (pc_plus_4_id),     // pc_plus_4_d_o is just pc_plus_4_id_i passed through
        .rs1_data_d_o       (rs1_data_d),
        .rs2_data_d_o       (rs2_data_d),
        .imm_ext_d_o        (imm_ext_d),
        .rs1_addr_d_o       (rs1_addr_d),
        .rs2_addr_d_o       (rs2_addr_d),
        .rd_addr_d_o        (rd_addr_d)
    );

    // ID/EX REGISTER
    id_ex_register u_id_ex_register (
        .clk            (clk),
        .rst_n          (rst_n),
        .stall_e        (1'b0),             // stall_e not used per P&H diagram if forwarding handles all, else from HU
        .flush_e        (flush_e),          // From Hazard Unit
        .reg_write_d_i  (reg_write_d),
        .result_src_d_i (result_src_d),
        .mem_write_d_i  (mem_write_d),
        .jump_d_i       (jump_d),
        .branch_d_i     (branch_d),
        .alu_src_d_i    (alu_src_d),
        .alu_control_d_i(alu_control_d),
        .funct3_d_i     (funct3_d),
        .op_a_sel_d_i   (op_a_sel_d),
        .pc_target_src_sel_d_i (pc_target_src_sel_d),
        .pc_d_i         (pc_id),            // pc_d_i from Decode (which is pc_id)
        .pc_plus_4_d_i  (pc_plus_4_id),
        .rs1_data_d_i   (rs1_data_d),
        .rs2_data_d_i   (rs2_data_d),
        .imm_ext_d_i    (imm_ext_d),
        .rs1_addr_d_i   (rs1_addr_d),       // Pass Rs1 Addr
        .rs2_addr_d_i   (rs2_addr_d),       // Pass Rs2 Addr
        .rd_addr_d_i    (rd_addr_d),
        .reg_write_e_o  (reg_write_e),
        .result_src_e_o (result_src_e),
        .mem_write_e_o  (mem_write_e),
        .jump_e_o       (jump_e),
        .branch_e_o     (branch_e),
        .alu_src_e_o    (alu_src_e),
        .alu_control_e_o(alu_control_e),
        .funct3_e_o     (funct3_e),
        .op_a_sel_e_o   (op_a_sel_e),
        .pc_target_src_sel_e_o (pc_target_src_sel_e),
        .pc_e_o         (pc_e),
        .pc_plus_4_e_o  (pc_plus_4_e),
        .rs1_data_e_o   (rs1_data_e),
        .rs2_data_e_o   (rs2_data_e),
        .imm_ext_e_o    (imm_ext_e),
        .rs1_addr_e_o   (rs1_addr_e),
        .rs2_addr_e_o   (rs2_addr_e),
        .rd_addr_e_o    (rd_addr_e)
    );

    // EXECUTE STAGE
    execute u_execute (
        .reg_write_e_i  (reg_write_e),
        .result_src_e_i (result_src_e),
        .mem_write_e_i  (mem_write_e),
        .jump_e_i       (jump_e),
        .branch_e_i     (branch_e),
        .alu_src_e_i    (alu_src_e),
        .alu_control_e_i(alu_control_e),
        .funct3_e_i     (funct3_e),
        .op_a_sel_e_i   (op_a_sel_e),
        .pc_target_src_sel_e_i (pc_target_src_sel_e),
        .pc_e_i         (pc_e),
        .pc_plus_4_e_i  (pc_plus_4_e),
        .rs1_data_e_i   (rs1_data_e),
        .rs2_data_e_i   (rs2_data_e),
        .imm_ext_e_i    (imm_ext_e),
        .rd_addr_e_i    (rd_addr_e),
        .forward_data_mem_i (data_from_mem_stage_for_fwd),
        .forward_data_wb_i  (result_w),         // Data from WB output (ResultW)
        .forward_a_e_i  (forward_a_e),      // From Hazard Unit
        .forward_b_e_i  (forward_b_e),      // From Hazard Unit
        .reg_write_m_o  (reg_write_m_ex_out),
        .result_src_m_o (result_src_m_ex_out),
        .mem_write_m_o  (mem_write_m_ex_out),
        .alu_result_m_o (alu_result_m_ex_out),
        .rs2_data_m_o   (rs2_data_m_ex_out),
        .rd_addr_m_o    (rd_addr_m_ex_out),
        .pc_plus_4_m_o  (pc_plus_4_m_ex_out),
        .funct3_m_o     (funct3_m_ex_out),
        .pc_src_e_o     (pc_src_from_ex),
        .pc_target_addr_e_o (pc_target_addr_from_ex)
    );

    // EX/MEM REGISTER
    ex_mem_register u_ex_mem_register (
        .clk            (clk),
        .rst_n          (rst_n),
        .reg_write_e_i  (reg_write_m_ex_out),
        .result_src_e_i (result_src_m_ex_out),
        .mem_write_e_i  (mem_write_m_ex_out),
        .alu_result_e_i (alu_result_m_ex_out),
        .rs2_data_e_i   (rs2_data_m_ex_out),
        .rd_addr_e_i    (rd_addr_m_ex_out),
        .pc_plus_4_e_i  (pc_plus_4_m_ex_out),
        .funct3_e_i     (funct3_m_ex_out),
        .reg_write_m_o  (reg_write_m),
        .result_src_m_o (result_src_m),
        .mem_write_m_o  (mem_write_m),
        .alu_result_m_o (alu_result_m),
        .rs2_data_m_o   (rs2_data_m),
        .rd_addr_m_o    (rd_addr_m),
        .pc_plus_4_m_o  (pc_plus_4_m),
        .funct3_m_o     (funct3_m)
    );

    // MEMORY STAGE
    memory_stage u_memory_stage (
        .clk            (clk),
        .rst_n          (rst_n),
        .reg_write_m_i  (reg_write_m),
        .result_src_m_i (result_src_m),
        .mem_write_m_i  (mem_write_m),
        .funct3_m_i     (funct3_m),
        .alu_result_m_i (alu_result_m),
        .rs2_data_m_i   (rs2_data_m),
        .rd_addr_m_i    (rd_addr_m),
        .pc_plus_4_m_i  (pc_plus_4_m),
        .reg_write_w_o  (reg_write_w_mem_out),
        .result_src_w_o (result_src_w_mem_out),
        .read_data_w_o  (read_data_w_mem_out),
        .alu_result_w_o (alu_result_w_mem_out), // Pass ALU result through
        .rd_addr_w_o    (rd_addr_w_mem_out),
        .pc_plus_4_w_o  (pc_plus_4_w_mem_out)
    );

    // MEM/WB REGISTER
    mem_wb_register u_mem_wb_register (
        .clk            (clk),
        .rst_n          (rst_n),
        .reg_write_m_i  (reg_write_w_mem_out),
        .result_src_m_i (result_src_w_mem_out),
        .read_data_m_i  (read_data_w_mem_out),
        .alu_result_m_i (alu_result_w_mem_out),
        .rd_addr_m_i    (rd_addr_w_mem_out),
        .pc_plus_4_m_i  (pc_plus_4_w_mem_out),
        .reg_write_wb_o (reg_write_wb),
        .result_src_wb_o(result_src_wb),
        .read_data_wb_o (read_data_wb),
        .alu_result_wb_o(alu_result_wb),
        .rd_addr_wb_o   (rd_addr_wb),
        .pc_plus_4_wb_o (pc_plus_4_wb)
    );

    // WRITEBACK STAGE
    writeback_stage u_writeback_stage (
        .result_src_wb_i (result_src_wb),
        .read_data_wb_i  (read_data_wb),
        .alu_result_wb_i (alu_result_wb),
        .pc_plus_4_wb_i  (pc_plus_4_wb),
        .result_w_o      (result_w)
    );

    // HAZARD UNIT (Pipeline Control)
    pipeline_control u_pipeline_control (
        .rs1_addr_d_i   (rs1_addr_d),    // Rs1D from Decode
        .rs2_addr_d_i   (rs2_addr_d),    // Rs2D from Decode

        .rd_addr_e_i    (rd_addr_e),     // RdE from ID/EX output
        .reg_write_e_i  (reg_write_e),   // RegWriteE from ID/EX output
        .result_src_e_i (result_src_e),  // ResultSrcE from ID/EX output (for load detection)

        .rd_addr_m_i    (rd_addr_m),     // RdM from EX/MEM output
        .reg_write_m_i  (reg_write_m),   // RegWriteM from EX/MEM output

        .rd_addr_w_i    (rd_addr_wb),    // RdW from MEM/WB output
        .reg_write_w_i  (reg_write_wb),  // RegWriteW from MEM/WB output

        .pc_src_e_i     (pc_src_from_ex), // PCSrcE from Execute stage output

        .stall_f_o      (stall_f),
        .stall_d_o      (stall_d),
        .flush_d_o      (flush_d),
        .flush_e_o      (flush_e),
        .forward_a_e_o  (forward_a_e),
        .forward_b_e_o  (forward_b_e)
    );

endmodule


--- File: tests/CMakeLists.txt ---
add_custom_target(tests_full)
add_subdirectory(unit)


--- File: tests/unit/control_unit_tb.cpp ---
// tests/unit/control_unit_tb.cpp
#include "Vcontrol_unit_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <string>
#include <map> // Not strictly needed here, but useful for complex setups
#include <bitset>

// --- C++ Constants Mirroring Verilog Defines ---
// From common/alu_defines.svh
const int ALU_CONTROL_WIDTH_CPP_CU = 4; // Suffix to avoid clash if alu.cpp linked
const uint8_t ALU_OP_ADD_CU  = 0b0000;
const uint8_t ALU_OP_SUB_CU  = 0b0001;
const uint8_t ALU_OP_SLL_CU  = 0b0010;
const uint8_t ALU_OP_SLT_CU  = 0b0011;
const uint8_t ALU_OP_SLTU_CU = 0b0100;
const uint8_t ALU_OP_XOR_CU  = 0b0101;
const uint8_t ALU_OP_SRL_CU  = 0b0110;
const uint8_t ALU_OP_SRA_CU  = 0b0111;
const uint8_t ALU_OP_OR_CU   = 0b1000;
const uint8_t ALU_OP_AND_CU  = 0b1001;

// From common/immediate_types.svh
enum ImmediateTypeCppCU {
    IMM_TYPE_NONE_CU, IMM_TYPE_I_CU, IMM_TYPE_S_CU, IMM_TYPE_B_CU,
    IMM_TYPE_U_CU, IMM_TYPE_J_CU, IMM_TYPE_ISHIFT_CU
};

// From common/control_signals_defines.svh
enum AluASrcSelCppCU { ALU_A_SRC_RS1_CU, ALU_A_SRC_PC_CU, ALU_A_SRC_ZERO_CU };
enum PcTargetSrcSelCppCU { PC_TARGET_SRC_PC_PLUS_IMM_CU, PC_TARGET_SRC_ALU_JALR_CU };

// From common/riscv_opcodes.svh
// Opcodes
const uint8_t OPCODE_LUI_CU        = 0b0110111;
const uint8_t OPCODE_AUIPC_CU      = 0b0010111;
const uint8_t OPCODE_JAL_CU        = 0b1101111;
const uint8_t OPCODE_JALR_CU       = 0b1100111;
const uint8_t OPCODE_BRANCH_CU     = 0b1100011;
const uint8_t OPCODE_LOAD_CU       = 0b0000011;
const uint8_t OPCODE_STORE_CU      = 0b0100011;
const uint8_t OPCODE_OP_IMM_CU   = 0b0010011;
const uint8_t OPCODE_OP_CU         = 0b0110011;
// Funct3 (examples, add more as needed for specific tests)
const uint8_t FUNCT3_ADDI_CU       = 0b000;
const uint8_t FUNCT3_SLLI_CU       = 0b001;
const uint8_t FUNCT3_SLTI_CU       = 0b010;
const uint8_t FUNCT3_SRLI_SRAI_CU  = 0b101;
const uint8_t FUNCT3_ADD_SUB_CU    = 0b000;
const uint8_t FUNCT3_BEQ_CU        = 0b000;
const uint8_t FUNCT3_BNE_CU        = 0b001;
const uint8_t FUNCT3_BLT_CU        = 0b100;
const uint8_t FUNCT3_BGE_CU        = 0b101;
const uint8_t FUNCT3_BLTU_CU       = 0b110;
const uint8_t FUNCT3_BGEU_CU       = 0b111;
// Funct7_5
const uint8_t FUNCT7_5_SRA_ALT_CU  = 1; // For SRA/SRAI/SUB
const uint8_t FUNCT7_5_ADD_MAIN_CU = 0; // For SRL/SRLI/ADD


vluint64_t sim_time_cu = 0;

void eval_cu(Vcontrol_unit_tb* dut, VerilatedVcdC* tfp) {
    dut->eval();
    if (tfp) tfp->dump(sim_time_cu);
    // sim_time_cu++; // For combinational, advance time per test case
}

struct ControlUnitTestCase {
    std::string name;
    uint8_t     op;
    uint8_t     funct3;
    uint8_t     funct7_5; // Only 1 bit

    // Expected outputs
    bool        exp_reg_write;
    uint8_t     exp_result_src; // 2 bits
    bool        exp_mem_write;
    bool        exp_jump;
    bool        exp_branch;
    bool        exp_alu_src_b;   // Operand B: 0 for Reg, 1 for Imm
    uint8_t     exp_alu_control;
    ImmediateTypeCppCU exp_imm_type;
    // exp_funct3_d is implicitly tc.funct3
    AluASrcSelCppCU exp_op_a_sel;
    PcTargetSrcSelCppCU exp_pc_target_sel;
};

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vcontrol_unit_tb* top = new Vcontrol_unit_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_control_unit.vcd");

    std::cout << "Starting Control Unit Testbench" << std::endl;

    std::vector<ControlUnitTestCase> test_cases = {
        // LUI
        {"LUI", OPCODE_LUI_CU, 0, 0, true, 0b00, false, false, false, true, ALU_OP_ADD_CU, IMM_TYPE_U_CU, ALU_A_SRC_ZERO_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        // AUIPC
        {"AUIPC", OPCODE_AUIPC_CU, 0, 0, true, 0b00, false, false, false, true, ALU_OP_ADD_CU, IMM_TYPE_U_CU, ALU_A_SRC_PC_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        // JAL
        {"JAL", OPCODE_JAL_CU, 0, 0, true, 0b10, false, true, false, true, ALU_OP_ADD_CU, IMM_TYPE_J_CU, ALU_A_SRC_PC_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        // JALR
        {"JALR", OPCODE_JALR_CU, FUNCT3_ADDI_CU, 0, true, 0b10, false, true, false, true, ALU_OP_ADD_CU, IMM_TYPE_I_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_ALU_JALR_CU},
        // Branches (BEQ, BNE, BLT, BGE, BLTU, BGEU)
        {"BEQ", OPCODE_BRANCH_CU, FUNCT3_BEQ_CU, 0, false,0b00,false,false,true, false,ALU_OP_SUB_CU, IMM_TYPE_B_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        {"BNE", OPCODE_BRANCH_CU, FUNCT3_BNE_CU, 0, false,0b00,false,false,true, false,ALU_OP_SUB_CU, IMM_TYPE_B_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        {"BLT", OPCODE_BRANCH_CU, FUNCT3_BLT_CU, 0, false,0b00,false,false,true, false,ALU_OP_SLT_CU, IMM_TYPE_B_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        {"BGE", OPCODE_BRANCH_CU, FUNCT3_BGE_CU, 0, false,0b00,false,false,true, false,ALU_OP_SLT_CU, IMM_TYPE_B_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        {"BLTU",OPCODE_BRANCH_CU, FUNCT3_BLTU_CU,0, false,0b00,false,false,true, false,ALU_OP_SLTU_CU,IMM_TYPE_B_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        {"BGEU",OPCODE_BRANCH_CU, FUNCT3_BGEU_CU,0, false,0b00,false,false,true, false,ALU_OP_SLTU_CU,IMM_TYPE_B_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        // Load (e.g. LW, funct3=010)
        {"LOAD (LW)", OPCODE_LOAD_CU, 0b010, 0, true, 0b01, false, false, false, true, ALU_OP_ADD_CU, IMM_TYPE_I_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        // Store (e.g. SW, funct3=010)
        {"STORE (SW)", OPCODE_STORE_CU, 0b010, 0, false,0b00,true, false, false, true, ALU_OP_ADD_CU, IMM_TYPE_S_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        // OP_IMM (ADDI, SLTI, SLTIU, XORI, ORI, ANDI, SLLI, SRLI, SRAI)
        {"ADDI", OPCODE_OP_IMM_CU, FUNCT3_ADDI_CU, 0,                true,0b00,false,false,false, true, ALU_OP_ADD_CU, IMM_TYPE_I_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        {"SLLI", OPCODE_OP_IMM_CU, FUNCT3_SLLI_CU, FUNCT7_5_ADD_MAIN_CU, true,0b00,false,false,false, true, ALU_OP_SLL_CU, IMM_TYPE_ISHIFT_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        {"SRLI", OPCODE_OP_IMM_CU, FUNCT3_SRLI_SRAI_CU, FUNCT7_5_ADD_MAIN_CU,true,0b00,false,false,false, true, ALU_OP_SRL_CU, IMM_TYPE_ISHIFT_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        {"SRAI", OPCODE_OP_IMM_CU, FUNCT3_SRLI_SRAI_CU, FUNCT7_5_SRA_ALT_CU, true,0b00,false,false,false, true, ALU_OP_SRA_CU, IMM_TYPE_ISHIFT_CU, ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        // OP (ADD, SUB, SLL, SLT, SLTU, XOR, SRL, SRA, OR, AND)
        {"ADD", OPCODE_OP_CU, FUNCT3_ADD_SUB_CU, FUNCT7_5_ADD_MAIN_CU, true,0b00,false,false,false, false,ALU_OP_ADD_CU, IMM_TYPE_NONE_CU,ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        {"SUB", OPCODE_OP_CU, FUNCT3_ADD_SUB_CU, FUNCT7_5_SRA_ALT_CU,  true,0b00,false,false,false, false,ALU_OP_SUB_CU, IMM_TYPE_NONE_CU,ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        {"SRA", OPCODE_OP_CU, FUNCT3_SRLI_SRAI_CU, FUNCT7_5_SRA_ALT_CU,true,0b00,false,false,false, false,ALU_OP_SRA_CU, IMM_TYPE_NONE_CU,ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU},
        // Unknown Opcode
        {"Unknown Opcode", 0x7F, 0, 0, false,0b00,false,false,false,false,ALU_OP_ADD_CU, IMM_TYPE_NONE_CU,ALU_A_SRC_RS1_CU, PC_TARGET_SRC_PC_PLUS_IMM_CU}
    };

    int passed_count = 0;
    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name
                  << " (op=0x" << std::hex << (int)tc.op
                  << ", f3=0x" << (int)tc.funct3
                  << ", f7_5=" << (int)tc.funct7_5 << std::dec << ")" << std::endl;

        top->i_op = tc.op;
        top->i_funct3 = tc.funct3;
        top->i_funct7_5 = tc.funct7_5;

        eval_cu(top, tfp);
        sim_time_cu++;

        bool current_pass = true;
        if(top->o_reg_write_d != tc.exp_reg_write) {std::cout << "  FAIL: RegWrite. Exp=" << tc.exp_reg_write << " Got=" << (int)top->o_reg_write_d << std::endl; current_pass=false;}
        if(top->o_result_src_d != tc.exp_result_src) {std::cout << "  FAIL: ResultSrc. Exp=" << (int)tc.exp_result_src << " Got=" << (int)top->o_result_src_d << std::endl; current_pass=false;}
        if(top->o_mem_write_d != tc.exp_mem_write) {std::cout << "  FAIL: MemWrite. Exp=" << tc.exp_mem_write << " Got=" << (int)top->o_mem_write_d << std::endl; current_pass=false;}
        if(top->o_jump_d != tc.exp_jump) {std::cout << "  FAIL: Jump. Exp=" << tc.exp_jump << " Got=" << (int)top->o_jump_d << std::endl; current_pass=false;}
        if(top->o_branch_d != tc.exp_branch) {std::cout << "  FAIL: Branch. Exp=" << tc.exp_branch << " Got=" << (int)top->o_branch_d << std::endl; current_pass=false;}
        if(top->o_alu_src_d != tc.exp_alu_src_b) {std::cout << "  FAIL: AluSrcB. Exp=" << tc.exp_alu_src_b << " Got=" << (int)top->o_alu_src_d << std::endl; current_pass=false;}
        if(top->o_alu_control_d != tc.exp_alu_control) {std::cout << "  FAIL: AluControl. Exp=0b" << std::bitset<ALU_CONTROL_WIDTH_CPP_CU>(tc.exp_alu_control) << " Got=0b" << std::bitset<ALU_CONTROL_WIDTH_CPP_CU>(top->o_alu_control_d) << std::endl; current_pass=false;}
        if(top->o_imm_type_d != static_cast<uint8_t>(tc.exp_imm_type)) {std::cout << "  FAIL: ImmType. Exp=" << (int)tc.exp_imm_type << " Got=" << (int)top->o_imm_type_d << std::endl; current_pass=false;}
        if(top->o_funct3_d != tc.funct3) {std::cout << "  FAIL: Funct3Out. Exp=0b" << std::bitset<3>(tc.funct3) << " Got=0b" << std::bitset<3>(top->o_funct3_d) << std::endl; current_pass=false;} // Funct3 should pass through
        if(top->o_op_a_sel_d != static_cast<uint8_t>(tc.exp_op_a_sel)) {std::cout << "  FAIL: OpASel. Exp=" << (int)tc.exp_op_a_sel << " Got=" << (int)top->o_op_a_sel_d << std::endl; current_pass=false;}
        if(top->o_pc_target_src_sel_d != static_cast<uint8_t>(tc.exp_pc_target_sel)) {std::cout << "  FAIL: PcTargetSel. Exp=" << (int)tc.exp_pc_target_sel << " Got=" << (int)top->o_pc_target_src_sel_d << std::endl; current_pass=false;}

        if (current_pass) {
            std::cout << "  PASS" << std::endl;
            passed_count++;
        } else {
            std::cout << "  FAILED" << std::endl;
        }
    }

    std::cout << "\nControl Unit Testbench Finished. Passed " << passed_count << "/" << test_cases.size() << " tests." << std::endl;

    if (tfp) tfp->close();
    delete top;
    return (passed_count == test_cases.size()) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/instruction_memory_tb.sv ---
// tests/unit/instruction_memory_tb.sv

`include "common/defines.svh"

module instruction_memory_tb (
    // Testbench is combinational for instruction_memory inputs/outputs
    // clk/rst_n are not strictly needed by instruction_memory.sv itself for read path,
    // but Verilator testbenches often have them. We can omit for this simple module.

    input  logic [`DATA_WIDTH-1:0]     i_address,
    output logic [`INSTR_WIDTH-1:0]    o_instruction
);

    instruction_memory u_instr_mem (
        .address     (i_address),
        .instruction (o_instruction)
    );

endmodule


--- File: tests/unit/CMakeLists.txt ---
set(RTL_INCLUDE_PATH ${CMAKE_SOURCE_DIR}/rtl)

function(add_verilator_test module_name)
    set(OBJ_DIR ${CMAKE_CURRENT_BINARY_DIR}/obj_dir_${module_name})
    set(CPP_TESTBENCH_FILE ${CMAKE_CURRENT_SOURCE_DIR}/${module_name}.cpp)

    set(RTL_SOURCES "")
    foreach(rtl_file ${ARGN})
        list(APPEND RTL_SOURCES "${rtl_file}")
    endforeach()

    add_custom_target(build-unit-test-${module_name} ALL
        COMMAND ${CMAKE_COMMAND} -E make_directory ${OBJ_DIR}
        COMMAND ${PROJECT_VERILATOR_EXECUTABLE}
                -Wall --Wno-fatal --cc --exe --build --trace
                --top-module ${module_name}
                -I${RTL_INCLUDE_PATH}
                ${RTL_SOURCES}
                ${CPP_TESTBENCH_FILE}
                --Mdir "${OBJ_DIR}"
                -CFLAGS "-std=c++17 -Wall"
        DEPENDS ${RTL_SOURCES} ${CPP_TESTBENCH_FILE}
        COMMENT "Verilating and Building executable for ${module_name}"
        VERBATIM
        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    )

    add_custom_target(run-unit-test-${module_name}
        COMMAND "${OBJ_DIR}/V${module_name}"
        DEPENDS "build-unit-test-${module_name}"
        WORKING_DIRECTORY ${OBJ_DIR}
        COMMENT "Running Verilated test for ${module_name}"
        VERBATIM
    )

    if(TARGET tests_full)
        add_dependencies(tests_full run-unit-test-${module_name})
    endif()
endfunction()


#----------------------------------------------------------------------------------------------------------------------
# Base components
#----------------------------------------------------------------------------------------------------------------------

add_verilator_test(
    alu
    ${CMAKE_SOURCE_DIR}/rtl/core/alu.sv
)

add_verilator_test(
    instruction_memory_tb
    ${CMAKE_SOURCE_DIR}/rtl/core/instruction_memory.sv
    ${CMAKE_SOURCE_DIR}/tests/unit/instruction_memory_tb.sv
)

add_verilator_test(
    data_memory_tb
    ${CMAKE_SOURCE_DIR}/rtl/core/data_memory.sv
    ${CMAKE_SOURCE_DIR}/tests/unit/data_memory_tb.sv
)

add_verilator_test(
    register_file_tb
    ${CMAKE_SOURCE_DIR}/rtl/core/register_file.sv
    ${CMAKE_SOURCE_DIR}/tests/unit/register_file_tb.sv
)

add_verilator_test(
    immediate_generator_tb
    ${CMAKE_SOURCE_DIR}/rtl/core/immediate_generator.sv
    ${CMAKE_SOURCE_DIR}/tests/unit/immediate_generator_tb.sv
)


#----------------------------------------------------------------------------------------------------------------------
# Pipeline stages
#----------------------------------------------------------------------------------------------------------------------

add_verilator_test(
    control_unit_tb
    ${CMAKE_SOURCE_DIR}/rtl/core/control_unit.sv
    ${CMAKE_SOURCE_DIR}/tests/unit/control_unit_tb.sv
)

add_verilator_test(
    fetch_tb
    ${CMAKE_SOURCE_DIR}/rtl/core/fetch.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/instruction_memory.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/if_id_register.sv
    ${CMAKE_SOURCE_DIR}/tests/unit/fetch_tb.sv
)

add_verilator_test(
    decode_tb
    ${CMAKE_SOURCE_DIR}/rtl/core/decode.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/control_unit.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/register_file.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/immediate_generator.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/if_id_register.sv
    ${CMAKE_SOURCE_DIR}/tests/unit/decode_tb.sv
)

add_verilator_test(
    execute_tb # Top Verilog testbench module and .cpp file name
    # Source files needed
    ${CMAKE_SOURCE_DIR}/rtl/core/execute.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/alu.sv         # execute instantiates alu
    # common defines are included via -I${RTL_INCLUDE_PATH}
    ${CMAKE_SOURCE_DIR}/tests/unit/execute_tb.sv # The Verilog testbench wrapper
)

add_verilator_test(
    writeback_stage_tb
    ${CMAKE_SOURCE_DIR}/rtl/core/writeback_stage.sv
    ${CMAKE_SOURCE_DIR}/tests/unit/writeback_stage_tb.sv
)

add_verilator_test(
    memory_stage_tb
    ${CMAKE_SOURCE_DIR}/rtl/core/memory_stage.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/data_memory.sv
    ${CMAKE_SOURCE_DIR}/tests/unit/memory_stage_tb.sv
)

#----------------------------------------------------------------------------------------------------------------------
# Pipeline control
#----------------------------------------------------------------------------------------------------------------------

add_verilator_test(
    pipeline_control_tb
    ${CMAKE_SOURCE_DIR}/rtl/core/pipeline_control.sv
    ${CMAKE_SOURCE_DIR}/tests/unit/pipeline_control_tb.sv
)

#----------------------------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------------------------



--- File: tests/unit/data_memory_tb.sv ---
`include "common/defines.svh"

module data_memory_tb (
    input  logic clk,
    input  logic rst_n,

    // Inputs to data_memory
    input  logic [`DATA_WIDTH-1:0]     i_addr,
    input  logic [`DATA_WIDTH-1:0]     i_write_data,
    input  logic                       i_mem_write_en,
    input  logic [2:0]                 i_funct3,

    // Output from data_memory
    output logic [`DATA_WIDTH-1:0]     o_read_data
);

    data_memory u_data_mem (
        .clk            (clk),
        .rst_n          (rst_n),
        .addr_i         (i_addr),
        .write_data_i   (i_write_data),
        .mem_write_en_i (i_mem_write_en),
        .funct3_i       (i_funct3),
        .read_data_o    (o_read_data)
    );

endmodule


--- File: tests/unit/execute_tb.cpp ---
// tests/unit/execute_tb.cpp
#include "Vexecute_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <string>
#include <map>
#include <bitset>

// C++ Constants (mirroring .svh files for testbench use)

// From common/alu_defines.svh
const int ALU_CONTROL_WIDTH_EX_TB = 4; // Suffix to avoid clash if alu.cpp linked
const uint8_t ALU_OP_ADD_EX_TB  = 0b0000;
const uint8_t ALU_OP_SUB_EX_TB  = 0b0001;
const uint8_t ALU_OP_SLL_EX_TB  = 0b0010;
const uint8_t ALU_OP_SLT_EX_TB  = 0b0011;
const uint8_t ALU_OP_SLTU_EX_TB = 0b0100;
const uint8_t ALU_OP_XOR_EX_TB  = 0b0101;
const uint8_t ALU_OP_SRL_EX_TB  = 0b0110;
const uint8_t ALU_OP_SRA_EX_TB  = 0b0111;
const uint8_t ALU_OP_OR_EX_TB   = 0b1000;
const uint8_t ALU_OP_AND_EX_TB  = 0b1001;

// From common/control_signals_defines.svh
enum AluASrcSelCppExTb {
    ALU_A_SRC_RS1_EX_TB,
    ALU_A_SRC_PC_EX_TB,
    ALU_A_SRC_ZERO_EX_TB
};

enum PcTargetSrcSelCppExTb {
    PC_TARGET_SRC_PC_PLUS_IMM_EX_TB,
    PC_TARGET_SRC_ALU_JALR_EX_TB
};

// From common/riscv_opcodes.svh (funct3 codes)
// For R-Type (funct3 can vary, but for ADD/SUB it's 000)
const uint8_t FUNCT3_ADD_SUB_EX_TB = 0b000;
// For I-Type
const uint8_t FUNCT3_ADDI_EX_TB    = 0b000;
// For U-Type (LUI/AUIPC - funct3 not critical for EX logic itself, but passed)
const uint8_t FUNCT3_LUI_AUIPC_EX_TB = 0b000; // Example, often not specifically checked in EX
// For Branches
const uint8_t FUNCT3_BEQ_EX_TB  = 0b000;
const uint8_t FUNCT3_BNE_EX_TB  = 0b001;
const uint8_t FUNCT3_BLT_EX_TB  = 0b100;
const uint8_t FUNCT3_BGE_EX_TB  = 0b101;
const uint8_t FUNCT3_BLTU_EX_TB = 0b110;
const uint8_t FUNCT3_BGEU_EX_TB = 0b111;
// For JALR
const uint8_t FUNCT3_JALR_EX_TB    = 0b000;
// For Store (e.g. SW)
const uint8_t FUNCT3_SW_EX_TB      = 0b010;
// Add other specific funct3 codes if needed for detailed tests


// Forwarding MUX select codes
const uint8_t FWD_NONE_EX_TB   = 0b00;
const uint8_t FWD_MEM_WB_EX_TB = 0b01; // From MEM/WB (RdW) -> EX
const uint8_t FWD_EX_MEM_EX_TB = 0b10; // From EX/MEM (RdM) -> EX

vluint64_t sim_time_execute_tb = 0;

void eval_execute(Vexecute_tb* dut, VerilatedVcdC* tfp) {
    dut->eval();
    if (tfp) tfp->dump(sim_time_execute_tb);
}

// Test case structure
struct ExecuteTestCase {
    std::string name;
    // --- Inputs to Execute Stage (simulating outputs of ID/EX register) ---
    bool     reg_write_e_i;
    uint8_t  result_src_e_i; // 00:ALU, 01:Mem, 10:PC+4
    bool     mem_write_e_i;
    bool     jump_e_i;
    bool     branch_e_i;
    bool     alu_src_e_i;     // For ALU OpB: 0=Reg_Rs2, 1=Imm
    uint8_t  alu_control_e_i; // 4-bit ALU operation
    uint8_t  funct3_e_i;      // 3-bit funct3 (from instruction, used for branches, memory ops)
    AluASrcSelCppExTb op_a_sel_e_i;    // Selects original source for ALU OpA
    PcTargetSrcSelCppExTb pc_target_src_sel_e_i; // Selects how PC_Target is calculated

    uint64_t pc_e_i;
    uint64_t pc_plus_4_e_i;
    uint64_t rs1_data_e_i;    // Data from RF/forwarding for Rs1
    uint64_t rs2_data_e_i;    // Data from RF/forwarding for Rs2
    uint64_t imm_ext_e_i;     // Sign-extended immediate
    uint8_t  rd_addr_e_i;     // Destination register address

    // Forwarding inputs
    uint64_t forward_data_mem_i; // Data from MEM stage (EX/MEM reg output) for forwarding
    uint64_t forward_data_wb_i;  // Data from WB stage (MEM/WB reg output) for forwarding
    uint8_t  forward_a_e_i;      // Control for OpA forwarding MUX
    uint8_t  forward_b_e_i;      // Control for OpB forwarding MUX

    // --- Expected Outputs from Execute Stage ---
    // To EX/MEM Register
    bool     exp_reg_write_m;
    uint8_t  exp_result_src_m;
    bool     exp_mem_write_m;
    uint64_t exp_alu_result_m;
    uint64_t exp_rs2_data_m;   // Original rs2_data_e_i value passed through
    uint8_t  exp_rd_addr_m;
    uint64_t exp_pc_plus_4_m;
    uint8_t  exp_funct3_m;     // Pipelined funct3

    // To PC Update Logic
    bool     exp_pc_src_e;       // PCSrcE: 1 if branch/jump taken
    uint64_t exp_pc_target_addr_e; // PCTargetE: target address
};


int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vexecute_tb* top = new Vexecute_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_execute.vcd");

    std::cout << "Starting Execute Stage Testbench (Corrected)" << std::endl;
    top->rst_n = 1; // For combinational DUT, rst_n is not strictly for logic, but good for sim init
    top->clk = 0;   // Provide a clock for VCD tracing, though execute stage is combinational

    std::vector<ExecuteTestCase> test_cases = {
        // --- Test Case 1: R-Type ADD (no forwarding) ---
        {   "R-Type ADD, no fwd",
            true, 0b00, false, false, false, false, ALU_OP_ADD_EX_TB, FUNCT3_ADD_SUB_EX_TB, ALU_A_SRC_RS1_EX_TB, PC_TARGET_SRC_PC_PLUS_IMM_EX_TB,
            0x100, 0x104, 10, 20, 0xBADBEEF, 3,
            0, 0, FWD_NONE_EX_TB, FWD_NONE_EX_TB,
            true, 0b00, false, 30, 20, 3, 0x104, FUNCT3_ADD_SUB_EX_TB,
            false, 0x100 + 0xBADBEEF // pc_target_addr is pc_e_i + imm_ext_e_i by default for non-JALR target_sel
        },
        // --- Test Case 2: I-Type ADDI (no forwarding) ---
        {   "I-Type ADDI, no fwd",
            true, 0b00, false, false, false, true, ALU_OP_ADD_EX_TB, FUNCT3_ADDI_EX_TB, ALU_A_SRC_RS1_EX_TB, PC_TARGET_SRC_PC_PLUS_IMM_EX_TB,
            0x200, 0x204, 50, 0xCCC, 15, 6,
            0, 0, FWD_NONE_EX_TB, FWD_NONE_EX_TB,
            true, 0b00, false, 65, 0xCCC, 6, 0x204, FUNCT3_ADDI_EX_TB,
            false, 0x200 + 15
        },
        // --- Test Case 3: LUI (OpA=Zero, OpB=Imm) ---
        {   "LUI U-Type",
            true, 0b00, false, false, false, true, ALU_OP_ADD_EX_TB, FUNCT3_LUI_AUIPC_EX_TB, ALU_A_SRC_ZERO_EX_TB, PC_TARGET_SRC_PC_PLUS_IMM_EX_TB,
            0x300, 0x304, 0xAAA, 0xBBB, 0xFFFFFFFFABCD0000ULL, 5,
            0,0,FWD_NONE_EX_TB,FWD_NONE_EX_TB,
            true,0b00,false,0xFFFFFFFFABCD0000ULL,0xBBB,5,0x304,FUNCT3_LUI_AUIPC_EX_TB,
            false, 0x300 + 0xFFFFFFFFABCD0000ULL
        },
        // --- Test Case 4: AUIPC (OpA=PC, OpB=Imm) ---
        {   "AUIPC U-Type",
            true, 0b00, false, false, false, true, ALU_OP_ADD_EX_TB, FUNCT3_LUI_AUIPC_EX_TB, ALU_A_SRC_PC_EX_TB, PC_TARGET_SRC_PC_PLUS_IMM_EX_TB,
            0x400, 0x404, 0xAAA, 0xBBB, 0x12300000ULL, 1,
            0,0,FWD_NONE_EX_TB,FWD_NONE_EX_TB,
            true,0b00,false, 0x400 + 0x12300000ULL,0xBBB,1,0x404,FUNCT3_LUI_AUIPC_EX_TB,
            false, 0x400 + 0x12300000ULL
        },
        // --- Test Case 5: Forwarding EX/MEM -> OpA for ADD ---
        {   "R-Type ADD, FwdA from EX/MEM",
            true, 0b00, false, false, false, false, ALU_OP_ADD_EX_TB, FUNCT3_ADD_SUB_EX_TB, ALU_A_SRC_RS1_EX_TB, PC_TARGET_SRC_PC_PLUS_IMM_EX_TB,
            0x100, 0x104, 10/*old rs1_data_e_i, will be overridden by fwd*/, 20, 0, 5,
            0x55/*fwd_mem_data*/, 0x66/*fwd_wb_data, not used*/, FWD_EX_MEM_EX_TB, FWD_NONE_EX_TB,
            true, 0b00, false, 0x55 + 20, 20, 5, 0x104, FUNCT3_ADD_SUB_EX_TB,
            false, 0x100 + 0
        },
        // --- Test Case 6: Forwarding MEM/WB -> OpB for ADD (OpB is reg, not imm) ---
        {   "R-Type ADD, FwdB from MEM/WB",
            true, 0b00, false, false, false, false, ALU_OP_ADD_EX_TB, FUNCT3_ADD_SUB_EX_TB, ALU_A_SRC_RS1_EX_TB, PC_TARGET_SRC_PC_PLUS_IMM_EX_TB,
            0x100, 0x104, 10, 20/*old rs2_data_e_i, will be overridden*/, 0, 5,
            0x88/*fwd_mem_data, not used*/, 0x77/*fwd_wb_data*/, FWD_NONE_EX_TB, FWD_MEM_WB_EX_TB,
            true, 0b00, false, 10 + 0x77, 20, 5, 0x104, FUNCT3_ADD_SUB_EX_TB,
            false, 0x100 + 0
        },
        // --- Test Case 7: BEQ Taken (ALU SUB, Zero=1) ---
        {   "BEQ Branch Taken",
            false,0b00,false,false,true,false,ALU_OP_SUB_EX_TB,FUNCT3_BEQ_EX_TB,ALU_A_SRC_RS1_EX_TB,PC_TARGET_SRC_PC_PLUS_IMM_EX_TB,
            0x800,0x804,100,100,0x40/*offset*/,0,
            0,0,FWD_NONE_EX_TB,FWD_NONE_EX_TB,
            false,0b00,false,0/*ALU result 100-100=0*/,100,0,0x804,FUNCT3_BEQ_EX_TB,
            true, 0x800 + 0x40
        },
        // --- Test Case 8: BLT Not Taken (ALU SLT, Res=0) ---
        {   "BLT Not Taken",
            false,0b00,false,false,true,false,ALU_OP_SLT_EX_TB,FUNCT3_BLT_EX_TB,ALU_A_SRC_RS1_EX_TB,PC_TARGET_SRC_PC_PLUS_IMM_EX_TB,
            0x800,0x804,200,100,0x40,0, // rs1(200) not < rs2(100), so SLT res=0
            0,0,FWD_NONE_EX_TB,FWD_NONE_EX_TB,
            false,0b00,false,0/*ALU result*/,100,0,0x804,FUNCT3_BLT_EX_TB,
            false, 0x800 + 0x40
        },
        // --- Test Case 9: JALR ---
        {   "JALR Jump",
            true,0b10/*ResultSrc=PC+4*/,false,true,false,true,ALU_OP_ADD_EX_TB,FUNCT3_JALR_EX_TB,ALU_A_SRC_RS1_EX_TB,PC_TARGET_SRC_ALU_JALR_EX_TB,
            0x500,0x504,0x1000/*rs1_data*/,0xCCC/*rs2_data not used*/,0x80/*imm*/,1,
            0,0,FWD_NONE_EX_TB,FWD_NONE_EX_TB,
            true,0b10,false,0x1000+0x80,0xCCC,1,0x504,FUNCT3_JALR_EX_TB,
            true, (0x1000+0x80) & ~1ULL
        },
        // --- Test Case 10: Store instruction (SW) ---
        {   "SW (Store Word)",
            false, 0b00, true, false, false, true, ALU_OP_ADD_EX_TB, FUNCT3_SW_EX_TB, ALU_A_SRC_RS1_EX_TB, PC_TARGET_SRC_PC_PLUS_IMM_EX_TB,
            0xA00, 0xA04, 0x100/*base_addr_rs1*/, 0xDEADBEEF/*data_to_store_rs2*/, 0x8/*offset_imm*/, 0/*rd not written for SW*/,
            0, 0, FWD_NONE_EX_TB, FWD_NONE_EX_TB,
            false, 0b00, true, 0x100 + 0x8/*eff_addr*/, 0xDEADBEEF/*data_to_store*/, 0, 0xA04, FUNCT3_SW_EX_TB,
            false, 0xA00 + 0x8
        },
    };

    int passed_count = 0;
    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name << std::endl;

        // Apply inputs from test case
        top->i_reg_write_e = tc.reg_write_e_i;
        top->i_result_src_e = tc.result_src_e_i;
        top->i_mem_write_e = tc.mem_write_e_i;
        top->i_jump_e = tc.jump_e_i;
        top->i_branch_e = tc.branch_e_i;
        top->i_alu_src_e = tc.alu_src_e_i;
        top->i_alu_control_e = tc.alu_control_e_i;
        top->i_funct3_e = tc.funct3_e_i;
        top->i_op_a_sel_e = static_cast<uint8_t>(tc.op_a_sel_e_i);
        top->i_pc_target_src_sel_e = static_cast<uint8_t>(tc.pc_target_src_sel_e_i);
        top->i_pc_e = tc.pc_e_i;
        top->i_pc_plus_4_e = tc.pc_plus_4_e_i;
        top->i_rs1_data_e = tc.rs1_data_e_i;
        top->i_rs2_data_e = tc.rs2_data_e_i;
        top->i_imm_ext_e = tc.imm_ext_e_i;
        top->i_rd_addr_e = tc.rd_addr_e_i;
        top->i_forward_data_mem = tc.forward_data_mem_i;
        top->i_forward_data_wb = tc.forward_data_wb_i;
        top->i_forward_a_e = tc.forward_a_e_i;
        top->i_forward_b_e = tc.forward_b_e_i;

        eval_execute(top, tfp); // Evaluate combinational logic
        sim_time_execute_tb++;    // Increment VCD time for each test case

        bool current_pass = true;
        // Check all outputs
        if(top->o_reg_write_m != tc.exp_reg_write_m) { std::cout << "  FAIL o_reg_write_m Exp=" << tc.exp_reg_write_m << " Got=" << (int)top->o_reg_write_m << std::endl; current_pass = false; }
        if(top->o_result_src_m != tc.exp_result_src_m) { std::cout << "  FAIL o_result_src_m Exp=" << (int)tc.exp_result_src_m << " Got=" << (int)top->o_result_src_m << std::endl; current_pass = false; }
        if(top->o_mem_write_m != tc.exp_mem_write_m) { std::cout << "  FAIL o_mem_write_m Exp=" << tc.exp_mem_write_m << " Got=" << (int)top->o_mem_write_m << std::endl; current_pass = false; }
        if(top->o_alu_result_m != tc.exp_alu_result_m) { std::cout << "  FAIL o_alu_result_m Exp=0x" << std::hex << tc.exp_alu_result_m << " Got=0x" << top->o_alu_result_m << std::dec << std::endl; current_pass = false; }
        if(top->o_rs2_data_m != tc.exp_rs2_data_m) { std::cout << "  FAIL o_rs2_data_m Exp=0x" << std::hex << tc.exp_rs2_data_m << " Got=0x" << top->o_rs2_data_m << std::dec << std::endl; current_pass = false; }
        if(top->o_rd_addr_m != tc.exp_rd_addr_m) { std::cout << "  FAIL o_rd_addr_m Exp=" << (int)tc.exp_rd_addr_m << " Got=" << (int)top->o_rd_addr_m << std::endl; current_pass = false; }
        if(top->o_pc_plus_4_m != tc.exp_pc_plus_4_m) { std::cout << "  FAIL o_pc_plus_4_m Exp=0x" << std::hex << tc.exp_pc_plus_4_m << " Got=0x" << top->o_pc_plus_4_m << std::dec << std::endl; current_pass = false; }
        if(top->o_funct3_m != tc.exp_funct3_m) { std::cout << "  FAIL o_funct3_m Exp=" << (int)tc.exp_funct3_m << " Got=" << (int)top->o_funct3_m << std::endl; current_pass = false; }
        if(top->o_pc_src_e != tc.exp_pc_src_e) { std::cout << "  FAIL o_pc_src_e Exp=" << tc.exp_pc_src_e << " Got=" << (int)top->o_pc_src_e << std::endl; current_pass = false; }
        if(top->o_pc_target_addr_e != tc.exp_pc_target_addr_e) { std::cout << "  FAIL o_pc_target_addr_e Exp=0x" << std::hex << tc.exp_pc_target_addr_e << " Got=0x" << top->o_pc_target_addr_e << std::dec << std::endl; current_pass = false; }

        if (current_pass) {
            std::cout << "  PASS" << std::endl;
            passed_count++;
        } else {
            std::cout << "  FAILED" << std::endl;
        }
    }

    std::cout << "\nExecute Stage Testbench Finished. Passed " << passed_count << "/" << test_cases.size() << " tests." << std::endl;

    if (tfp) tfp->close();
    delete top;
    return (passed_count == test_cases.size()) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/writeback_stage_tb.sv ---
`include "common/defines.svh"

module writeback_stage_tb (
    // Inputs to writeback_stage
    input  logic [1:0]                 i_result_src_wb,
    input  logic [`DATA_WIDTH-1:0]     i_read_data_wb,
    input  logic [`DATA_WIDTH-1:0]     i_alu_result_wb,
    input  logic [`DATA_WIDTH-1:0]     i_pc_plus_4_wb,

    // Output from writeback_stage
    output logic [`DATA_WIDTH-1:0]     o_result_w
);

    writeback_stage u_writeback_stage (
        .result_src_wb_i (i_result_src_wb),
        .read_data_wb_i  (i_read_data_wb),
        .alu_result_wb_i (i_alu_result_wb),
        .pc_plus_4_wb_i  (i_pc_plus_4_wb),
        .result_w_o      (o_result_w)
    );

endmodule


--- File: tests/unit/alu.cpp ---
// tests/unit/alu.cpp
#include "Valu.h" // Verilator generated header for alu module
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cassert>
#include <cstdint>
#include <string>
#include <vector>
#include <bitset>

// ALU Control Opcodes (из alu_defines.svh)
const int ALU_CONTROL_WIDTH_CPP = 4;
const uint8_t ALU_OP_ADD_CPP  = 0b0000;
const uint8_t ALU_OP_SUB_CPP  = 0b0001;
const uint8_t ALU_OP_SLL_CPP  = 0b0010;
const uint8_t ALU_OP_SLT_CPP  = 0b0011;
const uint8_t ALU_OP_SLTU_CPP = 0b0100;
const uint8_t ALU_OP_XOR_CPP  = 0b0101;
const uint8_t ALU_OP_SRL_CPP  = 0b0110;
const uint8_t ALU_OP_SRA_CPP  = 0b0111;
const uint8_t ALU_OP_OR_CPP   = 0b1000;
const uint8_t ALU_OP_AND_CPP  = 0b1001;

vluint64_t sim_time = 0; // Глобальное время симуляции для VCD

double sc_time_stamp() {
    return sim_time;
}

// Измененная функция eval_alu: clk не нужен для комбинационного ALU
void eval_alu(Valu* alu_core, VerilatedVcdC* tfp) {
    alu_core->eval(); // Просто вызываем eval
    if (tfp) {
        tfp->dump(sim_time); // Дампим на текущее время симуляции
    }
}

struct AluTestCase {
    std::string name;
    uint64_t a, b;
    uint8_t alu_control_val;
    uint64_t expected_res;
    bool expected_zero;
};

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Valu* top = new Valu;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_alu.vcd");

    std::cout << "Starting Enhanced ALU Testbench (RV64)" << std::endl;

    AluTestCase tests[] = {
        // === ADD Tests ===
        {"ADD 5+10", 5, 10, ALU_OP_ADD_CPP, 15, false},
        {"ADD 0+0", 0, 0, ALU_OP_ADD_CPP, 0, true},
        {"ADD -1+1", 0xFFFFFFFFFFFFFFFFULL, 1, ALU_OP_ADD_CPP, 0, true},
        {"ADD MAX_UINT64+1", 0xFFFFFFFFFFFFFFFFULL, 1, ALU_OP_ADD_CPP, 0, true},
        {"ADD MAX_INT64+1", 0x7FFFFFFFFFFFFFFFULL, 1, ALU_OP_ADD_CPP, 0x8000000000000000ULL, false},
        {"ADD MIN_INT64-1", 0x8000000000000000ULL, 0xFFFFFFFFFFFFFFFFULL, ALU_OP_ADD_CPP, 0x7FFFFFFFFFFFFFFFULL, false},
        {"ADD large positives", 0x7000000000000000ULL, 0x0FFFFFFFFFFFFFFFULL, ALU_OP_ADD_CPP, 0x7FFFFFFFFFFFFFFFULL, false},

        // === SUB Tests ===
        {"SUB 10-5", 10, 5, ALU_OP_SUB_CPP, 5, false},
        {"SUB 5-10", 5, 10, ALU_OP_SUB_CPP, (uint64_t)-5, false},
        {"SUB 0-0", 0, 0, ALU_OP_SUB_CPP, 0, true},
        {"SUB 0-1", 0, 1, ALU_OP_SUB_CPP, (uint64_t)-1, false},
        {"SUB MIN_INT64-1", 0x8000000000000000ULL, 1, ALU_OP_SUB_CPP, 0x7FFFFFFFFFFFFFFFULL, false},
        {"SUB MAX_INT64 - MIN_INT64", 0x7FFFFFFFFFFFFFFFULL, 0x8000000000000000ULL, ALU_OP_SUB_CPP, 0xFFFFFFFFFFFFFFFFULL, false},

        // === SLL Tests ===
        {"SLL 1<<3", 0x1ULL, 3, ALU_OP_SLL_CPP, 0x8ULL, false},
        {"SLL 1<<0", 0x1ULL, 0, ALU_OP_SLL_CPP, 0x1ULL, false},
        {"SLL 1<<63", 0x1ULL, 63, ALU_OP_SLL_CPP, 0x8000000000000000ULL, false},
        {"SLL 1<<64 (shamt=0)", 0x1ULL, 64, ALU_OP_SLL_CPP, 0x1ULL, false}, // operand_b[5:0] -> shamt=0
        {"SLL 0xFF<<8", 0xFFULL, 8, ALU_OP_SLL_CPP, 0xFF00ULL, false},
        {"SLL anything by 0", 0xABCDEF1234567890ULL, 0, ALU_OP_SLL_CPP, 0xABCDEF1234567890ULL, false},

        // === SLT Tests ===
        {"SLT 5<10", 5, 10, ALU_OP_SLT_CPP, 1, false},
        {"SLT 10<5", 10, 5, ALU_OP_SLT_CPP, 0, true},
        {"SLT 5<5", 5, 5, ALU_OP_SLT_CPP, 0, true},
        {"SLT -5<2", (uint64_t)-5, 2, ALU_OP_SLT_CPP, 1, false},
        {"SLT 2<-5", 2, (uint64_t)-5, ALU_OP_SLT_CPP, 0, true},
        {"SLT -2<-5", (uint64_t)-2, (uint64_t)-5, ALU_OP_SLT_CPP, 0, true},
        {"SLT -5<-2", (uint64_t)-5, (uint64_t)-2, ALU_OP_SLT_CPP, 1, false},
        {"SLT MAX_INT64 vs MIN_INT64", 0x7FFFFFFFFFFFFFFFULL, 0x8000000000000000ULL, ALU_OP_SLT_CPP, 0, true},
        {"SLT MIN_INT64 vs MAX_INT64", 0x8000000000000000ULL, 0x7FFFFFFFFFFFFFFFULL, ALU_OP_SLT_CPP, 1, false},

        // === SLTU Tests ===
        {"SLTU 5<10", 5, 10, ALU_OP_SLTU_CPP, 1, false},
        {"SLTU 10<5", 10, 5, ALU_OP_SLTU_CPP, 0, true},
        {"SLTU 5<5", 5, 5, ALU_OP_SLTU_CPP, 0, true},
        {"SLTU (uint)-5 < 2", (uint64_t)-5, 2, ALU_OP_SLTU_CPP, 0, true}, 
        {"SLTU 2 < (uint)-5", 2, (uint64_t)-5, ALU_OP_SLTU_CPP, 1, false},
        {"SLTU MAX_UINT64 vs 0", 0xFFFFFFFFFFFFFFFFULL, 0, ALU_OP_SLTU_CPP, 0, true},
        {"SLTU 0 vs MAX_UINT64", 0, 0xFFFFFFFFFFFFFFFFULL, ALU_OP_SLTU_CPP, 1, false},

        // === XOR Tests ===
        {"XOR F0F0^0F0F", 0xF0F0F0F0F0F0F0F0ULL, 0x0F0F0F0F0F0F0F0FULL, ALU_OP_XOR_CPP, 0xFFFFFFFFFFFFFFFFULL, false},
        {"XOR A^A=0", 0x123456789ABCDEF0ULL, 0x123456789ABCDEF0ULL, ALU_OP_XOR_CPP, 0, true},
        {"XOR A^0=A", 0x123456789ABCDEF0ULL, 0, ALU_OP_XOR_CPP, 0x123456789ABCDEF0ULL, false},

        // === SRL Tests ===
        {"SRL 0x8000...>>1", 0x8000000000000000ULL, 1, ALU_OP_SRL_CPP, 0x4000000000000000ULL, false},
        {"SRL 0x0F...>>4", 0x0F00000000000000ULL, 4, ALU_OP_SRL_CPP, 0x00F0000000000000ULL, false},
        {"SRL val by 0", 0xABCDEF1234567890ULL, 0, ALU_OP_SRL_CPP, 0xABCDEF1234567890ULL, false},
        {"SRL val by 64 (shamt=0)", 0xABCDEF1234567890ULL, 64, ALU_OP_SRL_CPP, 0xABCDEF1234567890ULL, false},
        {"SRL val by 63", 0x8000000000000000ULL, 63, ALU_OP_SRL_CPP, 1, false},

        // === SRA Tests ===
        {"SRA 0x8000...>>1 (neg)", 0x8000000000000000ULL, 1, ALU_OP_SRA_CPP, 0xC000000000000000ULL, false},
        {"SRA 0x4000...>>1 (pos)", 0x4000000000000000ULL, 1, ALU_OP_SRA_CPP, 0x2000000000000000ULL, false},
        {"SRA -16>>4", 0xFFFFFFFFFFFFFFF0ULL, 4, ALU_OP_SRA_CPP, 0xFFFFFFFFFFFFFFFFULL, false}, 
        {"SRA val by 0", 0x8BCDEF1234567890ULL, 0, ALU_OP_SRA_CPP, 0x8BCDEF1234567890ULL, false},
        {"SRA val by 64 (shamt=0)", 0x8BCDEF1234567890ULL, 64, ALU_OP_SRA_CPP, 0x8BCDEF1234567890ULL, false},
        {"SRA -2 by 1", (uint64_t)-2, 1, ALU_OP_SRA_CPP, (uint64_t)-1, false}, 
        {"SRA MIN_INT64 by 63", 0x8000000000000000ULL, 63, ALU_OP_SRA_CPP, 0xFFFFFFFFFFFFFFFFULL, false},

        // === OR Tests ===
        {"OR F0F0|0F0F", 0xF0F0F0F0F0F0F0F0ULL, 0x0F0F0F0F0F0F0F0FULL, ALU_OP_OR_CPP, 0xFFFFFFFFFFFFFFFFULL, false},
        {"OR A|0=A", 0x123456789ABCDEF0ULL, 0, ALU_OP_OR_CPP, 0x123456789ABCDEF0ULL, false},
        {"OR A|A=A", 0x123456789ABCDEF0ULL, 0x123456789ABCDEF0ULL, ALU_OP_OR_CPP, 0x123456789ABCDEF0ULL, false},
        {"OR A|~A = FFs", 0x5555555555555555ULL, 0xAAAAAAAAAAAAAAAAULL, ALU_OP_OR_CPP, 0xFFFFFFFFFFFFFFFFULL, false},

        // === AND Tests ===
        {"AND F0F0&0F0F", 0xF0F0F0F0F0F0F0F0ULL, 0x0F0F0F0F0F0F0F0FULL, ALU_OP_AND_CPP, 0, true},
        {"AND A&0=0", 0x123456789ABCDEF0ULL, 0, ALU_OP_AND_CPP, 0, true},
        {"AND A&A=A", 0x123456789ABCDEF0ULL, 0x123456789ABCDEF0ULL, ALU_OP_AND_CPP, 0x123456789ABCDEF0ULL, false},
        {"AND A&~A = 0", 0x5555555555555555ULL, 0xAAAAAAAAAAAAAAAAULL, ALU_OP_AND_CPP, 0, true},
    };

    int num_tests = sizeof(tests) / sizeof(AluTestCase);
    int passed_tests = 0;

    for (int i = 0; i < num_tests; ++i) {
        AluTestCase& t = tests[i];

        top->operand_a = t.a;
        top->operand_b = t.b;
        top->alu_control = t.alu_control_val;

        eval_alu(top, tfp); // Вызываем eval один раз, т.к. модуль комбинационный
        // Для VCD инкрементируем время после каждого набора входов/выходов
        sim_time++;

        bool pass = (top->result == t.expected_res) &&
                    (top->zero_flag == t.expected_zero);

        if (pass) {
            passed_tests++;
        } else {
            std::cout << "FAIL Test: " << t.name << std::endl;
            std::cout << "  Input: A=0x" << std::hex << t.a << ", B=0x" << t.b
                      << ", ALUControl=0b" << std::bitset<ALU_CONTROL_WIDTH_CPP>(t.alu_control_val) << std::dec << std::endl;
            std::cout << "  Got  : Res=0x" << std::hex << top->result << ", Zero=" << (int)top->zero_flag << std::dec << std::endl;
            std::cout << "  Exp  : Res=0x" << std::hex << t.expected_res << ", Zero=" << (int)t.expected_zero << std::dec << std::endl;
        }
        assert(pass);
    }

    std::cout << "\nEnhanced ALU Testbench Finished. Passed " << passed_tests << "/" << num_tests << " tests." << std::endl;

    if (tfp) tfp->close();
    delete top;
    return (passed_tests == num_tests) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/pipeline_control_tb.sv ---
`include "common/defines.svh"

module pipeline_control_tb (
    // Inputs to pipeline_control
    input  logic [`REG_ADDR_WIDTH-1:0] i_rs1_addr_d,
    input  logic [`REG_ADDR_WIDTH-1:0] i_rs2_addr_d,
    input  logic [`REG_ADDR_WIDTH-1:0] i_rd_addr_e,
    input  logic                       i_reg_write_e,
    input  logic [1:0]                 i_result_src_e,
    input  logic [`REG_ADDR_WIDTH-1:0] i_rd_addr_m,
    input  logic                       i_reg_write_m,
    input  logic [`REG_ADDR_WIDTH-1:0] i_rd_addr_w,
    input  logic                       i_reg_write_w,
    input  logic                       i_pc_src_e,

    // Outputs from pipeline_control
    output logic                       o_stall_f,
    output logic                       o_stall_d,
    output logic                       o_flush_d,
    output logic                       o_flush_e,
    output logic [1:0]                 o_forward_a_e,
    output logic [1:0]                 o_forward_b_e
);

    pipeline_control u_pipeline_control (
        .rs1_addr_d_i   (i_rs1_addr_d),
        .rs2_addr_d_i   (i_rs2_addr_d),
        .rd_addr_e_i    (i_rd_addr_e),
        .reg_write_e_i  (i_reg_write_e),
        .result_src_e_i (i_result_src_e),
        .rd_addr_m_i    (i_rd_addr_m),
        .reg_write_m_i  (i_reg_write_m),
        .rd_addr_w_i    (i_rd_addr_w),
        .reg_write_w_i  (i_reg_write_w),
        .pc_src_e_i     (i_pc_src_e),
        .stall_f_o      (o_stall_f),
        .stall_d_o      (o_stall_d),
        .flush_d_o      (o_flush_d),
        .flush_e_o      (o_flush_e),
        .forward_a_e_o  (o_forward_a_e),
        .forward_b_e_o  (o_forward_b_e)
    );

endmodule


--- File: tests/unit/instruction_memory_tb.cpp ---
// tests/unit/instruction_memory_tb.cpp
#include "Vinstruction_memory_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h" // Optional: if we want VCD for this simple test

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <string>

// Ожидаемые значения из instruction_memory.sv initial block
const uint32_t DEFAULT_NOP_INSTR = 0x00000013;
const uint32_t INSTR_MEM_0 = 0x00100093; // addi x1, x0, 1
const uint32_t INSTR_MEM_1 = 0x00200113; // addi x2, x0, 2
const uint32_t INSTR_MEM_2 = 0x00308193; // addi x3, x1, 3
const uint32_t INSTR_MEM_3 = 0x00110213; // addi x4, x2, 1

const int ROM_SIZE_INSTR = 256; // Должно соответствовать ROM_SIZE в instruction_memory.sv

vluint64_t sim_time_imem = 0; // Отдельное время для этого теста

void eval_imem(Vinstruction_memory_tb* dut, VerilatedVcdC* tfp) {
    dut->eval();
    if (tfp) {
        tfp->dump(sim_time_imem);
    }
    // sim_time_imem++; // Для комбинационного теста время можно не инкрементировать на каждом eval
}

struct ImemTestCase {
    std::string name;
    uint64_t    address;
    uint32_t    expected_instruction;
    bool        expect_defined_behavior; // true if address is within ROM and behavior is defined
};

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vinstruction_memory_tb* top = new Vinstruction_memory_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_instruction_memory.vcd");

    std::cout << "Starting Instruction Memory Testbench" << std::endl;

    std::vector<ImemTestCase> test_cases = {
        {"Read Addr 0 (Instr 0)",       0x00, INSTR_MEM_0, true},
        {"Read Addr 4 (Instr 1)",       0x04, INSTR_MEM_1, true},
        {"Read Addr 8 (Instr 2)",       0x08, INSTR_MEM_2, true},
        {"Read Addr 12 (Instr 3)",      0x0C, INSTR_MEM_3, true},
        {"Read Addr 16 (Uninit, NOP)",  0x10, DEFAULT_NOP_INSTR, true},
        {"Read Addr last valid (NOP)",  (uint64_t)((ROM_SIZE_INSTR - 1) * 4), DEFAULT_NOP_INSTR, true},
        // Тесты для адресов немного за пределами инициализированных, но внутри ROM_SIZE
        {"Read Addr 20 (Uninit, NOP)",  0x14, DEFAULT_NOP_INSTR, true},
        {"Read Addr 0x3F8 (last in ROM)",0x3F8, DEFAULT_NOP_INSTR, true}, // (255*4)
        {"Read Addr 0x3FC (last in ROM)",0x3FC, DEFAULT_NOP_INSTR, true}, // (255*4) -> (256-1)*4

        // Тесты на граничные условия (за пределами ROM)
        // Поведение здесь зависит от Verilator/SystemVerilog для out-of-bounds array access.
        // Verilator может выдать предупреждение или ошибку, или вернуть 'x.
        // Мы ожидаем, что это не приведет к падению симуляции, но значение может быть неопределенным.
        // Для `logic` неинициализированные биты обычно 'x'.
        // Если instruction_memory.sv не обрабатывает out-of-bounds, то это undefined behavior.
        // Мы пометим expect_defined_behavior = false для таких случаев.
        {"Read Addr Out of Bounds High", (uint64_t)(ROM_SIZE_INSTR * 4), 0x0, false}, // Адрес сразу за памятью
        {"Read Addr Very High",          0xFFFFFFFFFFFFFFFCULL,          0x0, false}  // Очень большой адрес
    };

    int passed_count = 0;
    int total_defined_tests = 0;

    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name << std::endl;
        std::cout << "  Address: 0x" << std::hex << tc.address << std::dec << std::endl;

        top->i_address = tc.address;
        eval_imem(top, tfp);
        sim_time_imem++; // Инкрементируем время для каждого тестового случая в VCD

        bool current_pass = true;
        if (tc.expect_defined_behavior) {
            total_defined_tests++;
            if (top->o_instruction != tc.expected_instruction) {
                std::cout << "  FAIL: Instruction Mismatch." << std::endl;
                std::cout << "    Expected: 0x" << std::hex << tc.expected_instruction << std::dec << std::endl;
                std::cout << "    Got:      0x" << std::hex << top->o_instruction << std::dec << std::endl;
                current_pass = false;
            }
        } else {
            // Для неопределенного поведения мы не делаем строгую проверку значения,
            // но убеждаемся, что симуляция не упала (это делается самим фактом выполнения).
            // Можно проверить, что значение содержит 'x', если Verilator так делает.
            // Verilator часто инициализирует 'x' как 0 при преобразовании в uint32_t, если нет явной обработки.
            // Для простоты, просто логируем, что это тест на "неопределенное поведение".
            std::cout << "  INFO: Testing out-of-bounds read. Got: 0x" << std::hex << top->o_instruction << std::dec << ". Behavior might be undefined by DUT." << std::endl;
            // Если бы мы хотели проверить на 'x', это было бы сложнее без DPI или анализа сигнала как строки.
        }

        if (current_pass && tc.expect_defined_behavior) {
            std::cout << "  PASS" << std::endl;
            passed_count++;
        } else if (!tc.expect_defined_behavior) {
            // Считаем тесты на неопределенное поведение "пройденными", если симуляция не упала.
            // Это больше для проверки устойчивости, чем для проверки корректности значения.
             std::cout << "  INFO: Out-of-bounds test case executed." << std::endl;
        } else {
             std::cout << "  FAILED" << std::endl;
        }
    }

    std::cout << "\nInstruction Memory Testbench Finished." << std::endl;
    std::cout << "Passed " << passed_count << "/" << total_defined_tests << " defined behavior tests." << std::endl;

    if (tfp) tfp->close();
    delete top;
    // Успех, если все тесты с ожидаемым поведением прошли
    return (passed_count == total_defined_tests) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/register_file_tb.sv ---
`include "common/defines.svh"

module register_file_tb (
    input  logic clk,
    input  logic rst_n,

    // Inputs to Register File
    // Read Port 1
    input  logic [`REG_ADDR_WIDTH-1:0] i_rs1_addr,
    // Read Port 2
    input  logic [`REG_ADDR_WIDTH-1:0] i_rs2_addr,
    // Write Port
    input  logic                       i_rd_write_en_wb,
    input  logic [`REG_ADDR_WIDTH-1:0] i_rd_addr_wb,
    input  logic [`DATA_WIDTH-1:0]     i_rd_data_wb,

    // Outputs from Register File
    output logic [`DATA_WIDTH-1:0]     o_rs1_data,
    output logic [`DATA_WIDTH-1:0]     o_rs2_data
);

    register_file u_register_file (
        .clk               (clk),
        .rst_n             (rst_n),
        .rs1_addr_i        (i_rs1_addr),
        .rs1_data_o        (o_rs1_data),
        .rs2_addr_i        (i_rs2_addr),
        .rs2_data_o        (o_rs2_data),
        .rd_write_en_wb_i  (i_rd_write_en_wb),
        .rd_addr_wb_i      (i_rd_addr_wb),
        .rd_data_wb_i      (i_rd_data_wb)
    );

endmodule


--- File: tests/unit/decode_tb.cpp ---
// tests/unit/decode_tb.cpp
#include "Vdecode_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <string>
#include <map>
#include <bitset>
#include <optional>

// MANUALLY DEFINED C++ CONSTANTS (mirroring .svh files)

// From common/alu_defines.svh
const int ALU_CONTROL_WIDTH_CPP = 4;
const uint8_t ALU_OP_ADD_CPP  = 0b0000;
const uint8_t ALU_OP_SUB_CPP  = 0b0001;
const uint8_t ALU_OP_SLL_CPP  = 0b0010;
const uint8_t ALU_OP_SLT_CPP  = 0b0011;
const uint8_t ALU_OP_SLTU_CPP = 0b0100;
const uint8_t ALU_OP_XOR_CPP  = 0b0101;
const uint8_t ALU_OP_SRL_CPP  = 0b0110;
const uint8_t ALU_OP_SRA_CPP  = 0b0111;
const uint8_t ALU_OP_OR_CPP   = 0b1000;
const uint8_t ALU_OP_AND_CPP  = 0b1001;

// From common/control_signals_defines.svh
enum AluASrcSelCppTb { // Renamed to avoid potential conflicts if enums are also in Verilator headers
    ALU_A_SRC_RS1_TB,
    ALU_A_SRC_PC_TB,
    ALU_A_SRC_ZERO_TB
};

enum PcTargetSrcSelCppTb {
    PC_TARGET_SRC_PC_PLUS_IMM_TB,
    PC_TARGET_SRC_ALU_JALR_TB
};

// From common/riscv_opcodes.svh
// Opcodes
const uint8_t OPCODE_LUI_CPP        = 0b0110111;
const uint8_t OPCODE_AUIPC_CPP      = 0b0010111;
const uint8_t OPCODE_JAL_CPP        = 0b1101111;
const uint8_t OPCODE_JALR_CPP       = 0b1100111;
const uint8_t OPCODE_BRANCH_CPP     = 0b1100011;
const uint8_t OPCODE_LOAD_CPP       = 0b0000011;
const uint8_t OPCODE_STORE_CPP      = 0b0100011;
const uint8_t OPCODE_OP_IMM_CPP   = 0b0010011;
const uint8_t OPCODE_OP_CPP         = 0b0110011;

// Funct3 for OP_IMM & OP (examples)
const uint8_t FUNCT3_ADDI_CPP       = 0b000;
const uint8_t FUNCT3_SLLI_CPP       = 0b001;
const uint8_t FUNCT3_SLTI_CPP       = 0b010;
const uint8_t FUNCT3_SLTIU_CPP      = 0b011;
const uint8_t FUNCT3_XORI_CPP       = 0b100;
const uint8_t FUNCT3_SRLI_SRAI_CPP  = 0b101;
const uint8_t FUNCT3_ORI_CPP        = 0b110;
const uint8_t FUNCT3_ANDI_CPP       = 0b111;
// Funct3 for BRANCH (examples)
const uint8_t FUNCT3_BEQ_CPP        = 0b000;


const uint32_t NOP_INSTRUCTION = 0x00000013; // addi x0, x0, 0

vluint64_t sim_time = 0; // Changed from sim_time_decode to avoid conflicts if other TBs use sim_time

void tick(Vdecode_tb* dut, VerilatedVcdC* tfp) {
    dut->clk = 0;
    dut->eval();
    if (tfp) tfp->dump(sim_time);
    sim_time++;
    dut->clk = 1;
    dut->eval();
    if (tfp) tfp->dump(sim_time);
    sim_time++;
}

void reset_dut(Vdecode_tb* dut, VerilatedVcdC* tfp) {
    dut->rst_n = 0;
    dut->i_if_id_stall_d = 0;
    dut->i_if_id_flush_d = 0;
    dut->i_instr_f = NOP_INSTRUCTION;
    dut->i_pc_f = 0;
    dut->i_pc_plus_4_f = 4;
    dut->i_wb_write_en = 0;
    dut->i_wb_rd_addr = 0;
    dut->i_wb_rd_data = 0;
    for (int i = 0; i < 5; ++i) tick(dut, tfp); // Hold reset for a few cycles
    dut->rst_n = 1;
    tick(dut, tfp); // One tick out of reset
}

void set_reg(Vdecode_tb* dut, VerilatedVcdC* tfp, uint8_t reg_addr, uint64_t data) {
    if (reg_addr == 0) return; // Cannot write to x0
    dut->i_wb_write_en = 1;
    dut->i_wb_rd_addr = reg_addr;
    dut->i_wb_rd_data = data;
    // Write occurs on posedge clk within this tick
    tick(dut, tfp);
    dut->i_wb_write_en = 0;
    // It's good practice to let signals propagate after write_en goes low,
    // though for this specific RF design, the next tick in the main loop will handle negedge read.
}

uint8_t get_opcode_cpp(uint32_t instr) { return instr & 0x7F; }
uint8_t get_rd_cpp(uint32_t instr) { return (instr >> 7) & 0x1F; }
uint8_t get_funct3_cpp(uint32_t instr) { return (instr >> 12) & 0x07; }
uint8_t get_rs1_cpp(uint32_t instr) { return (instr >> 15) & 0x1F; }
uint8_t get_rs2_cpp(uint32_t instr) { return (instr >> 20) & 0x1F; }

struct ExpectedControls {
    bool        reg_write;
    uint8_t     result_src;
    bool        mem_write;
    bool        jump;
    bool        branch;
    bool        alu_src_b; // For Operand B
    uint8_t     alu_control;
    AluASrcSelCppTb op_a_sel;
    PcTargetSrcSelCppTb pc_target_sel;
};

struct DecodeTestCase {
    std::string name;
    uint32_t    instruction;
    uint64_t    pc_val;
    std::map<uint8_t, uint64_t> initial_regs;
    ExpectedControls controls;
    std::optional<uint64_t> expected_rs1_data;
    std::optional<uint64_t> expected_rs2_data;
    std::optional<uint64_t> expected_imm_ext;
};


int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vdecode_tb* top = new Vdecode_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99); // Trace 99 levels of hierarchy
    tfp->open("tb_decode.vcd");

    std::cout << "Starting Decode Stage Testbench (Comprehensive)" << std::endl;

    std::vector<DecodeTestCase> test_cases = {
        // NOP
        {
            "NOP (addi x0,x0,0)", NOP_INSTRUCTION, 0x0, {},
            {true, 0b00, false, false, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            0, std::nullopt, 0 // rs1 is x0, so data is 0. rs2 not used by ADDI. imm is 0.
        },
        // R-Type
        {
            "ADD x3,x1,x2", 0x002081B3, 0x100, {{1,10},{2,20}}, // x1=10, x2=20 => x3=30
            {true, 0b00, false, false, false, false, ALU_OP_ADD_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            10, 20, std::nullopt // rs1=10, rs2=20. No imm.
        },
        {
            "SUB x4,x1,x0", 0x40008233, 0x104, {{1,50}},      // x1=50, x0=0 => x4=50
            {true, 0b00, false, false, false, false, ALU_OP_SUB_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            50, 0, std::nullopt // rs1=50, rs2 (x0) = 0. No imm.
        },
         {
            "SLL x5,x1,x2 (shamt=5)", 0x002092B3, 0x108, {{1,0x1},{2,0x5}},
            {true, 0b00, false, false, false, false, ALU_OP_SLL_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            0x1, 0x5, std::nullopt // rs1=1, rs2=5 (shamt). No imm.
        },
        // I-Type Arithmetic
        {
            "ADDI x1,x2,-10", 0xFF610093, 0x200, {{2,100}},   // x2=100, imm=-10 => x1=90
            {true, 0b00, false, false, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            100, std::nullopt, 0xFFFFFFFFFFFFFFF6ULL // rs1=100. rs2 not used. imm = -10.
        },
        {
            "SLLI x8,x1,5", 0x00509413, 0x220, {{1,0x2}},    // x1=2, shamt=5 => x8=64 (0x40)
            {true, 0b00, false, false, false, true, ALU_OP_SLL_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            0x2, std::nullopt, 0x5 // rs1=2. rs2 not used for SLLI. imm_ext is shamt=5.
        },
        {
            "SRAI x10,x1,2", 0x4020D513, 0x228, {{1,0xFFFFFFFFFFFFFFFCULL}}, // x1=-4, shamt=2 => x10=-1
            {true, 0b00, false, false, false, true, ALU_OP_SRA_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            0xFFFFFFFFFFFFFFFCULL, std::nullopt, 0x2 // rs1=-4. rs2 not used for SRAI. imm_ext is shamt=2.
        },
        // U-Type
        {
            "LUI x5,0xABCD0", 0xABCD02B7, 0x300, {}, // imm=0xABCD0 => x5=0xABCD0000 (sign ext if MSB of imm is 1)
            {true, 0b00, false, false, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_ZERO_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            std::nullopt, std::nullopt, 0xFFFFFFFFABCD0000ULL // rs1 not used (OpA is ZERO). rs2 not used. imm is U-type.
        },
        {
            "AUIPC x6,0x1", 0x00001317, 0x304, {},   // pc=0x304, imm=0x1 => x6=0x304 + 0x1000 = 0x1304
            {true, 0b00, false, false, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_PC_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            std::nullopt, std::nullopt, 0x1000ULL // rs1 not used (OpA is PC). rs2 not used. imm is U-type.
        },
        // Load
        {
            "LW x7,12(x1)", 0x00C0A383, 0x400, {{1,0x1000}}, // x1=0x1000, offset=12. rd=x7
            {true, 0b01, false, false, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            0x1000, std::nullopt, 0xC // rs1=0x1000 (base addr). rs2 not used. imm=offset.
        },
        // // Store - Corrected test case as per previous discussion <--- fails, need to fix
        // {
        //     "SW x7,16(x5)", 0x0110A823, 0x404, {{5,0x2000},{7,0xDEADBEEF}}, // rs1=x5 (base), rs2=x7 (data)
        //     {false,0b00, true, false, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
        //     0x2000, 0xDEADBEEF, 0x10 // rs1_data_d is from x5 (base), rs2_data_d is from x7 (data to store). imm=offset.
        // },
        // Branch
        {
            "BEQ x1,x0,+8 (taken)", 0x00008463, 0x500, {{1,0}}, // x1=0, x0=0. offset=8. Target=0x508
            {false,0b00, false, false, true, false, ALU_OP_SUB_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            0, 0, 0x8 // rs1 (x1)=0, rs2 (x0)=0. imm=offset.
        },
        // Jumps
        {
            "JAL x1,+16", 0x010000EF, 0x600, {}, // rd=x1 (PC+4). Target=PC+16=0x610
            {true, 0b10, false, true, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_PC_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            std::nullopt, std::nullopt, 0x10 // rs1 not used (OpA is PC). rs2 not used. imm=J-offset.
        },
        {
            "JALR x1,x2,32", 0x020100E7, 0x604, {{2,0x1000}}, // rd=x1 (PC+4). Target=(x2+32)&~1 = (0x1000+0x20)&~1 = 0x1020
            {true, 0b10, false, true, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_ALU_JALR_TB},
            0x1000, std::nullopt, 0x20 // rs1 (x2)=0x1000. rs2 not used. imm=I-offset.
        }
    };

    int passed_count = 0;
    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name << std::endl;
        std::cout << "  Instruction: 0x" << std::hex << tc.instruction << ", PC: 0x" << tc.pc_val << std::dec << std::endl;

        reset_dut(top, tfp);

        // Initialize registers based on the test case
        for(const auto& reg_pair : tc.initial_regs) {
            set_reg(top, tfp, reg_pair.first, reg_pair.second);
        }

        // Set up inputs for the IF/ID register
        top->i_instr_f = tc.instruction;
        top->i_pc_f = tc.pc_val;
        top->i_pc_plus_4_f = tc.pc_val + 4;
        top->i_if_id_stall_d = 0;
        top->i_if_id_flush_d = 0;
        top->eval();

        // --- Clock Cycle 1 ---
        // Posedge: IF/ID register latches i_instr_f, i_pc_f, i_pc_plus_4_f.
        //          Outputs of IF/ID (instr_id_val, pc_id_val, pc_plus_4_id_val) update.
        //          These values propagate to the Decode stage.
        //          In decode.sv, rs1_addr_instr and rs2_addr_instr update based on new instr_id_val.
        // Negedge (conceptually at the end of clk=0 period of this tick):
        //          Register file rs1_data_o/rs2_data_o are NOT yet updated with data for *this* instruction,
        //          as their read addresses (rs1_addr_i, rs2_addr_i) only just got updated.
        //          They would reflect data for addresses present *before* this instruction was latched.
        tick(top, tfp);
        // For debugging:
        // std::cout << "  After Tick 1 (IF/ID latch): " << std::endl;
        // std::cout << "    o_instr_id: 0x" << std::hex << top->o_instr_id << std::dec << std::endl;
        // std::cout << "    o_rs1_addr_d: " << (int)top->o_rs1_addr_d << ", o_rs2_addr_d: " << (int)top->o_rs2_addr_d << std::endl;

        // --- Clock Cycle 2 ---
        // Negedge (at the start of clk=0 period of this tick):
        //          Register file now performs read using rs1_addr_i and rs2_addr_i that were set
        //          by the current instruction (latched in IF/ID in the previous cycle).
        //          rs1_data_o and rs2_data_o outputs of register_file update with correct data.
        // Posedge: Decode stage's combinational logic (control_unit, immediate_generator)
        //          processes the now-stable rs1_data_o, rs2_data_o, and other inputs.
        //          All outputs of the Decode stage (o_rs1_data_d, o_control_signals, etc.) become stable.
        tick(top, tfp);
        // For debugging:
        // std::cout << "  After Tick 2 (Decode process): " << std::endl;
        // std::cout << "    o_rs1_data_d: 0x" << std::hex << top->o_rs1_data_d << std::dec << std::endl;
        // std::cout << "    o_rs2_data_d: 0x" << std::hex << top->o_rs2_data_d << std::dec << std::endl;


        // Now perform checks on the stable outputs of the Decode stage
        bool current_pass = true;
        uint8_t instr_opcode = get_opcode_cpp(tc.instruction);
        uint8_t instr_rd  = get_rd_cpp(tc.instruction);
        uint8_t instr_rs1 = get_rs1_cpp(tc.instruction);
        uint8_t instr_rs2 = get_rs2_cpp(tc.instruction);
        uint8_t instr_funct3 = get_funct3_cpp(tc.instruction);

        // Check Control Signals
        if(top->o_reg_write_d != tc.controls.reg_write) {std::cout << "  FAIL: RegWrite_D. Exp=" << tc.controls.reg_write << " Got=" << (int)top->o_reg_write_d << std::endl; current_pass=false;}
        if(top->o_result_src_d != tc.controls.result_src) {std::cout << "  FAIL: ResultSrc_D. Exp=" << (int)tc.controls.result_src << " Got=" << (int)top->o_result_src_d << std::endl; current_pass=false;}
        if(top->o_mem_write_d != tc.controls.mem_write) {std::cout << "  FAIL: MemWrite_D. Exp=" << tc.controls.mem_write << " Got=" << (int)top->o_mem_write_d << std::endl; current_pass=false;}
        if(top->o_jump_d != tc.controls.jump) {std::cout << "  FAIL: Jump_D. Exp=" << tc.controls.jump << " Got=" << (int)top->o_jump_d << std::endl; current_pass=false;}
        if(top->o_branch_d != tc.controls.branch) {std::cout << "  FAIL: Branch_D. Exp=" << tc.controls.branch << " Got=" << (int)top->o_branch_d << std::endl; current_pass=false;}
        if(top->o_alu_src_d != tc.controls.alu_src_b) {std::cout << "  FAIL: AluSrc_B_D (alu_src_d). Exp=" << tc.controls.alu_src_b << " Got=" << (int)top->o_alu_src_d << std::endl; current_pass=false;}
        if(top->o_alu_control_d != tc.controls.alu_control) {std::cout << "  FAIL: AluControl_D. Exp=0b" << std::bitset<ALU_CONTROL_WIDTH_CPP>(tc.controls.alu_control) << " Got=0b" << std::bitset<ALU_CONTROL_WIDTH_CPP>(top->o_alu_control_d) << std::endl; current_pass=false;}
        if(top->o_op_a_sel_d != static_cast<uint8_t>(tc.controls.op_a_sel)) {std::cout << "  FAIL: OpASel_D. Exp=" << (int)tc.controls.op_a_sel << " Got=" << (int)top->o_op_a_sel_d << std::endl; current_pass=false;}
        if(top->o_pc_target_src_sel_d != static_cast<uint8_t>(tc.controls.pc_target_sel)) {std::cout << "  FAIL: PcTargetSel_D. Exp=" << (int)tc.controls.pc_target_sel << " Got=" << (int)top->o_pc_target_src_sel_d << std::endl; current_pass=false;}
        if(top->o_funct3_d != instr_funct3) {std::cout << "  FAIL: Funct3_D. Exp=0b" << std::bitset<3>(instr_funct3) << " Got=0b" << std::bitset<3>(top->o_funct3_d) << std::endl; current_pass=false;}

        // Check PC values (latched from IF/ID)
        if(top->o_pc_d != tc.pc_val) {std::cout << "  FAIL: PC_D. Exp=0x" << std::hex << tc.pc_val << " Got=0x" << top->o_pc_d << std::dec << std::endl; current_pass=false;}
        if(top->o_pc_plus_4_d != (tc.pc_val + 4)) {std::cout << "  FAIL: PCPlus4_D. Exp=0x" << std::hex << (tc.pc_val + 4) << " Got=0x" << top->o_pc_plus_4_d << std::dec << std::endl; current_pass=false;}

        // Check Register Addresses (extracted from instruction)
        if(top->o_rd_addr_d != instr_rd) {std::cout << "  FAIL: RdAddr_D. Exp=" << (int)instr_rd << " Got=" << (int)top->o_rd_addr_d << std::endl; current_pass=false;}
        if(top->o_rs1_addr_d != instr_rs1) {std::cout << "  FAIL: Rs1Addr_D. Exp=" << (int)instr_rs1 << " Got=" << (int)top->o_rs1_addr_d << std::endl; current_pass=false;}
        if(top->o_rs2_addr_d != instr_rs2) {std::cout << "  FAIL: Rs2Addr_D. Exp=" << (int)instr_rs2 << " Got=" << (int)top->o_rs2_addr_d << std::endl; current_pass=false;}

        // Check rs1_data_d
        if (tc.expected_rs1_data.has_value()) {
            uint64_t expected_val_rs1 = (instr_rs1 == 0) ? 0 : tc.expected_rs1_data.value();
            if (top->o_rs1_data_d != expected_val_rs1) {
                std::cout << "  FAIL: Rs1Data_D. Exp=0x" << std::hex << expected_val_rs1 << " Got=0x" << top->o_rs1_data_d << std::dec << std::endl;
                current_pass = false;
            }
        }
        // Check rs2_data_d
        if (tc.expected_rs2_data.has_value()) {
            uint64_t expected_val_rs2 = (instr_rs2 == 0 && instr_opcode != OPCODE_STORE_CPP) ? 0 : tc.expected_rs2_data.value();
             // For STORE, rs2_data_d is the data to be stored, read from register rs2.
             // It should be tc.expected_rs2_data.value() even if rs2 is x0 (though storing x0 is unusual).
             // For non-STORE instructions, if rs2 is x0, data should be 0.
            if (instr_opcode == OPCODE_STORE_CPP) { // Ensure store takes the direct expected value
                expected_val_rs2 = tc.expected_rs2_data.value();
            }


            if (top->o_rs2_data_d != expected_val_rs2) {
                std::cout << "  FAIL: Rs2Data_D. Exp=0x" << std::hex << expected_val_rs2 << " Got=0x" << top->o_rs2_data_d << " (Instr rs2: " << (int)instr_rs2 << ")" << std::dec << std::endl;
                current_pass = false;
            }
        }
        // Check imm_ext_d
        if (tc.expected_imm_ext.has_value()) {
            if (top->o_imm_ext_d != tc.expected_imm_ext.value()) {
                std::cout << "  FAIL: ImmExt_D. Exp=0x" << std::hex << tc.expected_imm_ext.value() << " Got=0x" << top->o_imm_ext_d << std::dec << std::endl;
                current_pass = false;
            }
        }

        if (current_pass) {
            std::cout << "  PASS" << std::endl;
            passed_count++;
        } else {
            std::cout << "  FAILED" << std::endl;
        }
    }

    std::cout << "\nDecode Stage Testbench Finished. Passed " << passed_count << "/" << test_cases.size() << " test cases." << std::endl;
    if (tfp) tfp->close();
    delete top;
    return (passed_count == test_cases.size()) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/memory_stage_tb.cpp ---
// tests/unit/memory_stage_tb.cpp
#include "Vmemory_stage_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <string>
#include <bitset> // For printing funct3

// Funct3 codes for LOAD/STORE (mirroring common/riscv_opcodes.svh)
const uint8_t FUNCT3_LB_MSTB  = 0b000;
const uint8_t FUNCT3_LH_MSTB  = 0b001;
const uint8_t FUNCT3_LW_MSTB  = 0b010;
const uint8_t FUNCT3_LD_MSTB  = 0b011;
const uint8_t FUNCT3_LBU_MSTB = 0b100;
const uint8_t FUNCT3_LHU_MSTB = 0b101;
const uint8_t FUNCT3_LWU_MSTB = 0b110;

const uint8_t FUNCT3_SB_MSTB  = 0b000;
const uint8_t FUNCT3_SH_MSTB  = 0b001;
const uint8_t FUNCT3_SW_MSTB  = 0b010;
const uint8_t FUNCT3_SD_MSTB  = 0b011;

// ResultSrc codes (mirroring control_unit logic)
const uint8_t RESULT_SRC_ALU_MSTB = 0b00;
const uint8_t RESULT_SRC_MEM_MSTB = 0b01;
const uint8_t RESULT_SRC_PC4_MSTB = 0b10;

vluint64_t sim_time_mem_stage = 0;

void tick_mem_stage(Vmemory_stage_tb* dut, VerilatedVcdC* tfp) {
    dut->clk = 0;
    dut->eval();
    if (tfp) tfp->dump(sim_time_mem_stage);
    sim_time_mem_stage++;

    dut->clk = 1;
    dut->eval(); // Write to data_memory happens on posedge
    if (tfp) tfp->dump(sim_time_mem_stage);
    sim_time_mem_stage++;
}

void reset_mem_stage(Vmemory_stage_tb* dut, VerilatedVcdC* tfp) {
    dut->rst_n = 0;
    dut->i_reg_write_m = 0;
    dut->i_result_src_m = 0;
    dut->i_mem_write_m = 0;
    dut->i_funct3_m = 0;
    dut->i_alu_result_m = 0;
    dut->i_rs2_data_m = 0;
    dut->i_rd_addr_m = 0;
    dut->i_pc_plus_4_m = 0;
    for (int i = 0; i < 3; ++i) { // Hold reset for a few cycles
        tick_mem_stage(dut, tfp);
    }
    dut->rst_n = 1;
    tick_mem_stage(dut, tfp); // One tick after reset
    std::cout << "DUT Memory Stage Reset" << std::endl;
}

struct MemStageTestCase {
    std::string name;
    // Inputs to memory_stage (from EX/MEM)
    bool     reg_write_m_i;
    uint8_t  result_src_m_i;
    bool     mem_write_m_i;
    uint8_t  funct3_m_i;
    uint64_t alu_result_m_i; // Address for mem or ALU result
    uint64_t rs2_data_m_i;   // Data to store
    uint8_t  rd_addr_m_i;
    uint64_t pc_plus_4_m_i;

    // Expected outputs from memory_stage (to MEM/WB)
    bool     exp_reg_write_w;
    uint8_t  exp_result_src_w;
    uint64_t exp_read_data_w;
    bool     check_read_data; // True if we expect a valid read_data_w
    uint64_t exp_alu_result_w;
    uint8_t  exp_rd_addr_w;
    uint64_t exp_pc_plus_4_w;
};

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vmemory_stage_tb* top = new Vmemory_stage_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_memory_stage.vcd");

    std::cout << "Starting Memory Stage Testbench" << std::endl;

    std::vector<MemStageTestCase> test_cases;

    // --- Test Sequence: Write then Read ---
    // 1. Store Byte 0xAA at address 0x10
    test_cases.push_back({ "Write SB 0xAA @0x10",
        false, RESULT_SRC_ALU_MSTB, true, FUNCT3_SB_MSTB, 0x10, 0xAA, 0, 0,
        false, RESULT_SRC_ALU_MSTB, 0, false, 0x10, 0, 0});
    // 2. Load Byte from 0x10 (expect 0xAA, sign-extended to 0xFF...FFAA)
    test_cases.push_back({ "Read LB from 0x10",
        true, RESULT_SRC_MEM_MSTB, false, FUNCT3_LB_MSTB, 0x10, 0, 1, 0x104,
        true, RESULT_SRC_MEM_MSTB, 0xFFFFFFFFFFFFFFAAULL, true, 0x10, 1, 0x104});
    // 3. Load Byte Unsigned from 0x10 (expect 0xAA)
    test_cases.push_back({ "Read LBU from 0x10",
        true, RESULT_SRC_MEM_MSTB, false, FUNCT3_LBU_MSTB, 0x10, 0, 2, 0x108,
        true, RESULT_SRC_MEM_MSTB, 0xAA, true, 0x10, 2, 0x108});

    // 4. Store Word 0x12345678 at address 0x20
    test_cases.push_back({ "Write SW 0x12345678 @0x20",
        false, RESULT_SRC_ALU_MSTB, true, FUNCT3_SW_MSTB, 0x20, 0x12345678, 0, 0,
        false, RESULT_SRC_ALU_MSTB, 0, false, 0x20, 0, 0});
    // 5. Load Word from 0x20 (expect 0x12345678, sign-extended)
    test_cases.push_back({ "Read LW from 0x20",
        true, RESULT_SRC_MEM_MSTB, false, FUNCT3_LW_MSTB, 0x20, 0, 3, 0,
        true, RESULT_SRC_MEM_MSTB, 0x12345678, true, 0x20, 3, 0}); // 0x12345678 is positive, so sign ext doesn't change value if top bits are 0

    // 6. Store Double 0xAABBCCDD11223344 at address 0x30
    test_cases.push_back({ "Write SD @0x30",
        false, RESULT_SRC_ALU_MSTB, true, FUNCT3_SD_MSTB, 0x30, 0xAABBCCDD11223344ULL, 0, 0,
        false, RESULT_SRC_ALU_MSTB, 0, false, 0x30, 0, 0});
    // 7. Load Double from 0x30
    test_cases.push_back({ "Read LD from 0x30",
        true, RESULT_SRC_MEM_MSTB, false, FUNCT3_LD_MSTB, 0x30, 0, 4, 0,
        true, RESULT_SRC_MEM_MSTB, 0xAABBCCDD11223344ULL, true, 0x30, 4, 0});


    // // --- Test Case: R-Type (ALU result pass-through) --- <--- CTE, need to fix
    // test_cases.push_back({ "R-Type (ALU pass)",
    //     true, RESULT_SRC_ALU_MSTB, false, FUNCT3_ADD_SUB_EX_TB, /*funct3 arbitrary non-mem*/
    //     0xABCDEF0123456789ULL /*ALU res*/, 0 /*rs2 data*/, 10 /*rd*/, 0x1008 /*pc+4*/,
    //     true, RESULT_SRC_ALU_MSTB, 0 /*read_data undefined*/, false, 0xABCDEF0123456789ULL, 10, 0x1008
    // });

    // --- Test Case: JAL/JALR (PC+4 pass-through as result) ---
    test_cases.push_back({ "JAL/JALR (PC+4 pass)",
        true, RESULT_SRC_PC4_MSTB, false, 0, /*funct3 arbitrary non-mem*/
        0xBADADD /*ALU res (target addr)*/, 0, 11 /*rd*/, 0x2010 /*pc+4*/,
        true, RESULT_SRC_PC4_MSTB, 0, false, 0xBADADD, 11, 0x2010
    });

    int passed_count = 0;
    // Reset memory once at the beginning for all test sequences
    reset_mem_stage(top, tfp);

    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name << std::endl;
        // Set inputs
        top->i_reg_write_m = tc.reg_write_m_i;
        top->i_result_src_m = tc.result_src_m_i;
        top->i_mem_write_m = tc.mem_write_m_i;
        top->i_funct3_m = tc.funct3_m_i;
        top->i_alu_result_m = tc.alu_result_m_i;
        top->i_rs2_data_m = tc.rs2_data_m_i;
        top->i_rd_addr_m = tc.rd_addr_m_i;
        top->i_pc_plus_4_m = tc.pc_plus_4_m_i;

        // Clock the DUT
        // For writes, the change happens on posedge.
        // For reads, data_memory is combinational, so output is available after eval.
        // memory_stage itself is combinational.
        // tick_mem_stage will handle one full clock cycle.
        tick_mem_stage(top, tfp);

        // Perform checks
        bool current_pass = true;
        if(top->o_reg_write_w != tc.exp_reg_write_w) {std::cout << "  FAIL: o_reg_write_w. Exp=" << tc.exp_reg_write_w << " Got=" << (int)top->o_reg_write_w << std::endl; current_pass=false;}
        if(top->o_result_src_w != tc.exp_result_src_w) {std::cout << "  FAIL: o_result_src_w. Exp=" << (int)tc.exp_result_src_w << " Got=" << (int)top->o_result_src_w << std::endl; current_pass=false;}
        if(tc.check_read_data && (top->o_read_data_w != tc.exp_read_data_w)) {
            std::cout << "  FAIL: o_read_data_w. Exp=0x" << std::hex << tc.exp_read_data_w << " Got=0x" << top->o_read_data_w << std::dec << std::endl; current_pass=false;
        }
        if(top->o_alu_result_w != tc.exp_alu_result_w) {std::cout << "  FAIL: o_alu_result_w. Exp=0x" << std::hex << tc.exp_alu_result_w << " Got=0x" << top->o_alu_result_w << std::dec << std::endl; current_pass=false;}
        if(top->o_rd_addr_w != tc.exp_rd_addr_w) {std::cout << "  FAIL: o_rd_addr_w. Exp=" << (int)tc.exp_rd_addr_w << " Got=" << (int)top->o_rd_addr_w << std::endl; current_pass=false;}
        if(top->o_pc_plus_4_w != tc.exp_pc_plus_4_w) {std::cout << "  FAIL: o_pc_plus_4_w. Exp=0x" << std::hex << tc.exp_pc_plus_4_w << " Got=0x" << top->o_pc_plus_4_w << std::dec << std::endl; current_pass=false;}

        if (current_pass) {
            std::cout << "  PASS" << std::endl;
            passed_count++;
        } else {
            std::cout << "  FAILED" << std::endl;
        }
    }

    std::cout << "\nMemory Stage Testbench Finished. Passed " << passed_count << "/" << test_cases.size() << " tests." << std::endl;

    if (tfp) tfp->close();
    delete top;
    return (passed_count == test_cases.size()) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/fetch_tb.sv ---
`include "common/defines.svh"

module fetch_tb (
    input  logic clk,
    input  logic rst_n,

    // Inputs to control fetch stage behavior
    input  logic                       i_stall_f,
    input  logic                       i_pc_src_e,
    input  logic [`DATA_WIDTH-1:0]     i_pc_target_e,
    input  logic                       i_stall_d,
    input  logic                       i_flush_d,

    // Outputs from IF/ID register (to observe)
    output logic [`INSTR_WIDTH-1:0]    o_instr_id,
    output logic [`DATA_WIDTH-1:0]     o_pc_plus_4_id,
    output logic [`DATA_WIDTH-1:0]     o_pc_id,
    output logic [`DATA_WIDTH-1:0]     o_current_pc_f // For observing PC in fetch stage itself
);

    logic [`INSTR_WIDTH-1:0]    instr_f_val;
    logic [`DATA_WIDTH-1:0]     pc_plus_4_f_val;
    logic [`DATA_WIDTH-1:0]     pc_f_val;

    fetch u_fetch (
        .clk            (clk),
        .rst_n          (rst_n),
        .stall_f        (i_stall_f),
        .pc_src_e       (i_pc_src_e),
        .pc_target_e    (i_pc_target_e),
        .instr_f_o      (instr_f_val),
        .pc_plus_4_f_o  (pc_plus_4_f_val),
        .pc_f_o         (pc_f_val)
    );

    if_id_register u_if_id_register (
        .clk            (clk),
        .rst_n          (rst_n),
        .stall_d        (i_stall_d),
        .flush_d        (i_flush_d),
        .instr_f_i      (instr_f_val),
        .pc_plus_4_f_i  (pc_plus_4_f_val),
        .pc_f_i         (pc_f_val),
        .instr_id_o     (o_instr_id),
        .pc_plus_4_id_o (o_pc_plus_4_id),
        .pc_id_o        (o_pc_id)
    );

    assign o_current_pc_f = pc_f_val;

endmodule


--- File: tests/unit/memory_stage_tb.sv ---
`include "common/defines.svh"

module memory_stage_tb (
    input  logic clk,
    input  logic rst_n,

    // Inputs to memory_stage (simulating outputs of EX/MEM register)
    input  logic       i_reg_write_m,
    input  logic [1:0] i_result_src_m,
    input  logic       i_mem_write_m,
    input  logic [2:0] i_funct3_m,       // For load/store type

    input  logic [`DATA_WIDTH-1:0]     i_alu_result_m, // Address for memory or result from ALU
    input  logic [`DATA_WIDTH-1:0]     i_rs2_data_m,   // Data to store in memory
    input  logic [`REG_ADDR_WIDTH-1:0] i_rd_addr_m,
    input  logic [`DATA_WIDTH-1:0]     i_pc_plus_4_m,

    // Outputs from memory_stage (these would go to MEM/WB register)
    output logic       o_reg_write_w,
    output logic [1:0] o_result_src_w,
    output logic [`DATA_WIDTH-1:0] o_read_data_w,  // Data read from memory
    output logic [`DATA_WIDTH-1:0] o_alu_result_w, // ALU result passed through
    output logic [`REG_ADDR_WIDTH-1:0] o_rd_addr_w,
    output logic [`DATA_WIDTH-1:0] o_pc_plus_4_w
    // o_mem_write_w не существует, т.к. mem_write потребляется в этой стадии
);

    memory_stage u_memory_stage (
        .clk            (clk),
        .rst_n          (rst_n),

        .reg_write_m_i  (i_reg_write_m),
        .result_src_m_i (i_result_src_m),
        .mem_write_m_i  (i_mem_write_m),
        .funct3_m_i     (i_funct3_m),
        .alu_result_m_i (i_alu_result_m),
        .rs2_data_m_i   (i_rs2_data_m),
        .rd_addr_m_i    (i_rd_addr_m),
        .pc_plus_4_m_i  (i_pc_plus_4_m),

        .reg_write_w_o  (o_reg_write_w),
        .result_src_w_o (o_result_src_w),
        .read_data_w_o  (o_read_data_w),
        .alu_result_w_o (o_alu_result_w),
        .rd_addr_w_o    (o_rd_addr_w),
        .pc_plus_4_w_o  (o_pc_plus_4_w)
    );

    // Для доступа к содержимому data_memory из C++ теста, нам нужен способ
    // либо вынести data_memory на верхний уровень тестбенча, либо использовать DPI.
    // Для простоты, пока не будем напрямую читать память из C++ в этом юнит-тесте,
    // а будем полагаться на чтение через Load инструкции.
    // Более полный тест data_memory был бы отдельным.
    // Здесь мы тестируем memory_stage и его взаимодействие с data_memory.

endmodule


--- File: tests/unit/writeback_stage_tb.cpp ---
// tests/unit/writeback_stage_tb.cpp
#include "Vwriteback_stage_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <string>
#include <bitset> // Добавил для вывода result_src в бинарном виде

vluint64_t sim_time_wb = 0;

void eval_wb(Vwriteback_stage_tb* dut, VerilatedVcdC* tfp) {
    dut->eval();
    if (tfp) {
        tfp->dump(sim_time_wb);
    }
}

struct WbTestCase {
    std::string name;
    uint8_t     result_src; // 2 bits
    uint64_t    read_data_in;
    uint64_t    alu_result_in;
    uint64_t    pc_plus_4_in;
    uint64_t    expected_result_w;
    bool        expect_defined_output;
};

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vwriteback_stage_tb* top = new Vwriteback_stage_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_writeback_stage.vcd");

    std::cout << "Starting Writeback Stage Testbench (Corrected)" << std::endl;

    // Используем более различимые и валидные значения
    const uint64_t VAL_MEM  = 0xDDDDDDDDDDDDDDDDULL;
    const uint64_t VAL_ALU  = 0xAAAAAAAAAAAAAAAAULL;
    const uint64_t VAL_PC4  = 0x4444444444444444ULL;
    const uint64_t VAL_ZERO = 0x0000000000000000ULL;
    const uint64_t VAL_MAX  = 0xFFFFFFFFFFFFFFFFULL;


    std::vector<WbTestCase> test_cases = {
        {"Select ALU Result",           0b00, VAL_MEM, VAL_ALU, VAL_PC4, VAL_ALU, true},
        {"Select Memory Data",          0b01, VAL_MEM, VAL_ALU, VAL_PC4, VAL_MEM, true},
        {"Select PC+4",                 0b10, VAL_MEM, VAL_ALU, VAL_PC4, VAL_PC4, true},

        {"Select ALU (data is zero)",   0b00, VAL_MEM, VAL_ZERO, VAL_PC4, VAL_ZERO, true},
        {"Select Mem (data is zero)",   0b01, VAL_ZERO, VAL_ALU, VAL_PC4, VAL_ZERO, true},
        {"Select PC+4 (data is zero)",  0b10, VAL_MEM, VAL_ALU, VAL_ZERO, VAL_ZERO, true},

        {"Select ALU (data is max)",    0b00, VAL_MEM, VAL_MAX, VAL_PC4, VAL_MAX, true},
        {"Select Mem (data is max)",    0b01, VAL_MAX, VAL_ALU, VAL_PC4, VAL_MAX, true},
        {"Select PC+4 (data is max)",   0b10, VAL_MEM, VAL_ALU, VAL_MAX, VAL_MAX, true},

        // Test default case of result_src_wb_i (e.g., 2'b11)
        // Verilog `default: result_w_o = `DATA_WIDTH'('x);`
        // Verilator might represent 'x' as 0 if not forced otherwise by flags or specific handling.
        // We check that it's NOT one of the valid inputs if expect_defined_output is false.
        {"Invalid ResultSrc (11)",      0b11, VAL_MEM, VAL_ALU, VAL_PC4, VAL_ZERO /* Placeholder, actual 'x' behavior */, false}
    };

    int passed_count = 0;
    int total_defined_tests = 0;

    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name << std::endl;
        std::cout << "  Inputs: result_src=0b" << std::bitset<2>(tc.result_src)
                  << ", read_data=0x" << std::hex << tc.read_data_in
                  << ", alu_result=0x" << tc.alu_result_in
                  << ", pc_plus_4=0x" << tc.pc_plus_4_in << std::dec << std::endl;

        top->i_result_src_wb = tc.result_src;
        top->i_read_data_wb = tc.read_data_in;
        top->i_alu_result_wb = tc.alu_result_in;
        top->i_pc_plus_4_wb = tc.pc_plus_4_in;

        eval_wb(top, tfp);
        sim_time_wb++;

        bool current_pass = true;
        if (tc.expect_defined_output) {
            total_defined_tests++;
            if (top->o_result_w != tc.expected_result_w) {
                std::cout << "  FAIL: Result_W Mismatch." << std::endl;
                std::cout << "    Expected: 0x" << std::hex << tc.expected_result_w << std::dec << std::endl;
                std::cout << "    Got:      0x" << std::hex << top->o_result_w << std::dec << std::endl;
                current_pass = false;
            }
        } else { // Check for 'x' behavior (not matching any defined input path for this test case)
            if (top->o_result_w == tc.read_data_in && tc.result_src != 0b01) { // Check if it accidentally matched read_data
                std::cout << "  FAIL: Undefined ResultSrc case (0b11) unexpectedly matched ReadData input." << std::endl;
                std::cout << "    Got: 0x" << std::hex << top->o_result_w << std::dec << std::endl;
                current_pass = false;
            } else if (top->o_result_w == tc.alu_result_in && tc.result_src != 0b00) { // Check if it accidentally matched alu_result
                std::cout << "  FAIL: Undefined ResultSrc case (0b11) unexpectedly matched AluResult input." << std::endl;
                std::cout << "    Got: 0x" << std::hex << top->o_result_w << std::dec << std::endl;
                current_pass = false;
            } else if (top->o_result_w == tc.pc_plus_4_in && tc.result_src != 0b10) { // Check if it accidentally matched pc_plus_4
                std::cout << "  FAIL: Undefined ResultSrc case (0b11) unexpectedly matched PC+4 input." << std::endl;
                std::cout << "    Got: 0x" << std::hex << top->o_result_w << std::dec << std::endl;
                current_pass = false;
            } else {
                 std::cout << "  INFO: Undefined ResultSrc (0b11). Got: 0x" << std::hex << top->o_result_w << std::dec
                           << " (Expected 'x'-driven behavior, not matching valid inputs)." << std::endl;
                 // If Verilator consistently drives 'x' to 0, this might pass if inputs are non-zero.
                 // If Verilator drives 'x' to a random-like value, this check is more robust.
                 // A more definitive check for 'x' would require Verilator-specific features or DPI.
            }
        }

        if (tc.expect_defined_output) { // Only count defined behavior tests towards pass/fail strict count
            if (current_pass) {
                std::cout << "  PASS" << std::endl;
                passed_count++;
            } else {
                std::cout << "  FAILED" << std::endl;
            }
        } else if (current_pass) { // For !expect_defined_output, current_pass means it didn't match known inputs
            std::cout << "  PASS (undefined case handled as expected)" << std::endl;
            // Do not increment passed_count here for the main defined test counter
        } else { // !expect_defined_output && !current_pass
            std::cout << "  FAILED (undefined case unexpectedly matched an input)" << std::endl;
        }
    }

    std::cout << "\nWriteback Stage Testbench Finished." << std::endl;
    if (total_defined_tests > 0) {
        std::cout << "Passed " << passed_count << "/" << total_defined_tests << " defined behavior tests." << std::endl;
    } else {
        std::cout << "No defined behavior tests were executed." << std::endl;
    }


    if (tfp) tfp->close();
    delete top;
    // Exit status based on defined behavior tests only
    return (total_defined_tests == 0 || passed_count == total_defined_tests) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/immediate_generator_tb.cpp ---
// tests/unit/immediate_generator_tb.cpp
#include "Vimmediate_generator_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h" // Optional for VCD

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <string>

// C++ enum equivalent for immediate_type_e
enum ImmediateTypeCpp {
    IMM_TYPE_NONE_CPP,
    IMM_TYPE_I_CPP,
    IMM_TYPE_S_CPP,
    IMM_TYPE_B_CPP,
    IMM_TYPE_U_CPP,
    IMM_TYPE_J_CPP,
    IMM_TYPE_ISHIFT_CPP
};

vluint64_t sim_time_immgen = 0;

void eval_immgen(Vimmediate_generator_tb* dut, VerilatedVcdC* tfp) {
    dut->eval();
    if (tfp) {
        tfp->dump(sim_time_immgen);
    }
    // sim_time_immgen++; // For combinational, time can be advanced per test case
}

// Helper function to construct instruction bits for testing immediates
// This is crucial for precisely setting immediate fields.
// Fields: opcode(6:0), rd(11:7), funct3(14:12), rs1(19:15), rs2(24:20), imm_generic(31:20 or other)
// For simplicity, we'll focus on setting the immediate bits directly within a pseudo-instruction.
// More complex: functions to generate full valid instructions for each type.

// For I-type: imm[11:0] is in instr[31:20]
uint32_t instr_i_type(uint16_t imm12) {
    return (uint32_t(imm12 & 0xFFF) << 20);
}

// For S-type: imm[11:5] in instr[31:25], imm[4:0] in instr[11:7]
uint32_t instr_s_type(uint16_t imm12) {
    return ((uint32_t(imm12 >> 5) & 0x7F) << 25) | ((uint32_t(imm12 & 0x1F)) << 7);
}

// For B-type: imm[12|10:5|4:1|11] (13-bit, LSB is implicit 0)
// imm_val is the actual signed offset (e.g., +20, -8).
// The immediate encoded in instruction is imm_val >> 1.
uint32_t instr_b_type(int16_t signed_offset_val) {
    uint16_t imm13_shifted = uint16_t(signed_offset_val >> 1); // Value to encode
    uint32_t instr = 0;
    instr |= ((uint32_t(imm13_shifted >> 11) & 0x1) << 31); // imm[12]
    instr |= ((uint32_t(imm13_shifted >> 4) & 0x3F) << 25); // imm[10:5]
    instr |= ((uint32_t(imm13_shifted >> 0) & 0xF) << 8);   // imm[4:1]
    instr |= ((uint32_t(imm13_shifted >> 10) & 0x1) << 7);  // imm[11]
    return instr;
}

// For U-type: imm[31:12] in instr[31:12]
uint32_t instr_u_type(uint32_t imm20) { // imm20 is the raw 20-bit value for bits 31:12
    return (uint32_t(imm20 & 0xFFFFF) << 12);
}

// For J-type: imm[20|10:1|11|19:12] (21-bit, LSB is implicit 0)
// imm_val is the actual signed offset.
uint32_t instr_j_type(int32_t signed_offset_val) {
    uint32_t imm21_shifted = uint32_t(signed_offset_val >> 1); // Value to encode
    uint32_t instr = 0;
    instr |= ((uint32_t(imm21_shifted >> 19) & 0x1) << 31);  // imm[20]
    instr |= ((uint32_t(imm21_shifted >> 0) & 0x3FF) << 21); // imm[10:1]
    instr |= ((uint32_t(imm21_shifted >> 10) & 0x1) << 20);  // imm[11]
    instr |= ((uint32_t(imm21_shifted >> 11) & 0xFF) << 12); // imm[19:12]
    return instr;
}

// For ISHIFT-type (RV64): shamt[5:0] in instr[25:20]
// Other bits (e.g. instr[31:26] for SRAI) are part of opcode/funct7
uint32_t instr_ishift_type(uint8_t shamt6, uint8_t fixed_upper_bits = 0) {
    // fixed_upper_bits would be 0b010000 for SRAI's instr[31:26]
    // For SLLI/SRLI it's 0b000000
    return (uint32_t(fixed_upper_bits & 0x3F) << 26) | (uint32_t(shamt6 & 0x3F) << 20);
}


struct ImmGenTestCase {
    std::string name;
    uint32_t    instruction_bits; // The full instruction word
    ImmediateTypeCpp imm_type;
    uint64_t    expected_imm_ext;
};

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vimmediate_generator_tb* top = new Vimmediate_generator_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_immediate_generator.vcd");

    std::cout << "Starting Immediate Generator Testbench" << std::endl;

    std::vector<ImmGenTestCase> test_cases = {
        // I-Type
        {"I-Type positive", instr_i_type(100), IMM_TYPE_I_CPP, 100},
        {"I-Type negative", instr_i_type(0xFFF), IMM_TYPE_I_CPP, 0xFFFFFFFFFFFFFFFFULL}, // -1 (12-bit 0xFFF)
        {"I-Type max pos", instr_i_type(0x7FF), IMM_TYPE_I_CPP, 0x7FF}, // 2047
        {"I-Type min neg", instr_i_type(0x800), IMM_TYPE_I_CPP, 0xFFFFFFFFFFFFF800ULL}, // -2048
        {"I-Type zero", instr_i_type(0), IMM_TYPE_I_CPP, 0},

        // S-Type
        {"S-Type positive", instr_s_type(200), IMM_TYPE_S_CPP, 200},
        {"S-Type negative", instr_s_type(0xF00), IMM_TYPE_S_CPP, 0xFFFFFFFFFFFFFF00ULL}, // -256 (0xF00 is 1111 0000 0000, sign bit is instr[31])
        {"S-Type max pos", instr_s_type(0x7FF), IMM_TYPE_S_CPP, 0x7FF},
        {"S-Type min neg", instr_s_type(0x800), IMM_TYPE_S_CPP, 0xFFFFFFFFFFFFF800ULL},

        // B-Type
        {"B-Type positive offset +20", instr_b_type(20), IMM_TYPE_B_CPP, 20},
        {"B-Type negative offset -20", instr_b_type(-20), IMM_TYPE_B_CPP, (uint64_t)-20},
        {"B-Type max pos offset (4094)", instr_b_type(4094), IMM_TYPE_B_CPP, 4094}, // 2^12 - 2
        {"B-Type min neg offset (-4096)", instr_b_type(-4096), IMM_TYPE_B_CPP, (uint64_t)-4096},

        // U-Type (imm is shifted left by 12 bits internally by LUI/AUIPC, generator outputs imm_val for bits 31:12, zero-extended lower)
        // The generator itself outputs {instr[31:12], 12'h0}, sign-extended from bit 31 of this 32-bit value.
        {"U-Type 0xABCD0", instr_u_type(0xABCD0), IMM_TYPE_U_CPP, 0xFFFFFFFFABCD0000ULL}, // A=1010, so MSB is 1
        {"U-Type 0x12345", instr_u_type(0x12345), IMM_TYPE_U_CPP, 0x0000000012345000ULL}, // MSB is 0
        {"U-Type 0x0", instr_u_type(0x0), IMM_TYPE_U_CPP, 0x0},
        {"U-Type max (0xFFFFF)", instr_u_type(0xFFFFF), IMM_TYPE_U_CPP, 0xFFFFFFFFFFFFF000ULL},

        // J-Type
        {"J-Type positive offset +2046", instr_j_type(2046), IMM_TYPE_J_CPP, 2046}, // Max positive for 11 bit field for example (2^11-2)
                                                                                   // J-imm is 21 bits, so 2^20 max offset
        {"J-Type negative offset -2048", instr_j_type(-2048), IMM_TYPE_J_CPP, (uint64_t)-2048},
        {"J-Type max pos offset (2^19-2)", instr_j_type((1<<19)-2), IMM_TYPE_J_CPP, (1ULL<<19)-2},
        {"J-Type min neg offset (-2^19)", instr_j_type(-(1<<19)), IMM_TYPE_J_CPP, (uint64_t)(-(1LL<<19))},

        // ISHIFT-Type (RV64 shamt is 6 bits, instr[25:20])
        {"ISHIFT shamt=1", instr_ishift_type(1), IMM_TYPE_ISHIFT_CPP, 1},
        {"ISHIFT shamt=31", instr_ishift_type(31), IMM_TYPE_ISHIFT_CPP, 31},
        {"ISHIFT shamt=63", instr_ishift_type(63), IMM_TYPE_ISHIFT_CPP, 63},
        {"ISHIFT shamt=0", instr_ishift_type(0), IMM_TYPE_ISHIFT_CPP, 0},
        {"ISHIFT (SRAI fixed bits)", instr_ishift_type(5, 0b010000), IMM_TYPE_ISHIFT_CPP, 5}, // Check shamt extraction part

        // IMM_TYPE_NONE
        {"None Type", 0, IMM_TYPE_NONE_CPP, 0},
    };

    int passed_count = 0;
    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name << std::endl;
        std::cout << "  Instruction Bits: 0x" << std::hex << tc.instruction_bits
                  << ", Type: " << (int)tc.imm_type << std::dec << std::endl;

        top->i_instr = tc.instruction_bits;
        top->i_imm_type_sel = static_cast<uint8_t>(tc.imm_type); // Cast enum to uint8_t for Verilator port

        eval_immgen(top, tfp);
        sim_time_immgen++; // Increment time for VCD for each test case

        bool current_pass = true;
        if (top->o_imm_ext != tc.expected_imm_ext) {
            std::cout << "  FAIL: Immediate Mismatch." << std::endl;
            std::cout << "    Expected: 0x" << std::hex << tc.expected_imm_ext << std::dec << std::endl;
            std::cout << "    Got:      0x" << std::hex << top->o_imm_ext << std::dec << std::endl;
            current_pass = false;
        }

        if (current_pass) {
            std::cout << "  PASS" << std::endl;
            passed_count++;
        } else {
            std::cout << "  FAILED" << std::endl;
        }
    }

    std::cout << "\nImmediate Generator Testbench Finished. Passed " << passed_count << "/" << test_cases.size() << " tests." << std::endl;

    if (tfp) tfp->close();
    delete top;
    return (passed_count == test_cases.size()) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/decode_tb.sv ---
// tests/unit/decode_tb.sv
`include "common/defines.svh"
`include "common/alu_defines.svh"          // For ALU_CONTROL_WIDTH
`include "common/control_signals_defines.svh" // For alu_a_src_sel_e, pc_target_src_sel_e

module decode_tb (
    input  logic clk,
    input  logic rst_n,

    // Inputs to control the test environment
    // To IF/ID register
    input  logic                       i_if_id_stall_d, // Stall for if_id register
    input  logic                       i_if_id_flush_d, // Flush for if_id register
    input  logic [`INSTR_WIDTH-1:0]    i_instr_f,       // Instruction from a virtual "fetch"
    input  logic [`DATA_WIDTH-1:0]     i_pc_f,          // PC from a virtual "fetch"
    input  logic [`DATA_WIDTH-1:0]     i_pc_plus_4_f,   // PC+4 from a virtual "fetch"

    // To Register File (for initialization during test, and Writeback simulation)
    input  logic                       i_wb_write_en,
    input  logic [`REG_ADDR_WIDTH-1:0] i_wb_rd_addr,
    input  logic [`DATA_WIDTH-1:0]     i_wb_rd_data,

    // Outputs from Decode stage (to observe)
    // Control Signals
    output logic       o_reg_write_d,
    output logic [1:0] o_result_src_d,
    output logic       o_mem_write_d,
    output logic       o_jump_d,
    output logic       o_branch_d,
    output logic       o_alu_src_d, // Selects ALU Operand B
    output logic [`ALU_CONTROL_WIDTH-1:0] o_alu_control_d,
    output logic [2:0] o_funct3_d,
    output alu_a_src_sel_e o_op_a_sel_d,
    output pc_target_src_sel_e o_pc_target_src_sel_d,

    // Data
    output logic [`DATA_WIDTH-1:0]  o_pc_d,
    output logic [`DATA_WIDTH-1:0]  o_pc_plus_4_d,
    output logic [`DATA_WIDTH-1:0]  o_rs1_data_d,
    output logic [`DATA_WIDTH-1:0]  o_rs2_data_d,
    output logic [`DATA_WIDTH-1:0]  o_imm_ext_d,

    // Register addresses
    output logic [`REG_ADDR_WIDTH-1:0] o_rs1_addr_d,
    output logic [`REG_ADDR_WIDTH-1:0] o_rs2_addr_d,
    output logic [`REG_ADDR_WIDTH-1:0] o_rd_addr_d,

    // Output from IF/ID for sanity check
    output logic [`INSTR_WIDTH-1:0]    o_instr_id,
    output logic [`DATA_WIDTH-1:0]     o_pc_id,
    output logic [`DATA_WIDTH-1:0]     o_pc_plus_4_id
);

    // Signals between IF/ID and Decode
    logic [`INSTR_WIDTH-1:0]    instr_id_val;
    logic [`DATA_WIDTH-1:0]     pc_id_val;
    logic [`DATA_WIDTH-1:0]     pc_plus_4_id_val;

    // IF/ID Register instance
    if_id_register u_if_id_reg (
        .clk            (clk),
        .rst_n          (rst_n),
        .stall_d        (i_if_id_stall_d),
        .flush_d        (i_if_id_flush_d),
        .instr_f_i      (i_instr_f),
        .pc_f_i         (i_pc_f),
        .pc_plus_4_f_i  (i_pc_plus_4_f),
        .instr_id_o     (instr_id_val),
        .pc_id_o        (pc_id_val),
        .pc_plus_4_id_o (pc_plus_4_id_val)
    );

    // Decode Stage instance
    decode u_decode (
        .clk                (clk),
        .rst_n              (rst_n),
        .instr_id_i         (instr_id_val),
        .pc_id_i            (pc_id_val),
        .pc_plus_4_id_i     (pc_plus_4_id_val),
        .rd_write_en_wb_i   (i_wb_write_en),
        .rd_addr_wb_i       (i_wb_rd_addr),
        .rd_data_wb_i       (i_wb_rd_data),

        .reg_write_d_o      (o_reg_write_d),
        .result_src_d_o     (o_result_src_d),
        .mem_write_d_o      (o_mem_write_d),
        .jump_d_o           (o_jump_d),
        .branch_d_o         (o_branch_d),
        .alu_src_d_o        (o_alu_src_d),
        .alu_control_d_o    (o_alu_control_d),
        .funct3_d_o         (o_funct3_d),
        .op_a_sel_d_o       (o_op_a_sel_d),
        .pc_target_src_sel_d_o (o_pc_target_src_sel_d),

        .pc_d_o             (o_pc_d),
        .pc_plus_4_d_o      (o_pc_plus_4_d),
        .rs1_data_d_o       (o_rs1_data_d),
        .rs2_data_d_o       (o_rs2_data_d),
        .imm_ext_d_o        (o_imm_ext_d),
        .rs1_addr_d_o       (o_rs1_addr_d),
        .rs2_addr_d_o       (o_rs2_addr_d),
        .rd_addr_d_o        (o_rd_addr_d)
    );

    // Assign IF/ID outputs for observation
    assign o_instr_id     = instr_id_val;
    assign o_pc_id        = pc_id_val;
    assign o_pc_plus_4_id = pc_plus_4_id_val;

endmodule


--- File: tests/unit/immediate_generator_tb.sv ---
`include "common/defines.svh"
`include "common/immediate_types.svh" // For immediate_type_e

module immediate_generator_tb (
    input  logic [`INSTR_WIDTH-1:0] i_instr,
    input  immediate_type_e         i_imm_type_sel,
    output logic [`DATA_WIDTH-1:0]  o_imm_ext
);

    immediate_generator u_immediate_generator (
        .instr_i        (i_instr),
        .imm_type_sel_i (i_imm_type_sel),
        .imm_ext_o      (o_imm_ext)
    );

endmodule


--- File: tests/unit/control_unit_tb.sv ---
`include "common/defines.svh"
`include "common/alu_defines.svh"
`include "common/immediate_types.svh"
`include "common/control_signals_defines.svh"

module control_unit_tb (
    // Inputs to control_unit
    input  logic [6:0] i_op,
    input  logic [2:0] i_funct3,
    input  logic       i_funct7_5,

    // Outputs from control_unit
    output logic       o_reg_write_d,
    output logic [1:0] o_result_src_d,
    output logic       o_mem_write_d,
    output logic       o_jump_d,
    output logic       o_branch_d,
    output logic       o_alu_src_d,
    output logic [`ALU_CONTROL_WIDTH-1:0] o_alu_control_d,
    output immediate_type_e o_imm_type_d,
    output logic [2:0] o_funct3_d,
    output alu_a_src_sel_e o_op_a_sel_d,
    output pc_target_src_sel_e o_pc_target_src_sel_d
);

    control_unit u_control_unit (
        .op                (i_op),
        .funct3            (i_funct3),
        .funct7_5          (i_funct7_5),

        .reg_write_d_o     (o_reg_write_d),
        .result_src_d_o    (o_result_src_d),
        .mem_write_d_o     (o_mem_write_d),
        .jump_d_o          (o_jump_d),
        .branch_d_o        (o_branch_d),
        .alu_src_d_o       (o_alu_src_d),
        .alu_control_d_o   (o_alu_control_d),
        .imm_type_d_o      (o_imm_type_d),
        .funct3_d_o        (o_funct3_d),
        .op_a_sel_d_o      (o_op_a_sel_d),
        .pc_target_src_sel_d_o (o_pc_target_src_sel_d)
    );

endmodule


--- File: tests/unit/execute_tb.sv ---
`include "common/defines.svh"
`include "common/alu_defines.svh"
`include "common/control_signals_defines.svh"

module execute_tb (
    input  logic clk, // Not strictly used by execute.sv's logic but good for TB
    input  logic rst_n, // Same as clk

    // Inputs to Execute Stage (simulating outputs of ID/EX register)
    input  logic       i_reg_write_e,
    input  logic [1:0] i_result_src_e,
    input  logic       i_mem_write_e,
    input  logic       i_jump_e,
    input  logic       i_branch_e,
    input  logic       i_alu_src_e, // Selects ALU Operand B
    input  logic [`ALU_CONTROL_WIDTH-1:0] i_alu_control_e,
    input  logic [2:0] i_funct3_e,          // Pipelined funct3
    input  alu_a_src_sel_e i_op_a_sel_e,    // Selects ALU Operand A's original source
    input  pc_target_src_sel_e i_pc_target_src_sel_e, // Selects PC Target calculation method

    input  logic [`DATA_WIDTH-1:0]  i_pc_e,
    input  logic [`DATA_WIDTH-1:0]  i_pc_plus_4_e,
    input  logic [`DATA_WIDTH-1:0]  i_rs1_data_e,   // Data from RF for Rs1 (before forwarding)
    input  logic [`DATA_WIDTH-1:0]  i_rs2_data_e,   // Data from RF for Rs2 (before forwarding)
    input  logic [`DATA_WIDTH-1:0]  i_imm_ext_e,
    input  logic [`REG_ADDR_WIDTH-1:0] i_rd_addr_e,

    // Forwarding inputs
    input  logic [`DATA_WIDTH-1:0]     i_forward_data_mem, // Data from MEM stage output for forwarding
    input  logic [`DATA_WIDTH-1:0]     i_forward_data_wb,  // Data from WB stage output for forwarding
    input  logic [1:0]                 i_forward_a_e,      // Control for OpA forwarding MUX
    input  logic [1:0]                 i_forward_b_e,      // Control for OpB forwarding MUX

    // Outputs from Execute stage (these would go to EX/MEM register)
    output logic       o_reg_write_m,
    output logic [1:0] o_result_src_m,
    output logic       o_mem_write_m,
    output logic [`DATA_WIDTH-1:0] o_alu_result_m,
    output logic [`DATA_WIDTH-1:0] o_rs2_data_m,    // Original rs2_data_e passed through (for SW)
    output logic [`REG_ADDR_WIDTH-1:0] o_rd_addr_m,
    output logic [`DATA_WIDTH-1:0] o_pc_plus_4_m,
    output logic [2:0] o_funct3_m,          // Pipelined funct3 passed through

    // Outputs from Execute stage that affect PC update
    output logic       o_pc_src_e,           // PCSrcE: 1 if branch/jump taken
    output logic [`DATA_WIDTH-1:0] o_pc_target_addr_e // PCTargetE: target address
);

    execute u_execute (
        // .clk            (clk), // Not used internally by current execute.sv
        // .rst_n          (rst_n), // Not used internally

        .reg_write_e_i  (i_reg_write_e),
        .result_src_e_i (i_result_src_e),
        .mem_write_e_i  (i_mem_write_e),
        .jump_e_i       (i_jump_e),
        .branch_e_i     (i_branch_e),
        .alu_src_e_i    (i_alu_src_e),
        .alu_control_e_i(i_alu_control_e),
        .funct3_e_i     (i_funct3_e),
        .op_a_sel_e_i   (i_op_a_sel_e),
        .pc_target_src_sel_e_i (i_pc_target_src_sel_e),
        .pc_e_i         (i_pc_e),
        .pc_plus_4_e_i  (i_pc_plus_4_e),
        .rs1_data_e_i   (i_rs1_data_e),
        .rs2_data_e_i   (i_rs2_data_e),
        .imm_ext_e_i    (i_imm_ext_e),
        .rd_addr_e_i    (i_rd_addr_e),

        .forward_data_mem_i (i_forward_data_mem),
        .forward_data_wb_i  (i_forward_data_wb),
        .forward_a_e_i  (i_forward_a_e),
        .forward_b_e_i  (i_forward_b_e),

        .reg_write_m_o  (o_reg_write_m),
        .result_src_m_o (o_result_src_m),
        .mem_write_m_o  (o_mem_write_m),
        .alu_result_m_o (o_alu_result_m),
        .rs2_data_m_o   (o_rs2_data_m),
        .rd_addr_m_o    (o_rd_addr_m),
        .pc_plus_4_m_o  (o_pc_plus_4_m),
        .funct3_m_o     (o_funct3_m),
        .pc_src_e_o     (o_pc_src_e),
        .pc_target_addr_e_o (o_pc_target_addr_e)
    );

endmodule


--- File: tests/unit/fetch_tb.cpp ---
#include "Vfetch_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>

// В defines.svh INSTR_WIDTH = 32, DATA_WIDTH = 64
const uint32_t NOP_INSTRUCTION = 0x00000013;

vluint64_t sim_time = 0;

void tick(Vfetch_tb* dut, VerilatedVcdC* tfp) {
    dut->clk = 0;
    dut->eval();
    if (tfp) tfp->dump(sim_time);
    sim_time++;

    dut->clk = 1;
    dut->eval();
    if (tfp) tfp->dump(sim_time);
    sim_time++;
}

void reset_dut(Vfetch_tb* dut, VerilatedVcdC* tfp) {
    dut->rst_n = 0;
    // Initialize inputs to known safe values during reset
    dut->i_stall_f = 0;
    dut->i_pc_src_e = 0;
    dut->i_pc_target_e = 0;
    dut->i_stall_d = 0;
    dut->i_flush_d = 0;
    for (int i = 0; i < 5; ++i) { // Hold reset for a few cycles
        tick(dut, tfp);
    }
    dut->rst_n = 1;
    tick(dut, tfp); // One tick out of reset
    std::cout << "DUT Reset" << std::endl;
}


int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vfetch_tb* top = new Vfetch_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_fetch.vcd");

    std::cout << "Starting Fetch Stage Testbench" << std::endl;

    reset_dut(top, tfp);

    // Test Case 1: Basic sequential fetch
    std::cout << "Test Case 1: Sequential Fetch" << std::endl;
    top->i_stall_f = 0;
    top->i_pc_src_e = 0;
    top->i_pc_target_e = 0; // Don't care
    top->i_stall_d = 0;
    top->i_flush_d = 0;

    // Cycle 1: PC=0, Fetch instr @0. IF/ID gets this after this cycle.
    tick(top, tfp);
    std::cout << "  PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected after reset and first tick: PC_F=0. IF/ID output still from reset state or previous garbage before first valid data.
    // After PC=0 is fetched, on the NEXT rising edge, IF/ID will latch PC=0 and Instr @0.

    // Cycle 2: PC=0 latched into IF/ID. Fetch stage moves to PC=4.
    tick(top, tfp);
    std::cout << "  PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=4. IF/ID PC=0, Instr = mem[0] (0x00100093)

    // Cycle 3: PC=4 latched into IF/ID. Fetch stage moves to PC=8.
    tick(top, tfp);
    std::cout << "  PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=8. IF/ID PC=4, Instr = mem[1] (0x00200113)


    // Test Case 2: Stall Fetch (StallF)
    std::cout << "\nTest Case 2: Stall Fetch (stall_f)" << std::endl;
    top->i_stall_f = 1; // Stall PC update
    top->i_stall_d = 0; // IF/ID register loads normally
    // PC_F was 8. It should remain 8. Instr_F will be from PC=8.
    // IF/ID will latch current Instr_F and PC_F+4.
    // Previous IF/ID instr was mem[1] (from PC=4).
    tick(top, tfp); // PC=8 (stalled), instr_f = mem[8/4=2]. IF/ID gets (instr @ PC=8, PC=8+4)
    std::cout << "  StallF=1. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=8. IF/ID PC=8, Instr = mem[2] (0x00308193)

    tick(top, tfp); // PC=8 (still stalled), instr_f = mem[8/4=2]. IF/ID re-latches same values.
    std::cout << "  StallF=1. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=8. IF/ID PC=8, Instr = mem[2]

    top->i_stall_f = 0; // Release stall_f


    // Test Case 3: Stall Decode (StallD)
    std::cout << "\nTest Case 3: Stall Decode (stall_d)" << std::endl;
    // PC_F was 8. Now stall_f=0, so PC will advance to 12. instr_f = mem[12/4=3].
    // IF/ID was (PC=8, instr=mem[2]). Now stall_d=1, so IF/ID holds its value.
    top->i_stall_d = 1;
    tick(top, tfp);
    std::cout << "  StallD=1. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=12 (0xC). IF/ID PC=8, Instr = mem[2] (holds previous)

    // PC_F advances to 16. instr_f = mem[16/4=4].
    // IF/ID still holds (PC=8, instr=mem[2]).
    tick(top, tfp);
    std::cout << "  StallD=1. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=16 (0x10). IF/ID PC=8, Instr = mem[2]

    top->i_stall_d = 0; // Release stall_d


    // Test Case 4: Flush Decode (FlushD)
    std::cout << "\nTest Case 4: Flush Decode (flush_d)" << std::endl;
    // PC_F was 16. Now stall_d=0, PC advances to 20. instr_f = mem[20/4=5].
    // IF/ID was (PC=8, instr=mem[2]). Now flush_d=1. IF/ID should be NOP.
    top->i_flush_d = 1;
    tick(top, tfp);
    std::cout << "  FlushD=1. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=20 (0x14). IF/ID PC=0, Instr = NOP (0x13)

    top->i_flush_d = 0; // Release flush_d
    tick(top, tfp); // PC_F advances to 24. IF/ID gets (instr @ PC=20, PC=20+4)
    std::cout << "  FlushD=0. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=24 (0x18). IF/ID PC=20, Instr = mem[5]

    // Test Case 5: Branch Taken (pc_src_e)
    std::cout << "\nTest Case 5: Branch Taken" << std::endl;
    top->i_pc_src_e = 1;
    top->i_pc_target_e = 0x100; // Jump to address 0x100
    // PC_F was 24. Next PC should be 0x100. instr_f will be mem[0x100/4].
    // IF/ID was (PC=20, instr=mem[5]). IF/ID gets (instr @ PC=0x100, PC=0x100+4)
    tick(top, tfp);
    std::cout << "  Branch. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=0x100. IF/ID PC=0x100, Instr = mem[0x100/4] (which is NOP by default init)

    top->i_pc_src_e = 0; // Next cycle, no branch
    tick(top, tfp); // PC_F advances to 0x104. IF/ID gets (instr @ PC=0x100, PC=0x100+4)
    std::cout << "  After Branch. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=0x104. IF/ID PC=0x100, Instr = mem[0x100/4]


    std::cout << "\nFetch Stage Testbench Finished." << std::endl;

    if (tfp) tfp->close();
    delete top;
    return 0;
}


--- File: tests/unit/data_memory_tb.cpp ---
// tests/unit/data_memory_tb.cpp
#include "Vdata_memory_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <bitset>
#include <cstdint>
#include <vector>
#include <string>

// Funct3 codes for LOAD/STORE (из common/riscv_opcodes.svh)
const uint8_t FUNCT3_LB_CPP  = 0b000;
const uint8_t FUNCT3_LH_CPP  = 0b001;
const uint8_t FUNCT3_LW_CPP  = 0b010;
const uint8_t FUNCT3_LD_CPP  = 0b011;
const uint8_t FUNCT3_LBU_CPP = 0b100;
const uint8_t FUNCT3_LHU_CPP = 0b101;
const uint8_t FUNCT3_LWU_CPP = 0b110;

const uint8_t FUNCT3_SB_CPP  = 0b000;
const uint8_t FUNCT3_SH_CPP  = 0b001;
const uint8_t FUNCT3_SW_CPP  = 0b010;
const uint8_t FUNCT3_SD_CPP  = 0b011;


vluint64_t sim_time_dmem = 0;

void tick_dmem(Vdata_memory_tb* dut, VerilatedVcdC* tfp) {
    // Память синхронная по записи, комбинационная по чтению (но зависит от clk для записи)
    // Поэтому тактируем
    dut->clk = 0;
    dut->eval();
    if (tfp) tfp->dump(sim_time_dmem);
    sim_time_dmem++;

    dut->clk = 1;
    dut->eval(); // Запись происходит на posedge clk
    if (tfp) tfp->dump(sim_time_dmem);
    sim_time_dmem++;
}


void reset_dmem(Vdata_memory_tb* dut, VerilatedVcdC* tfp) {
    dut->rst_n = 0;
    dut->i_addr = 0;
    dut->i_write_data = 0;
    dut->i_mem_write_en = 0;
    dut->i_funct3 = 0;
    // Держим ресет несколько тактов
    for(int i=0; i<5; ++i) {
        tick_dmem(dut, tfp);
    }
    dut->rst_n = 1;
    tick_dmem(dut, tfp); // Один такт после снятия ресета
    std::cout << "DUT Data Memory Reset" << std::endl;
}

struct DmemTestCase {
    std::string name;
    // Действия: "WRITE" или "READ"
    std::string action;
    uint64_t    address;
    uint8_t     funct3;
    uint64_t    write_data; // Используется для WRITE
    bool        mem_write_en;

    // Ожидания (только для READ)
    uint64_t    expected_read_data;
    bool        check_read_data; // true, если нужно проверять прочитанные данные
};


int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vdata_memory_tb* top = new Vdata_memory_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_data_memory.vcd");

    std::cout << "Starting Data Memory Testbench" << std::endl;

    reset_dmem(top, tfp);

    std::vector<DmemTestCase> test_cases = {
        // Test SB (Store Byte) then LB (Load Byte Signed)
        {"Write Byte 0xAA to 0x00", "WRITE", 0x00, FUNCT3_SB_CPP, 0xAA, true, 0, false},
        {"Read Byte from 0x00 (signed AA)", "READ", 0x00, FUNCT3_LB_CPP, 0, false, 0xFFFFFFFFFFFFFFAAULL, true},
        {"Write Byte 0x55 to 0x01", "WRITE", 0x01, FUNCT3_SB_CPP, 0x55, true, 0, false},
        {"Read Byte from 0x01 (signed 55)", "READ", 0x01, FUNCT3_LB_CPP, 0, false, 0x55, true},

        // Test SH (Store Half) then LH (Load Half Signed) / LHU (Load Half Unsigned)
        {"Write Half 0xCCBB to 0x04", "WRITE", 0x04, FUNCT3_SH_CPP, 0xCCBB, true, 0, false},
        {"Read Half from 0x04 (signed CCBB)", "READ", 0x04, FUNCT3_LH_CPP, 0, false, 0xFFFFFFFFFFFFCCBBULL, true},
        {"Read Half from 0x04 (unsigned CCBB)", "READ", 0x04, FUNCT3_LHU_CPP, 0, false, 0xCCBB, true},
        {"Write Half 0x3344 to 0x0A", "WRITE", 0x0A, FUNCT3_SH_CPP, 0x3344, true, 0, false},
        {"Read Half from 0x0A (signed 3344)", "READ", 0x0A, FUNCT3_LH_CPP, 0, false, 0x3344, true},

        // Test SW (Store Word) then LW (Load Word Signed) / LWU (Load Word Unsigned)
        {"Write Word 0x87654321 to 0x10", "WRITE", 0x10, FUNCT3_SW_CPP, 0x87654321, true, 0, false},
        {"Read Word from 0x10 (signed)", "READ", 0x10, FUNCT3_LW_CPP, 0, false, 0xFFFFFFFF87654321ULL, true},
        {"Read Word from 0x10 (unsigned)", "READ", 0x10, FUNCT3_LWU_CPP, 0, false, 0x87654321, true},

        // Test SD (Store Double) then LD (Load Double)
        {"Write Double 0x1122334455667788 to 0x20", "WRITE", 0x20, FUNCT3_SD_CPP, 0x1122334455667788ULL, true, 0, false},
        {"Read Double from 0x20", "READ", 0x20, FUNCT3_LD_CPP, 0, false, 0x1122334455667788ULL, true},

        // Test LBU (Load Byte Unsigned)
        {"Write Byte 0xDD to 0x02", "WRITE", 0x02, FUNCT3_SB_CPP, 0xDD, true, 0, false},
        {"Read Byte from 0x02 (unsigned DD)", "READ", 0x02, FUNCT3_LBU_CPP, 0, false, 0xDD, true},

        // Test read from unwritten location (should be 0 after reset)
        {"Read from unwritten (0x100)", "READ", 0x100, FUNCT3_LD_CPP, 0, false, 0x00, true},

        // Test write disabled
        {"Attempt Write Byte 0xFF to 0x30 (Write Disabled)", "WRITE", 0x30, FUNCT3_SB_CPP, 0xFF, false, 0, false}, // mem_write_en = false
        {"Read Byte from 0x30 (should be 0)", "READ", 0x30, FUNCT3_LB_CPP, 0, false, 0x00, true}, // Expect 0 (or prev value if not reset)

        // Testfunct3 mismatch on write (should still write based on size)
        // The funct3 is mainly for size on store, and size+sign on load.
        {"Write Byte 0xEE to 0x40 (funct3=SD, but SB behavior)", "WRITE", 0x40, FUNCT3_SD_CPP /* Mismatched funct3, but size is SB */, 0xEE, true, 0, false}, // This test is tricky. Store ops only use funct3 for size.
                                                                                                                                                   // Let's make a specific SD then read it as byte
        {"Write Double 0x12345678ABCDEF01 to 0x50", "WRITE", 0x50, FUNCT3_SD_CPP, 0x12345678ABCDEF01ULL, true, 0, false},
        {"Read Byte from 0x50 (LSB of double)", "READ", 0x50, FUNCT3_LB_CPP, 0, false, 0x01, true} // Assuming Little Endian for byte order
    };

    int passed_count = 0;
    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name << std::endl;
        std::cout << "  Action: " << tc.action
                  << ", Address: 0x" << std::hex << tc.address
                  << ", Funct3: 0b" << std::bitset<3>(tc.funct3) << std::dec;
        if (tc.action == "WRITE") {
            std::cout << ", WriteData: 0x" << std::hex << tc.write_data << std::dec;
        }
        std::cout << ", MemWriteEn: " << tc.mem_write_en << std::endl;

        top->i_addr = tc.address;
        top->i_funct3 = tc.funct3;
        top->i_mem_write_en = tc.mem_write_en;
        if (tc.action == "WRITE") {
            top->i_write_data = tc.write_data;
        } else {
            top->i_write_data = 0; // Don't care for read
        }

        // For WRITE, data is written on posedge. For READ, output is combinational.
        // We tick once to ensure any synchronous write happens.
        // Then, for READs, the output o_read_data should be valid after eval.
        if (tc.action == "WRITE") {
            tick_dmem(top, tfp); // This will apply write on posedge clk
        } else { // READ
            // For read, the output is combinational. One eval after setting address should be enough.
            // But to keep VCD clean and have a "moment" of read:
            top->clk = 0; top->eval(); if(tfp) tfp->dump(sim_time_dmem); // Set address
            sim_time_dmem++;
            top->clk = 1; top->eval(); if(tfp) tfp->dump(sim_time_dmem); // Read output is stable
            sim_time_dmem++;
        }


        bool current_pass = true;
        if (tc.action == "READ" && tc.check_read_data) {
            if (top->o_read_data != tc.expected_read_data) {
                std::cout << "  FAIL: Read Data Mismatch." << std::endl;
                std::cout << "    Expected: 0x" << std::hex << tc.expected_read_data << std::dec << std::endl;
                std::cout << "    Got:      0x" << std::hex << top->o_read_data << std::dec << std::endl;
                current_pass = false;
            }
        }

        if (current_pass) {
            std::cout << "  PASS" << std::endl;
            passed_count++;
        } else {
            std::cout << "  FAILED" << std::endl;
        }
    }

    std::cout << "\nData Memory Testbench Finished. Passed " << passed_count << "/" << test_cases.size() << " tests." << std::endl;

    if (tfp) tfp->close();
    delete top;
    return (passed_count == test_cases.size()) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/register_file_tb.cpp ---
// tests/unit/register_file_tb.cpp
#include "Vregister_file_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <string>

vluint64_t sim_time_regfile = 0;

// Определяем один полный тактовый цикл: negedge -> posedge
// Чтение происходит на negedge, запись на posedge.
void step_clk_regfile(Vregister_file_tb* dut, VerilatedVcdC* tfp) {
    // ---- ФАЗА 1: CLK LOW (negedge) ----
    dut->clk = 0;
    dut->eval(); // Обновляются выходы RF (rs1_data_o, rs2_data_o) на основе адресов, поданных до этого
    if (tfp) tfp->dump(sim_time_regfile);
    sim_time_regfile++;

    // ---- ФАЗА 2: CLK HIGH (posedge) ----
    dut->clk = 1;
    dut->eval(); // Происходит запись в RF, если rd_write_en_wb_i активен
    if (tfp) tfp->dump(sim_time_regfile);
    sim_time_regfile++;
}

void reset_regfile(Vregister_file_tb* dut, VerilatedVcdC* tfp) {
    dut->rst_n = 0;
    // Установить входы в безопасное состояние во время сброса
    dut->i_rs1_addr = 0;
    dut->i_rs2_addr = 0;
    dut->i_rd_write_en_wb = 0;
    dut->i_rd_addr_wb = 0;
    dut->i_rd_data_wb = 0;

    // Пропустить несколько тактов с активным сбросом
    for (int i = 0; i < 3; ++i) {
        step_clk_regfile(dut, tfp);
    }
    dut->rst_n = 1;
    dut->eval(); // Применить rst_n = 1
    step_clk_regfile(dut, tfp); // Один такт после снятия сброса для стабилизации
    std::cout << "DUT Register File Reset" << std::endl;
}

struct RegFileTestCase {
    std::string name;
    // Действия перед проверкой чтения (могут быть множественные записи)
    std::vector<std::tuple<uint8_t, uint64_t, bool>> writes_before_read; // rd_addr, rd_data, write_enable

    // Адреса для чтения
    uint8_t  rs1_addr_check;
    uint8_t  rs2_addr_check;

    // Ожидаемые данные чтения (после всех записей и одного negedge для чтения)
    uint64_t expected_rs1_data;
    uint64_t expected_rs2_data;
};


int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vregister_file_tb* top = new Vregister_file_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_register_file.vcd");

    std::cout << "Starting Register File Testbench" << std::endl;

    std::vector<RegFileTestCase> test_cases = {
        {
            "Reset Check (Read x1, x2 after reset)",
            {}, // No writes
            1, 2, 0x0, 0x0 // Expect 0 from x1, x2 after reset
        },
        {
            "Write x1, Read x1",
            {{1, 0xABCD, true}}, // Write 0xABCD to x1
            1, 0, 0xABCD, 0x0 // Read x1, read x0
        },
        {
            "Write x5, x10; Read x5, x10",
            {{5, 0x12345, true}, {10, 0x6789A, true}},
            5, 10, 0x12345, 0x6789A
        },
        {
            "Write x0 (ignored), Read x0, x1",
            {{0, 0xFFFF, true}, {1, 0x1111, true}}, // Attempt write to x0
            0, 1, 0x0, 0x1111 // Expect x0=0, x1=0x1111
        },
        {
            "Write Disabled, Read x3",
            {{3, 0xBAD, false}}, // Write disabled
            3, 0, 0x0, 0x0 // Expect x3 to be 0 (from reset)
        },
        {
            "Sequential Writes to same reg, Read last",
            {{2, 0x100, true}, {2, 0x200, true}},
            2, 0, 0x200, 0x0
        },
        {
            "Read two different written regs",
            {{7, 0x777, true}, {15, 0xFFF, true}},
            7, 15, 0x777, 0xFFF
        },
        // // Тест на "запись в первой половине, чтение во второй" (write x1, read x1 in same conceptual cycle)
        // // В нашем RF: запись по posedge, чтение по negedge.
        // // Если мы выставим write_en, rd_addr, rd_data И rs1_addr (равный rd_addr) одновременно,
        // // то на negedge этого же такта мы прочитаем СТАРОЕ значение,
        // // а новое будет записано на posedge.
        // // Чтобы прочитать НОВОЕ значение, нужен следующий negedge.
        {
            "Write x1 (valA), then setup read x1, check old val, then check new val",
            {{1, 0xAAAA, true}}, // x1 = 0xAAAA after this set of operations + 1st tick
            1, 0, 0xAAAA, 0 // Прочитаем 0xAAAA на negedge после записи
        }
        // // Более сложный тест для read-during-write:
        // // 1. Записать начальное значение в x1 (e.g. 0x1111)
        // // 2. В одном такте: настроить запись нового значения в x1 (e.g. 0x2222) И настроить чтение x1
        // // 3. На negedge этого такта, o_rs1_data должно быть 0x1111 (старое).
        // // 4. На следующем negedge, o_rs1_data должно быть 0x2222 (новое).
    };


    int passed_count = 0;
    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name << std::endl;
        reset_regfile(top, tfp); // Сбрасываем RF перед каждым набором операций

        // Выполняем предварительные записи
        for (const auto& write_op : tc.writes_before_read) {
            top->i_rd_addr_wb = std::get<0>(write_op);
            top->i_rd_data_wb = std::get<1>(write_op);
            top->i_rd_write_en_wb = std::get<2>(write_op);
            std::cout << "  Setup Write: Addr=" << (int)top->i_rd_addr_wb
                      << ", Data=0x" << std::hex << top->i_rd_data_wb
                      << ", WE=" << (int)top->i_rd_write_en_wb << std::dec << std::endl;
            step_clk_regfile(top, tfp); // Запись происходит на posedge этого такта
        }
        // Сбрасываем сигналы записи после всех операций записи, чтобы они не влияли на чтение
        top->i_rd_write_en_wb = 0;
        top->i_rd_addr_wb = 0; // Можно не сбрасывать, если write_en=0
        top->i_rd_data_wb = 0; // Можно не сбрасывать

        // Устанавливаем адреса для чтения
        top->i_rs1_addr = tc.rs1_addr_check;
        top->i_rs2_addr = tc.rs2_addr_check;
        std::cout << "  Setup Read: rs1_addr=" << (int)top->i_rs1_addr
                  << ", rs2_addr=" << (int)top->i_rs2_addr << std::endl;

        // Данные чтения будут доступны на выходах o_rs1_data, o_rs2_data
        // ПОСЛЕ negedge следующего тактового импульса (или текущего, если адреса уже были установлены).
        // Сделаем один полный такт, чтобы чтение по negedge произошло.
        step_clk_regfile(top, tfp);
        // После этого step_clk_regfile, на выходах o_rs1_data и o_rs2_data должны быть актуальные значения

        bool current_pass = true;
        if (top->o_rs1_data != tc.expected_rs1_data) {
            std::cout << "  FAIL: RS1 Data Mismatch." << std::endl;
            std::cout << "    rs1_addr=" << (int)tc.rs1_addr_check << std::endl;
            std::cout << "    Expected: 0x" << std::hex << tc.expected_rs1_data << std::dec << std::endl;
            std::cout << "    Got:      0x" << std::hex << top->o_rs1_data << std::dec << std::endl;
            current_pass = false;
        }
        if (top->o_rs2_data != tc.expected_rs2_data) {
            std::cout << "  FAIL: RS2 Data Mismatch." << std::endl;
            std::cout << "    rs2_addr=" << (int)tc.rs2_addr_check << std::endl;
            std::cout << "    Expected: 0x" << std::hex << tc.expected_rs2_data << std::dec << std::endl;
            std::cout << "    Got:      0x" << std::hex << top->o_rs2_data << std::dec << std::endl;
            current_pass = false;
        }

        if (current_pass) {
            std::cout << "  PASS" << std::endl;
            passed_count++;
        } else {
            std::cout << "  FAILED" << std::endl;
        }
    }
     // Тест на чтение во время записи (read-during-write)
    std::cout << "\nRunning Test: Read-during-write x1" << std::endl;
    reset_regfile(top, tfp);
    // 1. Записать начальное значение в x1
    top->i_rd_addr_wb = 1; top->i_rd_data_wb = 0x1111; top->i_rd_write_en_wb = 1;
    step_clk_regfile(top, tfp); // x1 = 0x1111
    top->i_rd_write_en_wb = 0; // Снять WE

    // 2. Настроить чтение x1 и одновременно запись нового значения в x1
    top->i_rs1_addr = 1; // Читаем x1
    top->i_rs2_addr = 0; // Читаем x0
    top->i_rd_addr_wb = 1; // Пишем в x1
    top->i_rd_data_wb = 0x2222; // Новое значение
    top->i_rd_write_en_wb = 1;  // Разрешить запись

    // 3. Первый такт после установки:
    // clk=0 (negedge): rs1_data_o читает значение *до* записи 0x2222. Должно быть 0x1111.
    // clk=1 (posedge): 0x2222 записывается в regs[1].
    top->clk = 0; top->eval(); if(tfp) tfp->dump(sim_time_regfile); sim_time_regfile++;
    bool pass_rdw1 = (top->o_rs1_data == 0x1111);
    std::cout << "  Read-during-write (cycle 1 negedge): rs1_addr=1, read_data=0x" << std::hex << top->o_rs1_data << ". Expected 0x1111." << std::dec << std::endl;

    top->clk = 1; top->eval(); if(tfp) tfp->dump(sim_time_regfile); sim_time_regfile++;
    // Запись 0x2222 произошла

    top->i_rd_write_en_wb = 0; // Снять WE для следующего чтения

    // 4. Второй такт:
    // clk=0 (negedge): rs1_data_o читает новое значение 0x2222.
    top->clk = 0; top->eval(); if(tfp) tfp->dump(sim_time_regfile); sim_time_regfile++;
    bool pass_rdw2 = (top->o_rs1_data == 0x2222);
    std::cout << "  Read-during-write (cycle 2 negedge): rs1_addr=1, read_data=0x" << std::hex << top->o_rs1_data << ". Expected 0x2222." << std::dec << std::endl;

    top->clk = 1; top->eval(); if(tfp) tfp->dump(sim_time_regfile); sim_time_regfile++;


    if (pass_rdw1 && pass_rdw2) {
        std::cout << "  Read-during-write: PASS" << std::endl;
        passed_count++;
        test_cases.emplace_back(); // "Фиктивный" успешный тест для общего счетчика
    } else {
        std::cout << "  Read-during-write: FAILED" << std::endl;
        test_cases.emplace_back(); // "Фиктивный" проваленный тест
    }


    std::cout << "\nRegister File Testbench Finished. Passed " << passed_count << "/" << test_cases.size() << " tests." << std::endl;

    if (tfp) tfp->close();
    delete top;
    return (passed_count == test_cases.size()) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/pipeline_control_tb.cpp ---
// tests/unit/pipeline_control_tb.cpp
#include "Vpipeline_control_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <string>
#include <bitset>

// Define ResultSrc values for clarity (matching control_unit logic)
const uint8_t RESULT_SRC_ALU_CPP    = 0b00;
const uint8_t RESULT_SRC_MEM_CPP    = 0b01; // Indicates a Load instruction for Load-Use Hazard
const uint8_t RESULT_SRC_PC_PLUS4_CPP = 0b10;

// Define Forwarding codes for clarity (matching pipeline_control hazard unit logic)
const uint8_t FORWARD_NONE_CPP   = 0b00;
const uint8_t FORWARD_MEM_WB_CPP = 0b01; // From MEM/WB (RdW) -> EX (was value for RdW)
const uint8_t FORWARD_EX_MEM_CPP = 0b10; // From EX/MEM (RdM) -> EX (was value for RdM)


vluint64_t sim_time_pc = 0; // Pipeline Control sim time

void eval_pc(Vpipeline_control_tb* dut, VerilatedVcdC* tfp) {
    dut->eval();
    if (tfp) {
        tfp->dump(sim_time_pc);
    }
    // sim_time_pc++; // For combinational, advance time per test case
}

struct PCTestCase {
    std::string name;
    // Inputs from Decode (IF/ID outputs)
    uint8_t rs1_addr_d;
    uint8_t rs2_addr_d;
    // Inputs from Execute (ID/EX outputs)
    uint8_t rd_addr_e;
    bool    reg_write_e;
    uint8_t result_src_e; // To detect Load for Load-Use
    // Inputs from Memory (EX/MEM outputs)
    uint8_t rd_addr_m;
    bool    reg_write_m;
    // Inputs from Writeback (MEM/WB outputs)
    uint8_t rd_addr_w;
    bool    reg_write_w;
    // Control input
    bool    pc_src_e; // Branch/Jump taken in EX

    // Expected Outputs
    bool    exp_stall_f;
    bool    exp_stall_d;
    bool    exp_flush_d;
    bool    exp_flush_e;
    uint8_t exp_forward_a_e; // 2 bits
    uint8_t exp_forward_b_e; // 2 bits
};

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vpipeline_control_tb* top = new Vpipeline_control_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_pipeline_control.vcd");

    std::cout << "Starting Pipeline Control (Hazard Unit) Testbench" << std::endl;

    std::vector<PCTestCase> test_cases = {
        // --- No Hazards ---
        {"No Hazard",
            1, 2, // rs1D, rs2D
            3, true, RESULT_SRC_ALU_CPP, // rdE, RegWE, ResultSrcE (ALU op)
            4, true,           // rdM, RegWriteM
            5, true,           // rdW, RegWriteW
            false,             // pc_src_e
            false, false, false, false, FORWARD_NONE_CPP, FORWARD_NONE_CPP // Expected outputs
        },

        // --- Load-Use Hazard ---
        {"Load-Use rs1D == RdE",
            3, 2, // rs1D=3, rs2D=2
            3, true, RESULT_SRC_MEM_CPP, // EX is LW x3, ...
            4, false,          // No conflict from MEM
            5, false,          // No conflict from WB
            false,             // No branch
            true, true, false, true, FORWARD_NONE_CPP, FORWARD_NONE_CPP // StallF, StallD, FlushE
        },
        {"Load-Use rs2D == RdE",
            1, 3, // rs1D=1, rs2D=3
            3, true, RESULT_SRC_MEM_CPP, // EX is LW x3, ...
            4, false, 5, false, false,
            true, true, false, true, FORWARD_NONE_CPP, FORWARD_NONE_CPP
        },
        {"Load-Use rs1D==RdE, rs2D==RdE",
            3, 3, 3, true, RESULT_SRC_MEM_CPP, 4, false, 5, false, false,
            true, true, false, true, FORWARD_NONE_CPP, FORWARD_NONE_CPP
        },
        {"Load-Use, but RdE = x0",
            1, 2, 0, true, RESULT_SRC_MEM_CPP, 4, false, 5, false, false, // RdE = 0
            false, false, false, false, FORWARD_NONE_CPP, FORWARD_NONE_CPP // No stall
        },
        {"Load-Use, but RegWriteE=false (not typical for Load)",
            3, 2, 3, false,RESULT_SRC_MEM_CPP, 4, false, 5, false, false, // RegWriteE = false
            false, false, false, false, FORWARD_NONE_CPP, FORWARD_NONE_CPP // No stall
        },
        // {"Not a Load in EX, rs1D == RdE (should forward, not stall)",
        //     3, 2, 3, true, RESULT_SRC_ALU_CPP, // EX is ALU op to x3
        //     4, false, 5, false, false,
        //     false, false, false, false, FORWARD_EX_MEM_CPP /*Incorrect expectation: this is for RdM*/, FORWARD_NONE_CPP
        //     // Corrected expectation: If RdE is from current EX, it's not ready for forwarding by this unit.
        //     // This unit forwards from MEM and WB. If RdE is a hazard, it means previous cycle (now in MEM).
        //     // So, for this case, we test forwarding from MEM stage.
        //     // The test "EX/MEM Fwd A (RdM==Rs1D)" covers this. This specific case is redundant or needs clarification.
        //     // For now, let's assume the test below handles this.
        // },

        // --- Data Forwarding from EX/MEM (RdM) ---
        {"EX/MEM Fwd A (RdM==Rs1D)",
            3, 2, // rs1D=3
            10, false, RESULT_SRC_ALU_CPP, // No conflict from EX stage itself
            3, true,           // Instr in MEM writes to x3
            5, false,          // No conflict from WB
            false,
            false, false, false, false, FORWARD_EX_MEM_CPP, FORWARD_NONE_CPP
        },
        {"EX/MEM Fwd B (RdM==Rs2D)",
            1, 3, 10, false, RESULT_SRC_ALU_CPP, 3, true, 5, false, false,
            false, false, false, false, FORWARD_NONE_CPP, FORWARD_EX_MEM_CPP
        },
        {"EX/MEM Fwd A & B (RdM==Rs1D, RdM==Rs2D)",
            3, 3, 10, false, RESULT_SRC_ALU_CPP, 3, true, 5, false, false,
            false, false, false, false, FORWARD_EX_MEM_CPP, FORWARD_EX_MEM_CPP
        },
        {"EX/MEM Fwd A, RdM=x0",
            0, 2, 10, false, RESULT_SRC_ALU_CPP, 0, true, 5, false, false,
            false, false, false, false, FORWARD_NONE_CPP, FORWARD_NONE_CPP // No fwd from x0
        },
        {"EX/MEM Fwd A, RegWriteM=false",
            3, 2, 10, false, RESULT_SRC_ALU_CPP, 3, false, 5, false, false,
            false, false, false, false, FORWARD_NONE_CPP, FORWARD_NONE_CPP // No fwd if no write
        },

        // --- Data Forwarding from MEM/WB (RdW) ---
        {"MEM/WB Fwd A (RdW==Rs1D)",
            3, 2, // rs1D=3
            10, false, RESULT_SRC_ALU_CPP, // No conflict from EX
            11, false,          // No conflict from MEM
            3, true,           // Instr in WB writes to x3
            false,
            false, false, false, false, FORWARD_MEM_WB_CPP, FORWARD_NONE_CPP
        },
        {"MEM/WB Fwd B (RdW==Rs2D)",
            1, 3, 10, false, RESULT_SRC_ALU_CPP, 11, false, 3, true, false,
            false, false, false, false, FORWARD_NONE_CPP, FORWARD_MEM_WB_CPP
        },

        // --- Forwarding Priority: EX/MEM over MEM/WB ---
        {"Fwd Priority: RdM=Rs1D, RdW=Rs1D (MEM takes precedence)",
            3, 2, // rs1D=3
            10, false, RESULT_SRC_ALU_CPP,
            3, true,           // RdM=3, RegWriteM=true
            3, true,           // RdW=3, RegWriteW=true
            false,
            false, false, false, false, FORWARD_EX_MEM_CPP, FORWARD_NONE_CPP // Expect fwd from MEM
        },

        // --- Control Hazards (Branch/Jump Taken) ---
        {"Branch Taken (pc_src_e=1)",
            1, 2, 3, false, RESULT_SRC_ALU_CPP, 4, false, 5, false,
            true,              // pc_src_e = true
            false, false, true, true, FORWARD_NONE_CPP, FORWARD_NONE_CPP // FlushD, FlushE
        },

        // --- Combined: Load-Use Stall AND Branch Taken ---
        // If branch is resolved in EX, and there's a load-use for an instruction *before* the branch
        // this scenario might be tricky. Typically, if branch taken, earlier instructions are flushed.
        // If lwStall and PCSrcE both active, FlushE should be true.
        {"Load-Use Stall AND Branch Taken",
            3, 2, 3, true, RESULT_SRC_MEM_CPP, // Load-use (rs1D=3, RdE=3)
            4, false, 5, false,
            true,              // pc_src_e = true (branch taken)
            true, true, true, true, FORWARD_NONE_CPP, FORWARD_NONE_CPP // StallF, StallD, FlushD, FlushE
        },
    };

    int passed_count = 0;
    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name << std::endl;

        top->i_rs1_addr_d = tc.rs1_addr_d;
        top->i_rs2_addr_d = tc.rs2_addr_d;
        top->i_rd_addr_e = tc.rd_addr_e;
        top->i_reg_write_e = tc.reg_write_e;
        top->i_result_src_e = tc.result_src_e;
        top->i_rd_addr_m = tc.rd_addr_m;
        top->i_reg_write_m = tc.reg_write_m;
        top->i_rd_addr_w = tc.rd_addr_w;
        top->i_reg_write_w = tc.reg_write_w;
        top->i_pc_src_e = tc.pc_src_e;

        eval_pc(top, tfp);
        sim_time_pc++;

        bool current_pass = true;
        if(top->o_stall_f != tc.exp_stall_f) {std::cout << "  FAIL: StallF. Exp=" << tc.exp_stall_f << " Got=" << (int)top->o_stall_f << std::endl; current_pass=false;}
        if(top->o_stall_d != tc.exp_stall_d) {std::cout << "  FAIL: StallD. Exp=" << tc.exp_stall_d << " Got=" << (int)top->o_stall_d << std::endl; current_pass=false;}
        if(top->o_flush_d != tc.exp_flush_d) {std::cout << "  FAIL: FlushD. Exp=" << tc.exp_flush_d << " Got=" << (int)top->o_flush_d << std::endl; current_pass=false;}
        if(top->o_flush_e != tc.exp_flush_e) {std::cout << "  FAIL: FlushE. Exp=" << tc.exp_flush_e << " Got=" << (int)top->o_flush_e << std::endl; current_pass=false;}
        if(top->o_forward_a_e != tc.exp_forward_a_e) {std::cout << "  FAIL: ForwardAE. Exp=0b" << std::bitset<2>(tc.exp_forward_a_e) << " Got=0b" << std::bitset<2>(top->o_forward_a_e) << std::endl; current_pass=false;}
        if(top->o_forward_b_e != tc.exp_forward_b_e) {std::cout << "  FAIL: ForwardBE. Exp=0b" << std::bitset<2>(tc.exp_forward_b_e) << " Got=0b" << std::bitset<2>(top->o_forward_b_e) << std::endl; current_pass=false;}

        if (current_pass) {
            std::cout << "  PASS" << std::endl;
            passed_count++;
        } else {
            std::cout << "  FAILED" << std::endl;
        }
    }

    std::cout << "\nPipeline Control Testbench Finished. Passed " << passed_count << "/" << test_cases.size() << " tests." << std::endl;

    if (tfp) tfp->close();
    delete top;
    return (passed_count == test_cases.size()) ? EXIT_SUCCESS : EXIT_FAILURE;
}


