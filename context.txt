--- File: rtl/core/control_unit.sv ---
// rtl/core/control_unit.sv
`include "common/defines.svh"
`include "common/alu_defines.svh"
`include "common/immediate_types.svh"
`include "common/riscv_opcodes.svh"
`include "common/control_signals_defines.svh" // New include

module control_unit (
    // Inputs from instruction
    input  logic [6:0] op,
    input  logic [2:0] funct3,
    input  logic       funct7_5,

    // Outputs: Control signals
    output logic       reg_write_d_o,
    output logic [1:0] result_src_d_o,
    output logic       mem_write_d_o,
    output logic       jump_d_o,
    output logic       branch_d_o,
    output logic       alu_src_d_o,      // Selects ALU operand B (Reg vs Imm)
    output logic [`ALU_CONTROL_WIDTH-1:0] alu_control_d_o,
    output immediate_type_e imm_type_d_o,
    output logic [2:0] funct3_d_o,             // Pass funct3 for branch logic in EX & mem access type in MEM
    output alu_a_src_sel_e op_a_sel_d_o,        // Selects ALU operand A source
    output pc_target_src_sel_e pc_target_src_sel_d_o // Selects PC target source for EX
);

    // Pass funct3 directly as it's needed in later stages
    assign funct3_d_o = funct3;

    always_comb begin
        // Initialize signals to a known "safe" or default state for each instruction type
        reg_write_d_o   = 1'b0;
        result_src_d_o  = 2'b00; // Default: Result from ALU
        mem_write_d_o   = 1'b0;
        jump_d_o        = 1'b0;
        branch_d_o      = 1'b0;
        alu_src_d_o     = 1'b0; // Default: ALU Operand B from Register File (rs2)
        alu_control_d_o = `ALU_OP_ADD; // Default ALU operation
        imm_type_d_o    = IMM_TYPE_NONE;
        op_a_sel_d_o    = ALU_A_SRC_RS1; // Default
        pc_target_src_sel_d_o = PC_TARGET_SRC_PC_PLUS_IMM; // Default

        case (op)
            `OPCODE_LUI: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b1; // Imm for OpB
                imm_type_d_o    = IMM_TYPE_U;
                op_a_sel_d_o    = ALU_A_SRC_ZERO; // ALU OpA = 0
                alu_control_d_o = `ALU_OP_ADD;    // ALU = 0 + Imm
                result_src_d_o  = 2'b00;
            end
            `OPCODE_AUIPC: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b1; // Imm for OpB
                imm_type_d_o    = IMM_TYPE_U;
                op_a_sel_d_o    = ALU_A_SRC_PC;   // ALU OpA = PC
                alu_control_d_o = `ALU_OP_ADD;    // ALU = PC + Imm
                result_src_d_o  = 2'b00;
            end
            `OPCODE_JAL: begin
                reg_write_d_o   = 1'b1;
                jump_d_o        = 1'b1;
                imm_type_d_o    = IMM_TYPE_J;
                result_src_d_o  = 2'b10;      // rd = PC+4
                pc_target_src_sel_d_o = PC_TARGET_SRC_PC_PLUS_IMM; // Target = PC + ImmJ
                // ALU might be idle or used by a separate adder for PC+Imm.
                // To keep ALU control consistent if it *were* used for target:
                op_a_sel_d_o    = ALU_A_SRC_PC; // If ALU calculated PC+ImmJ
                alu_src_d_o     = 1'b1;
                alu_control_d_o = `ALU_OP_ADD;
            end
            `OPCODE_JALR: begin
                reg_write_d_o   = 1'b1;
                jump_d_o        = 1'b1;
                alu_src_d_o     = 1'b1; // Imm for OpB
                imm_type_d_o    = IMM_TYPE_I;
                op_a_sel_d_o    = ALU_A_SRC_RS1;  // ALU OpA = RS1
                alu_control_d_o = `ALU_OP_ADD;    // ALU = RS1 + Imm (for target calculation)
                result_src_d_o  = 2'b10;      // rd = PC+4
                pc_target_src_sel_d_o = PC_TARGET_SRC_ALU_JALR; // Target from ALU result & ~1
            end
            `OPCODE_BRANCH: begin
                branch_d_o      = 1'b1;
                alu_src_d_o     = 1'b0; // OpB = RS2 for comparison
                op_a_sel_d_o    = ALU_A_SRC_RS1; // OpA = RS1 for comparison
                imm_type_d_o    = IMM_TYPE_B;    // For PC + ImmB target calculation
                reg_write_d_o   = 1'b0;
                pc_target_src_sel_d_o = PC_TARGET_SRC_PC_PLUS_IMM; // Target is PC+ImmB
                case (funct3)
                    `FUNCT3_BEQ:  alu_control_d_o = `ALU_OP_SUB;
                    `FUNCT3_BNE:  alu_control_d_o = `ALU_OP_SUB;
                    `FUNCT3_BLT:  alu_control_d_o = `ALU_OP_SLT;
                    `FUNCT3_BGE:  alu_control_d_o = `ALU_OP_SLT;
                    `FUNCT3_BLTU: alu_control_d_o = `ALU_OP_SLTU;
                    `FUNCT3_BGEU: alu_control_d_o = `ALU_OP_SLTU;
                    default:      alu_control_d_o = `ALU_OP_ADD; // Or some invalid op
                endcase
            end
            `OPCODE_LOAD: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b1; // Imm for OpB (offset)
                imm_type_d_o    = IMM_TYPE_I;
                op_a_sel_d_o    = ALU_A_SRC_RS1;  // OpA = RS1 (base address)
                alu_control_d_o = `ALU_OP_ADD;    // ALU = RS1 + offset (address calculation)
                result_src_d_o  = 2'b01;      // Result from Memory
                mem_write_d_o   = 1'b0;
            end
            `OPCODE_STORE: begin
                alu_src_d_o     = 1'b1; // Imm for OpB (offset)
                imm_type_d_o    = IMM_TYPE_S;
                op_a_sel_d_o    = ALU_A_SRC_RS1;  // OpA = RS1 (base address)
                alu_control_d_o = `ALU_OP_ADD;    // ALU = RS1 + offset (address calculation)
                mem_write_d_o   = 1'b1;
                reg_write_d_o   = 1'b0;
            end
            `OPCODE_OP_IMM: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b1; // Imm for OpB
                imm_type_d_o    = (funct3 == `FUNCT3_SLLI || funct3 == `FUNCT3_SRLI_SRAI) ? IMM_TYPE_ISHIFT : IMM_TYPE_I;
                op_a_sel_d_o    = ALU_A_SRC_RS1;
                result_src_d_o  = 2'b00;
                case (funct3)
                    `FUNCT3_ADDI:  alu_control_d_o = `ALU_OP_ADD;
                    `FUNCT3_SLTI:  alu_control_d_o = `ALU_OP_SLT;
                    `FUNCT3_SLTIU: alu_control_d_o = `ALU_OP_SLTU;
                    `FUNCT3_XORI:  alu_control_d_o = `ALU_OP_XOR;
                    `FUNCT3_ORI:   alu_control_d_o = `ALU_OP_OR;
                    `FUNCT3_ANDI:  alu_control_d_o = `ALU_OP_AND;
                    `FUNCT3_SLLI:  alu_control_d_o = `ALU_OP_SLL;
                    `FUNCT3_SRLI_SRAI: begin
                        if (funct7_5 == `FUNCT7_5_SUB_ALT) alu_control_d_o = `ALU_OP_SRA;
                        else                               alu_control_d_o = `ALU_OP_SRL;
                    end
                    default:       alu_control_d_o = `ALU_OP_ADD;
                endcase
            end
            `OPCODE_OP: begin
                reg_write_d_o   = 1'b1;
                alu_src_d_o     = 1'b0; // OpB = RS2
                op_a_sel_d_o    = ALU_A_SRC_RS1; // OpA = RS1
                imm_type_d_o    = IMM_TYPE_NONE;
                result_src_d_o  = 2'b00;
                case (funct3)
                    `FUNCT3_ADD_SUB: begin
                        if (funct7_5 == `FUNCT7_5_SUB_ALT) alu_control_d_o = `ALU_OP_SUB;
                        else                               alu_control_d_o = `ALU_OP_ADD;
                    end
                    `FUNCT3_SLL:   alu_control_d_o = `ALU_OP_SLL;
                    `FUNCT3_SLT:   alu_control_d_o = `ALU_OP_SLT;
                    `FUNCT3_SLTU:  alu_control_d_o = `ALU_OP_SLTU;
                    `FUNCT3_XOR:   alu_control_d_o = `ALU_OP_XOR;
                    `FUNCT3_SRL_SRA: begin
                        if (funct7_5 == `FUNCT7_5_SUB_ALT) alu_control_d_o = `ALU_OP_SRA;
                        else                               alu_control_d_o = `ALU_OP_SRL;
                    end
                    `FUNCT3_OR:    alu_control_d_o = `ALU_OP_OR;
                    `FUNCT3_AND:   alu_control_d_o = `ALU_OP_AND;
                    default:       alu_control_d_o = `ALU_OP_ADD;
                endcase
            end
            default: begin // NOP / Unknown
                // Default assignments from above cover this
            end
        endcase
    end
endmodule


--- File: rtl/core/register_file.sv ---
// rtl/core/register_file.sv
`include "common/defines.svh"

module register_file (
    input  logic clk,
    input  logic rst_n,

    // Read Port 1
    input  logic [`REG_ADDR_WIDTH-1:0] rs1_addr_i,
    output logic [`DATA_WIDTH-1:0]     rs1_data_o, // Will become registered output

    // Read Port 2
    input  logic [`REG_ADDR_WIDTH-1:0] rs2_addr_i,
    output logic [`DATA_WIDTH-1:0]     rs2_data_o, // Will become registered output

    // Write Port (from Writeback stage)
    input  logic                       rd_write_en_wb_i, // RegWriteW
    input  logic [`REG_ADDR_WIDTH-1:0] rd_addr_wb_i,    // RdW
    input  logic [`DATA_WIDTH-1:0]     rd_data_wb_i     // ResultW
);

    // 32 registers, each DATA_WIDTH bits wide
    // reg[0] is hardwired to zero
    logic [`DATA_WIDTH-1:0] regs[31:0];

    // Synchronous write on positive clock edge
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // Initialize all registers to 0 on reset
            for (int i = 0; i < 32; i++) begin
                regs[i] <= `DATA_WIDTH'(0);
            end
        end else begin
            if (rd_write_en_wb_i && (rd_addr_wb_i != `REG_ADDR_WIDTH'(0))) begin
                regs[rd_addr_wb_i] <= rd_data_wb_i;
            end
        end
    end

    // Synchronous read on negative clock edge for rs1_data_o and rs2_data_o
    always_ff @(negedge clk or negedge rst_n) begin
        if (!rst_n) begin
            rs1_data_o <= `DATA_WIDTH'(0);
            rs2_data_o <= `DATA_WIDTH'(0);
        end else begin
            // Reading register 0 always yields 0
            rs1_data_o <= (rs1_addr_i == `REG_ADDR_WIDTH'(0)) ? `DATA_WIDTH'(0) : regs[rs1_addr_i];
            rs2_data_o <= (rs2_addr_i == `REG_ADDR_WIDTH'(0)) ? `DATA_WIDTH'(0) : regs[rs2_addr_i];
        end
    end

    // For simulation, to observe register values (not synthesizable this way usually for direct tb access)
    // Or use DPI for more robust testbench access
`ifdef VERILATOR
    // Provide a way to dump registers for Verilator testing if needed
    // This is a simplification; direct access for writing/reading from testbench
    // might be complex or require specific Verilator features like public_flat.
`endif

endmodule


--- File: rtl/core/data_memory.sv ---
// rtl/core/data_memory.sv
`include "common/defines.svh"
`include "common/riscv_opcodes.svh" // For FUNCT3 defines (LB, LH, LW, etc.)

module data_memory (
    input  logic clk,
    input  logic rst_n,

    input  logic [`DATA_WIDTH-1:0]     addr_i,        // Address from ALU result
    input  logic [`DATA_WIDTH-1:0]     write_data_i,  // Data from RS2 (for stores)
    input  logic                       mem_write_en_i,  // From MemWriteM control signal
    input  logic [2:0]                 funct3_i,      // To determine load/store type (size and sign)

    output logic [`DATA_WIDTH-1:0]     read_data_o    // Data read from memory (for loads)
);

    // Parameter for memory size (e.g., 2^10 = 1024 words of 64-bit)
    // Addresses are byte addresses.
    localparam MEM_ADDR_BITS = 10; // For 1KB of byte-addressable memory (2^10 bytes)
    localparam MEM_SIZE_BYTES = 1 << MEM_ADDR_BITS;
    localparam MEM_SIZE_WORDS = MEM_SIZE_BYTES / (`DATA_WIDTH/8);

    // Byte-addressable memory array. Each element is a byte.
    logic [7:0] mem [MEM_SIZE_BYTES-1:0];
    logic [`DATA_WIDTH-1:0] aligned_word_read;
    logic [`DATA_WIDTH-1:0] temp_read_data;

    // For faster simulation, Verilator might prefer word-oriented memory if operations are word-aligned
    // but byte-addressable is more general for LB/SB etc.

    // Read logic (combinational read based on address)
    // Handles different load types based on funct3
    logic [`DATA_WIDTH-1:0] read_data_aligned;
    always_comb begin
        // Default to 'x' or 0 if address is out of bounds (not explicitly handled here for simplicity)
        read_data_aligned = `DATA_WIDTH'('0);
        if (addr_i < MEM_SIZE_BYTES) begin
            // Read a full 64-bit word aligned to 8 bytes for simplicity first
            // This assumes addr_i is mostly aligned for LW/LD. Unaligned access is complex.
            // For byte/half access, we need to pick correct bytes from the word.
            // Let's read the 8 bytes starting at the (potentially unaligned) address.
            // This is a simplification; real unaligned access is more involved.
            // We'll handle alignment and byte picking for loads.
            // For simplicity, assume addr_i is aligned for word/double-word access.
            // For byte/half, addr_i can be unaligned within the word.

            // Construct the 64-bit value from individual bytes
            // This handles potential unaligned reads across word boundaries if MEM_SIZE_BYTES is large enough
            // and if addr_i + 7 does not exceed MEM_SIZE_BYTES-1.
            // For simplicity, let's assume we read an aligned 64-bit word first, then extract.
            logic [`DATA_WIDTH-1:0] fetched_word;
            logic [2:0] byte_offset_in_word = addr_i[2:0]; // Lower 3 bits for byte offset within a 64-bit word
            logic [MEM_ADDR_BITS-1:3] word_addr_idx;

            // Read the 8 bytes that form the 64-bit chunk containing addr_i
            // This is still a simplification, proper unaligned access over physical memory is hard
            for (int i = 0; i < (`DATA_WIDTH/8); i++) begin
                if ((addr_i + i) < MEM_SIZE_BYTES) begin
                    fetched_word[i*8 +: 8] = mem[addr_i + i];
                end else begin
                    fetched_word[i*8 +: 8] = 8'h00; // Out of bounds byte
                end
            end
            // The above loop is not quite right for constructing the word based on addr_i alignment
            // Let's re-think: fetch the aligned word, then select based on offset and funct3.
            temp_read_data = `DATA_WIDTH'('x);
            word_addr_idx = addr_i[MEM_ADDR_BITS-1:3]; // Index for 64-bit words if mem was word array

            // More correct byte-wise construction for an aligned read:
            for (int i = 0; i < (`DATA_WIDTH/8); i++) begin
                 // addr_i & ~7 ensures we start at an 8-byte boundary for the read
                if (( (addr_i & ~(`DATA_WIDTH/8 - 1)) + i) < MEM_SIZE_BYTES) begin
                    aligned_word_read[(i*8) +: 8] = mem[(addr_i & ~(`DATA_WIDTH/8 - 1)) + i];
                end else begin
                    aligned_word_read[(i*8) +: 8] = 8'h00;
                end
            end


            case (funct3_i)
                `FUNCT3_LB: begin // Load Byte (signed)
                    temp_read_data = {{(`DATA_WIDTH-8){aligned_word_read[byte_offset_in_word*8 + 7]}}, aligned_word_read[byte_offset_in_word*8 +: 8]};
                end
                `FUNCT3_LH: begin // Load Half-word (signed)
                    temp_read_data = {{(`DATA_WIDTH-16){aligned_word_read[byte_offset_in_word*8 + 15]}}, aligned_word_read[byte_offset_in_word*8 +: 16]};
                end
                `FUNCT3_LW: begin // Load Word (signed, 32-bit)
                    temp_read_data = {{(`DATA_WIDTH-32){aligned_word_read[byte_offset_in_word*8 + 31]}}, aligned_word_read[byte_offset_in_word*8 +: 32]};
                end
                `FUNCT3_LD: begin // Load Double-word (64-bit)
                    temp_read_data = aligned_word_read; // Assumes addr_i is 8-byte aligned for LD
                end
                `FUNCT3_LBU: begin // Load Byte (unsigned)
                    temp_read_data = {{(`DATA_WIDTH-8){1'b0}}, aligned_word_read[byte_offset_in_word*8 +: 8]};
                end
                `FUNCT3_LHU: begin // Load Half-word (unsigned)
                    temp_read_data = {{(`DATA_WIDTH-16){1'b0}}, aligned_word_read[byte_offset_in_word*8 +: 16]};
                end
                `FUNCT3_LWU: begin // Load Word (unsigned, 32-bit into 64-bit)
                    temp_read_data = {{(`DATA_WIDTH-32){1'b0}}, aligned_word_read[byte_offset_in_word*8 +: 32]};
                end
                default: temp_read_data = `DATA_WIDTH'('x); // Should not happen for load opcodes
            endcase
            read_data_aligned = temp_read_data;
        end
    end
    assign read_data_o = read_data_aligned;

    // Write logic (synchronous write on positive clock edge)
    always_ff @(posedge clk) begin
        if (mem_write_en_i && addr_i < MEM_SIZE_BYTES) begin
            case (funct3_i)
                `FUNCT3_SB: begin // Store Byte
                    if (addr_i < MEM_SIZE_BYTES) mem[addr_i] = write_data_i[7:0];
                end
                `FUNCT3_SH: begin // Store Half-word
                    if ((addr_i + 1) < MEM_SIZE_BYTES) begin // Check bounds for 2 bytes
                        mem[addr_i]   = write_data_i[7:0];
                        mem[addr_i+1] = write_data_i[15:8];
                    end
                end
                `FUNCT3_SW: begin // Store Word (32-bit)
                    if ((addr_i + 3) < MEM_SIZE_BYTES) begin // Check bounds for 4 bytes
                        for (int i = 0; i < 4; i++) begin
                            mem[addr_i+i] = write_data_i[i*8 +: 8];
                        end
                    end
                end
                `FUNCT3_SD: begin // Store Double-word (64-bit)
                    if ((addr_i + 7) < MEM_SIZE_BYTES) begin // Check bounds for 8 bytes
                        for (int i = 0; i < (`DATA_WIDTH/8); i++) begin
                            mem[addr_i+i] = write_data_i[i*8 +: 8];
                        end
                    end
                end
                default: ; // No action for other funct3 values during store
            endcase
        end
    end

    // Optional: Initialize memory on reset (for simulation)
    initial begin
        if (rst_n) begin // Wait for reset to de-assert if this initial block runs at time 0
            for (int i = 0; i < MEM_SIZE_BYTES; i++) begin
                mem[i] = 8'h00;
            end
        end
    end
    // Better reset handling:
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (int i = 0; i < MEM_SIZE_BYTES; i++) begin
                mem[i] = 8'h00;
            end
        end
    end

endmodule


--- File: rtl/core/execute.sv ---
// rtl/core/execute.sv
`include "common/pipeline_types.svh"
`include "common/riscv_opcodes.svh" // For FUNCT3 defines for branches

module execute (
    // Clock and Reset (potentially unused if purely combinational)
    // input  logic clk,
    // input  logic rst_n,

    // Input from Decode (latched by ID/EX register in pipeline.sv)
    input  id_ex_data_t            id_ex_data_i,

    // Forwarding signals from Hazard Unit and data from later stages
    input  logic [`DATA_WIDTH-1:0] forward_data_mem_i, // Data from EX/MEM output (ALUResultM or ReadDataM)
    input  logic [`DATA_WIDTH-1:0] forward_data_wb_i,  // Data from MEM/WB output (ResultW)
    input  logic [1:0]             forward_a_e_i,      // Control for OpA forwarding MUX
    input  logic [1:0]             forward_b_e_i,      // Control for OpB forwarding MUX

    // Output to Memory stage (to be latched by EX/MEM register in pipeline.sv)
    output ex_mem_data_t           ex_mem_data_o,

    // Outputs to Fetch Stage / PC update logic
    output logic                   pc_src_o,           // PCSrcE: 1 if branch/jump taken
    output logic [`DATA_WIDTH-1:0] pc_target_addr_o // PCTargetE: target address
);

    logic [`DATA_WIDTH-1:0] alu_operand_a_mux_out;
    logic [`DATA_WIDTH-1:0] alu_operand_a_final;
    logic [`DATA_WIDTH-1:0] alu_operand_b_mux_out;
    logic [`DATA_WIDTH-1:0] alu_operand_b_final;

    logic [`DATA_WIDTH-1:0] alu_result_internal;
    logic                   alu_zero_flag_internal;

    // ALU Operand A Source Selection (before forwarding)
    always_comb begin
        case (id_ex_data_i.op_a_sel)
            ALU_A_SRC_RS1:  alu_operand_a_mux_out = id_ex_data_i.rs1_data;
            ALU_A_SRC_PC:   alu_operand_a_mux_out = id_ex_data_i.pc;
            ALU_A_SRC_ZERO: alu_operand_a_mux_out = `DATA_WIDTH'(0);
            default:        alu_operand_a_mux_out = id_ex_data_i.rs1_data; // Should not happen
        endcase
    end

    // ALU Operand A Forwarding
    always_comb begin
        case (forward_a_e_i)
            2'b00:  alu_operand_a_final = alu_operand_a_mux_out;    // No forward
            2'b10:  alu_operand_a_final = forward_data_mem_i;       // Forward from EX/MEM stage (RdM)
            2'b01:  alu_operand_a_final = forward_data_wb_i;        // Forward from MEM/WB stage (RdW)
            default: alu_operand_a_final = alu_operand_a_mux_out;   // Should not happen
        endcase
    end

    // ALU Operand B Source Selection (before forwarding)
    assign alu_operand_b_mux_out = id_ex_data_i.alu_src ? id_ex_data_i.imm_ext : id_ex_data_i.rs2_data;

    // ALU Operand B Forwarding
    always_comb begin
        if (id_ex_data_i.alu_src) begin // If Operand B is an Immediate, no forwarding
            alu_operand_b_final = id_ex_data_i.imm_ext;
        end else begin // Operand B is from a register (rs2_data), forwarding might apply
            case (forward_b_e_i)
                2'b00:  alu_operand_b_final = alu_operand_b_mux_out;    // No forward
                2'b10:  alu_operand_b_final = forward_data_mem_i;       // Forward from EX/MEM stage (RdM)
                2'b01:  alu_operand_b_final = forward_data_wb_i;        // Forward from MEM/WB stage (RdW)
                default: alu_operand_b_final = alu_operand_b_mux_out;   // Should not happen
            endcase
        end
    end

    // ALU Instance
    alu u_alu (
        .operand_a   (alu_operand_a_final),
        .operand_b   (alu_operand_b_final),
        .alu_control (id_ex_data_i.alu_control),
        .result      (alu_result_internal),
        .zero_flag   (alu_zero_flag_internal)
    );

    // PC Target Address Calculation
    logic [`DATA_WIDTH-1:0] target_addr_pc_plus_imm;
    logic [`DATA_WIDTH-1:0] target_addr_alu_jalr_masked;

    assign target_addr_pc_plus_imm = id_ex_data_i.pc + id_ex_data_i.imm_ext;
    // For JALR: target = (ALU result of RS1 + Imm) & ~1.
    // ALU computes (RS1 + Imm) if op_a_sel=RS1, alu_src=Imm, alu_control=ADD.
    // This specific ALU result (alu_result_internal) is used for JALR.
    assign target_addr_alu_jalr_masked = alu_result_internal & ~(`DATA_WIDTH'(1));

    assign pc_target_addr_o = (id_ex_data_i.pc_target_src_sel == PC_TARGET_SRC_ALU_JALR) ?
                               target_addr_alu_jalr_masked : target_addr_pc_plus_imm;

    // Branch Condition Logic
    logic take_branch;
    always_comb begin
        take_branch = 1'b0;
        if (id_ex_data_i.branch) begin
            case (id_ex_data_i.funct3) // Use pipelined funct3
                `FUNCT3_BEQ:  take_branch = alu_zero_flag_internal;
                `FUNCT3_BNE:  take_branch = ~alu_zero_flag_internal;
                `FUNCT3_BLT:  take_branch = alu_result_internal[0];  // SLT result is 1 if taken
                `FUNCT3_BGE:  take_branch = ~alu_result_internal[0]; // SLT result is 0 if taken
                `FUNCT3_BLTU: take_branch = alu_result_internal[0];  // SLTU result is 1 if taken
                `FUNCT3_BGEU: take_branch = ~alu_result_internal[0]; // SLTU result is 0 if taken
                default:      take_branch = 1'b0;
            endcase
        end
    end

    // PCSrc signal: Controls MUX for next PC in Fetch stage
    assign pc_src_o = (id_ex_data_i.jump) || (id_ex_data_i.branch && take_branch);

    // Assign outputs to EX/MEM data structure
    assign ex_mem_data_o.reg_write  = id_ex_data_i.reg_write;
    assign ex_mem_data_o.result_src = id_ex_data_i.result_src;
    assign ex_mem_data_o.mem_write  = id_ex_data_i.mem_write;
    assign ex_mem_data_o.funct3     = id_ex_data_i.funct3;      // Pass funct3 for Memory stage (load/store type)
    assign ex_mem_data_o.alu_result = alu_result_internal;      // Result of ALU operation
    assign ex_mem_data_o.rs2_data   = id_ex_data_i.rs2_data;    // Original RS2 data (e.g., for Store instructions)
    assign ex_mem_data_o.rd_addr    = id_ex_data_i.rd_addr;
    assign ex_mem_data_o.pc_plus_4  = id_ex_data_i.pc_plus_4;   // For JAL/JALR writeback

endmodule


--- File: rtl/core/immediate_generator.sv ---
// rtl/core/immediate_generator.sv
`include "common/defines.svh"
`include "common/immediate_types.svh"

module immediate_generator (
    input  logic [`INSTR_WIDTH-1:0] instr_i,
    input  immediate_type_e         imm_type_sel_i, // Selects the type of immediate to generate
    output logic [`DATA_WIDTH-1:0]  imm_ext_o      // Sign-extended immediate value
);

    logic [`DATA_WIDTH-1:0] imm_i_type;
    logic [`DATA_WIDTH-1:0] imm_s_type;
    logic [`DATA_WIDTH-1:0] imm_b_type;
    logic [`DATA_WIDTH-1:0] imm_u_type;
    logic [`DATA_WIDTH-1:0] imm_j_type;
    logic [`DATA_WIDTH-1:0] imm_ishift_type;

    // I-type immediate: instr[31:20] (12 bits)
    assign imm_i_type = {{(`DATA_WIDTH-12){instr_i[31]}}, instr_i[31:20]};

    // S-type immediate: instr[31:25], instr[11:7] (12 bits)
    assign imm_s_type = {{(`DATA_WIDTH-12){instr_i[31]}}, instr_i[31:25], instr_i[11:7]};

    // B-type immediate: {instr[31], instr[7], instr[30:25], instr[11:8], 1'b0} (13 bits)
    // Sign-extended from original bit 12 (instr[31]) of the conceptual 13-bit immediate.
    assign imm_b_type = {{(`DATA_WIDTH-13){instr_i[31]}}, instr_i[31], instr_i[7], instr_i[30:25], instr_i[11:8], 1'b0};

    // U-type immediate: {instr[31:12], 12'b0} (32 bits)
    // Sign-extended from bit 31 of the effective 32-bit immediate. For RV64, this means sign-extend from bit 31 of the value.
    assign imm_u_type = {{(`DATA_WIDTH-32){instr_i[31]}}, instr_i[31:12], 12'h000};

    // J-type immediate: {instr[31], instr[19:12], instr[20], instr[30:21], 1'b0} (21 bits)
    // Sign-extended from original bit 20 (instr[31]) of the conceptual 21-bit immediate.
    assign imm_j_type = {{(`DATA_WIDTH-21){instr_i[31]}}, instr_i[31], instr_i[19:12], instr_i[20], instr_i[30:21], 1'b0};
    assign imm_ishift_type = `DATA_WIDTH'(instr_i[25:20]);

    always_comb begin
        case (imm_type_sel_i)
            IMM_TYPE_I:    imm_ext_o = imm_i_type;
            IMM_TYPE_S:    imm_ext_o = imm_s_type;
            IMM_TYPE_B:    imm_ext_o = imm_b_type;
            IMM_TYPE_U:    imm_ext_o = imm_u_type;
            IMM_TYPE_J:    imm_ext_o = imm_j_type;
            IMM_TYPE_ISHIFT: imm_ext_o = imm_ishift_type;
            IMM_TYPE_NONE: imm_ext_o = `DATA_WIDTH'(0); // Or 'x if preferred for non-existent immediates
            default:       imm_ext_o = `DATA_WIDTH'('x); // Should not happen with valid enum
        endcase
    end

endmodule


--- File: rtl/core/fetch.sv ---
// rtl/core/fetch.sv
`include "common/pipeline_types.svh" // Includes common/defines.svh indirectly

module fetch (
    input  logic clk,
    input  logic rst_n,

    // Control signals
    input  logic                       stall_f_i,
    input  logic                       pc_src_e_i,         // From Execute: select PC source
    input  logic [`DATA_WIDTH-1:0]     pc_target_e_i,      // From Execute: target address for branch/jump

    // Output to Decode (via pipeline register in top)
    output if_id_data_t                if_id_data_o
);

    logic [`DATA_WIDTH-1:0] pc_reg;
    logic [`DATA_WIDTH-1:0] pc_next;
    logic [`DATA_WIDTH-1:0] pc_plus_4_temp;
    logic [`INSTR_WIDTH-1:0] instr_mem_data;

    instruction_memory i_instr_mem (
        .address     (pc_reg), // Use current PC for fetch
        .instruction (instr_mem_data)
    );

    assign pc_plus_4_temp = pc_reg + 4;
    assign pc_next = pc_src_e_i ? pc_target_e_i : pc_plus_4_temp;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            pc_reg <= `PC_RESET_VALUE;
        end else if (!stall_f_i) begin
            pc_reg <= pc_next;
        end
        // If stall_f_i is asserted, pc_reg holds its value
    end

    // Assign outputs for the current cycle
    // These values will be latched by the IF/ID pipeline register in the main pipeline module
    assign if_id_data_o.instr      = instr_mem_data;
    assign if_id_data_o.pc         = pc_reg;         // PC of the fetched instruction
    assign if_id_data_o.pc_plus_4  = pc_plus_4_temp; // PC+4 of the fetched instruction

endmodule


--- File: rtl/core/alu.sv ---
// rtl/core/alu.sv
`include "common/defines.svh"
`include "common/alu_defines.svh" // Will use new defines

module alu (
    input  logic [`DATA_WIDTH-1:0]     operand_a,
    input  logic [`DATA_WIDTH-1:0]     operand_b,
    input  logic [`ALU_CONTROL_WIDTH-1:0] alu_control, // Unified control signal
    output logic [`DATA_WIDTH-1:0]     result,
    output logic                       zero_flag
);

    logic [`DATA_WIDTH-1:0] result_comb;
    logic [5:0]             shift_amount; // For RV64, shift by lower 6 bits of operand_b

    assign shift_amount = operand_b[5:0];

    always_comb begin
        result_comb = {`DATA_WIDTH{1'bx}}; // Default to 'x'

        case (alu_control)
            `ALU_OP_ADD:  result_comb = operand_a + operand_b;
            `ALU_OP_SUB:  result_comb = operand_a - operand_b;
            `ALU_OP_SLL:  result_comb = operand_a << shift_amount;
            `ALU_OP_SLT:  result_comb = ($signed(operand_a) < $signed(operand_b)) ? {{`DATA_WIDTH-1{1'b0}}, 1'b1} : {`DATA_WIDTH{1'b0}};
            `ALU_OP_SLTU: result_comb = (operand_a < operand_b) ? {{`DATA_WIDTH-1{1'b0}}, 1'b1} : {`DATA_WIDTH{1'b0}};
            `ALU_OP_XOR:  result_comb = operand_a ^ operand_b;
            `ALU_OP_SRL:  result_comb = operand_a >> shift_amount;
            `ALU_OP_SRA:  result_comb = $signed(operand_a) >>> shift_amount;
            `ALU_OP_OR:   result_comb = operand_a | operand_b;
            `ALU_OP_AND:  result_comb = operand_a & operand_b;
            // `ALU_OP_PASS_B: result_comb = operand_b; // If we had this explicit op
            default:      result_comb = {`DATA_WIDTH{1'bx}}; // Undefined operation
        endcase
    end

    assign result = result_comb;
    assign zero_flag = (result_comb == {`DATA_WIDTH{1'b0}});

endmodule


--- File: rtl/core/decode.sv ---
// rtl/core/decode.sv
`include "common/pipeline_types.svh"
`include "common/riscv_opcodes.svh" // For opcode/funct defines used in submodules

module decode (
    input  logic clk,
    input  logic rst_n,

    // Input from Fetch (latched by IF/ID register in pipeline.sv)
    input  if_id_data_t     if_id_data_i,

    // Input from Writeback stage for Register File write
    input  rf_write_data_t  writeback_data_i,

    // Output to Execute (to be latched by ID/EX register in pipeline.sv)
    output id_ex_data_t     id_ex_data_o,

    // Outputs for Hazard Unit (direct from instruction)
    output logic [`REG_ADDR_WIDTH-1:0] rs1_addr_d_o,
    output logic [`REG_ADDR_WIDTH-1:0] rs2_addr_d_o
    // rd_addr_d_o is part of id_ex_data_o.rd_addr
);

    // Instruction fields extracted from if_id_data_i.instr
    logic [6:0] opcode;
    logic [`REG_ADDR_WIDTH-1:0] rs1_addr_instr;
    logic [`REG_ADDR_WIDTH-1:0] rs2_addr_instr;
    logic [`REG_ADDR_WIDTH-1:0] rd_addr_instr;
    logic [2:0] funct3_instr;
    logic       funct7_5_instr;

    // Intermediate signals from submodules
    immediate_type_e imm_type_sel_internal;
    logic [`DATA_WIDTH-1:0] rs1_data_from_rf;
    logic [`DATA_WIDTH-1:0] rs2_data_from_rf;
    logic [`DATA_WIDTH-1:0] imm_ext_internal;

    // Decompose instruction from the input structure
    assign opcode         = if_id_data_i.instr[6:0];
    assign rd_addr_instr  = if_id_data_i.instr[11:7];
    assign funct3_instr   = if_id_data_i.instr[14:12];
    assign rs1_addr_instr = if_id_data_i.instr[19:15];
    assign rs2_addr_instr = if_id_data_i.instr[24:20];
    assign funct7_5_instr = if_id_data_i.instr[30];

    // Control Unit instance
    control_unit u_control_unit (
        .op                    (opcode),
        .funct3                (funct3_instr),
        .funct7_5              (funct7_5_instr),
        .reg_write_d_o         (id_ex_data_o.reg_write),
        .result_src_d_o        (id_ex_data_o.result_src),
        .mem_write_d_o         (id_ex_data_o.mem_write),
        .jump_d_o              (id_ex_data_o.jump),
        .branch_d_o            (id_ex_data_o.branch),
        .alu_src_d_o           (id_ex_data_o.alu_src),
        .alu_control_d_o       (id_ex_data_o.alu_control),
        .imm_type_d_o          (imm_type_sel_internal),
        .funct3_d_o            (id_ex_data_o.funct3), // Directly passes funct3_instr
        .op_a_sel_d_o          (id_ex_data_o.op_a_sel),
        .pc_target_src_sel_d_o (id_ex_data_o.pc_target_src_sel)
    );

    // Register File instance
    register_file u_register_file (
        .clk               (clk),
        .rst_n             (rst_n),
        .rs1_addr_i        (rs1_addr_instr),
        .rs1_data_o        (rs1_data_from_rf),
        .rs2_addr_i        (rs2_addr_instr),
        .rs2_data_o        (rs2_data_from_rf),
        .rd_write_en_wb_i  (writeback_data_i.reg_write_en),
        .rd_addr_wb_i      (writeback_data_i.rd_addr),
        .rd_data_wb_i      (writeback_data_i.result_to_rf)
    );

    // Immediate Generator instance
    immediate_generator u_immediate_generator (
        .instr_i           (if_id_data_i.instr),
        .imm_type_sel_i    (imm_type_sel_internal),
        .imm_ext_o         (imm_ext_internal)
    );

    // Assign data fields to the output structure
    // PC and PC+4 values are passed through from IF/ID stage data
    assign id_ex_data_o.pc         = if_id_data_i.pc;
    assign id_ex_data_o.pc_plus_4  = if_id_data_i.pc_plus_4;

    // Register data from RF
    assign id_ex_data_o.rs1_data   = rs1_data_from_rf;
    assign id_ex_data_o.rs2_data   = rs2_data_from_rf;

    // Extended immediate value
    assign id_ex_data_o.imm_ext    = imm_ext_internal;

    // Register addresses (rs1_addr and rs2_addr are also output separately for Hazard Unit)
    assign id_ex_data_o.rs1_addr   = rs1_addr_instr;
    assign id_ex_data_o.rs2_addr   = rs2_addr_instr;
    assign id_ex_data_o.rd_addr    = rd_addr_instr;

    // Outputs for Hazard Unit (direct from instruction fields)
    assign rs1_addr_d_o = rs1_addr_instr;
    assign rs2_addr_d_o = rs2_addr_instr;

endmodule


--- File: rtl/core/writeback_stage.sv ---
// rtl/core/writeback_stage.sv
`include "common/pipeline_types.svh"

module writeback_stage (
    // Input from Memory (latched by MEM/WB register in pipeline.sv)
    input  mem_wb_data_t           mem_wb_data_i,

    // Output to Register File write port (directly connected in pipeline.sv)
    output rf_write_data_t         rf_write_data_o
);

    logic [`DATA_WIDTH-1:0] result_selected_for_rf;

    // MUX to select the data to be written back to the register file
    always_comb begin
        case (mem_wb_data_i.result_src)
            2'b00:  result_selected_for_rf = mem_wb_data_i.alu_result;    // Result from ALU
            2'b01:  result_selected_for_rf = mem_wb_data_i.read_data_mem; // Data from memory
            2'b10:  result_selected_for_rf = mem_wb_data_i.pc_plus_4;     // PC+4 for JAL/JALR
            default: result_selected_for_rf = `DATA_WIDTH'('x); // Should not happen
        endcase
    end

    // Assign outputs for the register file write data structure
    assign rf_write_data_o.reg_write_en = mem_wb_data_i.reg_write;
    assign rf_write_data_o.rd_addr      = mem_wb_data_i.rd_addr;
    assign rf_write_data_o.result_to_rf = result_selected_for_rf;

endmodule


--- File: rtl/core/pipeline_control.sv ---
// rtl/core/pipeline_control.sv
`include "common/pipeline_types.svh"

module pipeline_control (
    // Inputs from various pipeline stages (latched values in pipeline.sv)
    input  if_id_data_t    if_id_data_i,     // For rs1_addr_d, rs2_addr_d (extracted from instr)
    input  id_ex_data_t    id_ex_data_i,     // For RdE, RegWriteE, ResultSrcE (load-use) and Rs1E, Rs2E (for forwarding)
    input  ex_mem_data_t   ex_mem_data_i,    // For RdM, RegWriteM (forwarding)
    input  mem_wb_data_t   mem_wb_data_i,    // For RdW, RegWriteW (forwarding)

    input  logic           pc_src_from_ex_i, // PCSrcE from Execute stage output

    // Output structure with all hazard control signals
    output hazard_control_t hazard_ctrl_o
);

    logic load_use_hazard;
    logic is_load_in_ex;

    // Extract rs1_addr and rs2_addr for the instruction currently in Decode stage,
    // which will be in Execute stage when these forwarding/stall signals are applied.
    // These correspond to Rs1D and Rs2D from the diagram for load-use hazard detection.
    logic [`REG_ADDR_WIDTH-1:0] rs1_addr_d_from_instr;
    logic [`REG_ADDR_WIDTH-1:0] rs2_addr_d_from_instr;

    assign rs1_addr_d_from_instr = if_id_data_i.instr[19:15];
    assign rs2_addr_d_from_instr = if_id_data_i.instr[24:20];


    // ** 1. Load-Use Hazard Detection & Stall Generation **
    // An instruction in EX is a load, and its destination (RdE) is a source for an instruction in ID.
    assign is_load_in_ex = (id_ex_data_i.result_src == 2'b01); // Data from memory

    assign load_use_hazard = is_load_in_ex && id_ex_data_i.reg_write && (id_ex_data_i.rd_addr != 0) &&
                             ((id_ex_data_i.rd_addr == rs1_addr_d_from_instr) || (id_ex_data_i.rd_addr == rs2_addr_d_from_instr));

    assign hazard_ctrl_o.stall_f = load_use_hazard;
    assign hazard_ctrl_o.stall_d = load_use_hazard; // Stall IF/ID register (holds current content)

    // ** 2. Flush Generation **
    // FlushD (IF/ID output becomes NOP): if branch/jump taken in EX.
    // FlushE (ID/EX output becomes NOP): if load-use stall OR branch/jump taken in EX.
    assign hazard_ctrl_o.flush_d = pc_src_from_ex_i;
    assign hazard_ctrl_o.flush_e = load_use_hazard || pc_src_from_ex_i;


    // ** 3. Forwarding Logic **
    // Forwarding for instruction currently in Execute stage.
    // Rs1E and Rs2E for the current EX instruction are id_ex_data_i.rs1_addr and id_ex_data_i.rs2_addr.

    // Forward for Operand A (connected to ALU operand A input in Execute)
    always_comb begin
        hazard_ctrl_o.forward_a_e = 2'b00; // Default: No forward

        // Check EX/MEM stage hazard: if instr in MEM writes to RdM, and RdM is Rs1 of instr in EX
        if (ex_mem_data_i.reg_write && (ex_mem_data_i.rd_addr != 0) &&
            (ex_mem_data_i.rd_addr == id_ex_data_i.rs1_addr)) begin
            hazard_ctrl_o.forward_a_e = 2'b10; // Forward from EX/MEM (RdM path)
        end
        // Check MEM/WB stage hazard: if instr in WB writes to RdW, and RdW is Rs1 of instr in EX
        // (and not already covered by EX/MEM forward)
        else if (mem_wb_data_i.reg_write && (mem_wb_data_i.rd_addr != 0) &&
                 (mem_wb_data_i.rd_addr == id_ex_data_i.rs1_addr)) begin
            hazard_ctrl_o.forward_a_e = 2'b01; // Forward from MEM/WB (RdW path)
        end
    end

    // Forward for Operand B (connected to ALU operand B input in Execute)
    always_comb begin
        hazard_ctrl_o.forward_b_e = 2'b00; // Default: No forward

        if (ex_mem_data_i.reg_write && (ex_mem_data_i.rd_addr != 0) &&
            (ex_mem_data_i.rd_addr == id_ex_data_i.rs2_addr)) begin
            hazard_ctrl_o.forward_b_e = 2'b10; // Forward from EX/MEM
        end
        else if (mem_wb_data_i.reg_write && (mem_wb_data_i.rd_addr != 0) &&
                 (mem_wb_data_i.rd_addr == id_ex_data_i.rs2_addr)) begin
            hazard_ctrl_o.forward_b_e = 2'b01; // Forward from MEM/WB
        end
    end

endmodule


--- File: rtl/core/instruction_memory.sv ---
`include "common/defines.svh"

module instruction_memory (
    input  logic [`DATA_WIDTH-1:0] address,
    output logic [`INSTR_WIDTH-1:0] instruction
);

    parameter string MEM_INIT_FILE = ""; // Parameter for memory initialization file
    localparam ROM_SIZE = 256; // Number of instructions
    logic [`INSTR_WIDTH-1:0] mem[ROM_SIZE-1:0];

    initial begin
        // Default initialize all memory to NOP
        for (int i = 0; i < ROM_SIZE; i++) begin
            mem[i] = 32'h00000013; // NOP: addi x0, x0, 0
        end

        if (MEM_INIT_FILE != "") begin
            // If a file is specified, load it. This will override NOPs.
            $readmemh(MEM_INIT_FILE, mem);
            // $display("Instruction memory initialized from %s", MEM_INIT_FILE);
        end else begin
            // Fallback to hardcoded test instructions if no file is provided
            // These will override the NOPs at specific locations.
            mem[0] = 32'h00100093; // addi x1, x0, 1
            mem[1] = 32'h00200113; // addi x2, x0, 2
            mem[2] = 32'h00308193; // addi x3, x1, 3
            mem[3] = 32'h00110213; // addi x4, x2, 1
            // $display("Instruction memory initialized with default test program.");
        end
    end

    assign instruction = (address[`DATA_WIDTH-1:2] < ROM_SIZE) ?
                     mem[address[`DATA_WIDTH-1:2]] :
                     `INSTR_WIDTH'('h00000013); // Return NOP for out-of-bounds access

endmodule


--- File: rtl/core/memory_stage.sv ---
// rtl/core/memory_stage.sv
`include "common/pipeline_types.svh"

module memory_stage (
    input  logic clk,
    input  logic rst_n,

    // Input from Execute (latched by EX/MEM register in pipeline.sv)
    input  ex_mem_data_t           ex_mem_data_i,

    // Output to Writeback (to be latched by MEM/WB register in pipeline.sv)
    output mem_wb_data_t           mem_wb_data_o
);

    logic [`DATA_WIDTH-1:0] mem_read_data_internal;

    // Data Memory Instance
    // Parameters for data_memory (like DATA_MEM_INIT_FILE) will be set
    // when data_memory is instantiated within this module, or if data_memory
    // itself is parameterized and those parameters are passed down from the top.
    // For now, assuming default data_memory instantiation.
    data_memory u_data_memory (
        .clk            (clk),
        .rst_n          (rst_n),
        .addr_i         (ex_mem_data_i.alu_result),   // Address from ALU result in EX stage
        .write_data_i   (ex_mem_data_i.rs2_data),     // Data to write is from rs2 (passed through EX)
        .mem_write_en_i (ex_mem_data_i.mem_write),    // Write enable from control unit (passed through EX)
        .funct3_i       (ex_mem_data_i.funct3),       // For load/store type and size
        .read_data_o    (mem_read_data_internal)      // Data read from memory
    );

    // Assign outputs to MEM/WB data structure
    // Control signals passed through
    assign mem_wb_data_o.reg_write      = ex_mem_data_i.reg_write;
    assign mem_wb_data_o.result_src     = ex_mem_data_i.result_src;

    // Data
    assign mem_wb_data_o.read_data_mem  = mem_read_data_internal;
    assign mem_wb_data_o.alu_result     = ex_mem_data_i.alu_result; // Pass ALU result through
    assign mem_wb_data_o.pc_plus_4      = ex_mem_data_i.pc_plus_4;  // Pass PC+4 through

    // Register address passed through
    assign mem_wb_data_o.rd_addr        = ex_mem_data_i.rd_addr;

endmodule


--- File: rtl/common/riscv_opcodes.svh ---
// rtl/common/riscv_opcodes.svh
`ifndef RISCV_OPCODES_SVH
`define RISCV_OPCODES_SVH

// Opcodes (bottom 7 bits of instruction)
`define OPCODE_LUI        7'b0110111 // Load Upper Immediate
`define OPCODE_AUIPC      7'b0010111 // Add Upper Immediate to PC
`define OPCODE_JAL        7'b1101111 // Jump and Link
`define OPCODE_JALR       7'b1100111 // Jump and Link Register
`define OPCODE_BRANCH     7'b1100011 // Conditional Branches (BEQ, BNE, etc.)
`define OPCODE_LOAD       7'b0000011 // Loads (LB, LH, LW, LD, LBU, LHU, LWU)
`define OPCODE_STORE      7'b0100011 // Stores (SB, SH, SW, SD)
`define OPCODE_OP_IMM   7'b0010011 // Immediate Arithmetic/Logic (ADDI, SLTI, etc.)
`define OPCODE_OP         7'b0110011 // Register-Register Arithmetic/Logic (ADD, SUB, etc.)
`define OPCODE_MISC_MEM 7'b0001111 // FENCE, FENCE.I
`define OPCODE_SYSTEM     7'b1110011 // ECALL, EBREAK, CSR instructions

// Funct3 codes for OP_IMM, OP, BRANCH, LOAD, STORE, JALR
// For OP_IMM & OP
`define FUNCT3_ADDI       3'b000 // ADDI
`define FUNCT3_ADD_SUB    3'b000 // ADD/SUB (OP)
`define FUNCT3_SLLI       3'b001 // SLLI (OP_IMM)
`define FUNCT3_SLL        3'b001 // SLL (OP)
`define FUNCT3_SLTI       3'b010 // SLTI (OP_IMM)
`define FUNCT3_SLT        3'b010 // SLT (OP)
`define FUNCT3_SLTIU      3'b011 // SLTIU (OP_IMM)
`define FUNCT3_SLTU       3'b011 // SLTU (OP)
`define FUNCT3_XORI       3'b100 // XORI (OP_IMM)
`define FUNCT3_XOR        3'b100 // XOR (OP)
`define FUNCT3_SRLI_SRAI  3'b101 // SRLI/SRAI (OP_IMM) - Distinguish by funct7
`define FUNCT3_SRL_SRA    3'b101 // SRL/SRA (OP)     - Distinguish by funct7
`define FUNCT3_ORI        3'b110 // ORI (OP_IMM)
`define FUNCT3_OR         3'b110 // OR (OP)
`define FUNCT3_ANDI       3'b111 // ANDI (OP_IMM)
`define FUNCT3_AND        3'b111 // AND (OP)

// For BRANCH
`define FUNCT3_BEQ        3'b000
`define FUNCT3_BNE        3'b001
`define FUNCT3_BLT        3'b100
`define FUNCT3_BGE        3'b101
`define FUNCT3_BLTU       3'b110
`define FUNCT3_BGEU       3'b111

// For LOAD
`define FUNCT3_LB         3'b000
`define FUNCT3_LH         3'b001
`define FUNCT3_LW         3'b010
`define FUNCT3_LD         3'b011 // RV64
`define FUNCT3_LBU        3'b100
`define FUNCT3_LHU        3'b101
`define FUNCT3_LWU        3'b110 // RV64

// For STORE
`define FUNCT3_SB         3'b000
`define FUNCT3_SH         3'b001
`define FUNCT3_SW         3'b010
`define FUNCT3_SD         3'b011 // RV64

// For JALR
`define FUNCT3_JALR       3'b000

// Funct7 codes (or relevant bits)
// For ADD/SUB and SRA/SRL distinction in OP and OP_IMM type instructions.
// For R-type (OP) and I-type shifts (OP_IMM), bit 5 of funct7 (instr[30]) is often used.
`define FUNCT7_5_SUB_ALT  1'b1 // For SUB, SRA, SRAI (funct7[5])
`define FUNCT7_5_ADD_MAIN 1'b0 // For ADD, SRL, SRLI (funct7[5])
// `define FUNCT7_SRL        7'b0000000 (SRL, SRLI, SRLW, SRLIW)
// `define FUNCT7_SRA        7'b0100000 (SRA, SRAI, SRAW, SRAIW)
// `define FUNCT7_ADD        7'b0000000
// `define FUNCT7_SUB        7'b0100000

`endif // RISCV_OPCODES_SVH


--- File: rtl/common/immediate_types.svh ---
// rtl/common/immediate_types.svh
`ifndef IMMEDIATE_TYPES_SVH
`define IMMEDIATE_TYPES_SVH

// Enum for selecting immediate type in immediate_generator
// This allows the control unit to specify exactly which format to use.
typedef enum logic [2:0] {
    IMM_TYPE_NONE, // For R-type or when immediate is not used by ALU operand B or for address calculation
    IMM_TYPE_I,    // I-type (ADDI, LW, JALR)
    IMM_TYPE_S,    // S-type (SW)
    IMM_TYPE_B,    // B-type (Branches)
    IMM_TYPE_U,    // U-type (LUI, AUIPC)
    IMM_TYPE_J,     // J-type (JAL)
    IMM_TYPE_ISHIFT // Новый тип для SLLI, SRLI, SRAI
} immediate_type_e;

`endif // IMMEDIATE_TYPES_SVH


--- File: rtl/common/pipeline_types.svh ---
// common/pipeline_types.svh
`ifndef PIPELINE_TYPES_SVH
`define PIPELINE_TYPES_SVH

`include "common/defines.svh"
`include "common/alu_defines.svh"
`include "common/control_signals_defines.svh"
`include "common/immediate_types.svh"

// Data from Fetch to Decode
typedef struct packed {
    logic [`INSTR_WIDTH-1:0]    instr;
    logic [`DATA_WIDTH-1:0]     pc;
    logic [`DATA_WIDTH-1:0]     pc_plus_4;
} if_id_data_t;

// Data from Decode to Execute
typedef struct packed {
    // Control Signals
    logic                       reg_write;
    logic [1:0]                 result_src; // 00:ALU, 01:MemRead, 10:PC+4
    logic                       mem_write;
    logic                       jump;
    logic                       branch;
    logic                       alu_src;    // Selects ALU OpB (0: Reg_Rs2, 1: Imm)
    logic [`ALU_CONTROL_WIDTH-1:0] alu_control;
    alu_a_src_sel_e             op_a_sel;
    pc_target_src_sel_e         pc_target_src_sel;
    logic [2:0]                 funct3;     // Pipelined funct3

    // Data
    logic [`DATA_WIDTH-1:0]     pc;
    logic [`DATA_WIDTH-1:0]     pc_plus_4;
    logic [`DATA_WIDTH-1:0]     rs1_data;
    logic [`DATA_WIDTH-1:0]     rs2_data;
    logic [`DATA_WIDTH-1:0]     imm_ext;

    // Register Addresses
    logic [`REG_ADDR_WIDTH-1:0] rs1_addr;
    logic [`REG_ADDR_WIDTH-1:0] rs2_addr;
    logic [`REG_ADDR_WIDTH-1:0] rd_addr;
} id_ex_data_t;

// Data from Execute to Memory
typedef struct packed {
    // Control Signals
    logic                       reg_write;
    logic [1:0]                 result_src;
    logic                       mem_write;
    logic [2:0]                 funct3;     // For memory access type

    // Data
    logic [`DATA_WIDTH-1:0]     alu_result; // Effective address or ALU result
    logic [`DATA_WIDTH-1:0]     rs2_data;   // Data to be stored
    logic [`DATA_WIDTH-1:0]     pc_plus_4;  // For JAL/JALR writeback

    // Register Address
    logic [`REG_ADDR_WIDTH-1:0] rd_addr;
} ex_mem_data_t;

// Data from Memory to Writeback
typedef struct packed {
    // Control Signals
    logic                       reg_write;
    logic [1:0]                 result_src;

    // Data
    logic [`DATA_WIDTH-1:0]     read_data_mem; // Data read from memory
    logic [`DATA_WIDTH-1:0]     alu_result;    // ALU result from EX
    logic [`DATA_WIDTH-1:0]     pc_plus_4;     // PC+4 from EX

    // Register Address
    logic [`REG_ADDR_WIDTH-1:0] rd_addr;
} mem_wb_data_t;

// Data for actual writeback to Register File (subset of mem_wb_data_t + selected result)
typedef struct packed {
    logic                       reg_write_en;
    logic [`REG_ADDR_WIDTH-1:0] rd_addr;
    logic [`DATA_WIDTH-1:0]     result_to_rf;
} rf_write_data_t;


// Control signals from Hazard Unit
typedef struct packed {
    logic       stall_f;
    logic       stall_d; // Stalls IF/ID latching new data
    logic       flush_d; // Clears IF/ID outputs (inserts NOP)
    logic       flush_e; // Clears ID/EX outputs (inserts NOP)
    logic [1:0] forward_a_e;
    logic [1:0] forward_b_e;
} hazard_control_t;


// NOP default values for pipeline data structures
// Used for reset and flushing stages

localparam if_id_data_t NOP_IF_ID_DATA = '{
    instr:      `NOP_INSTRUCTION,
    pc:         `PC_RESET_VALUE, // Or other defined "safe" PC
    pc_plus_4:  `PC_RESET_VALUE + 4 // Or other defined "safe" PC+4
};

localparam id_ex_data_t NOP_ID_EX_DATA = '{
    reg_write:          1'b0,
    result_src:         2'b00, // ALU Result
    mem_write:          1'b0,
    jump:               1'b0,
    branch:             1'b0,
    alu_src:            1'b0,  // Operand B from Reg
    alu_control:        `ALU_OP_ADD, // Default ADD
    op_a_sel:           ALU_A_SRC_RS1,
    pc_target_src_sel:  PC_TARGET_SRC_PC_PLUS_IMM,
    funct3:             3'b000,
    pc:                 `DATA_WIDTH'(0),
    pc_plus_4:          `DATA_WIDTH'(0),
    rs1_data:           `DATA_WIDTH'(0),
    rs2_data:           `DATA_WIDTH'(0),
    imm_ext:            `DATA_WIDTH'(0),
    rs1_addr:           `REG_ADDR_WIDTH'(0),
    rs2_addr:           `REG_ADDR_WIDTH'(0),
    rd_addr:            `REG_ADDR_WIDTH'(0)
};

localparam ex_mem_data_t NOP_EX_MEM_DATA = '{
    reg_write:          1'b0,
    result_src:         2'b00,
    mem_write:          1'b0,
    funct3:             3'b000,
    alu_result:         `DATA_WIDTH'(0),
    rs2_data:           `DATA_WIDTH'(0),
    pc_plus_4:          `DATA_WIDTH'(0),
    rd_addr:            `REG_ADDR_WIDTH'(0)
};

localparam mem_wb_data_t NOP_MEM_WB_DATA = '{
    reg_write:          1'b0,
    result_src:         2'b00,
    read_data_mem:      `DATA_WIDTH'(0),
    alu_result:         `DATA_WIDTH'(0),
    pc_plus_4:          `DATA_WIDTH'(0),
    rd_addr:            `REG_ADDR_WIDTH'(0)
};

`endif // PIPELINE_TYPES_SVH


--- File: rtl/common/defines.svh ---
`ifndef COMMON_DEFINES_SVH
`define COMMON_DEFINES_SVH

`define DATA_WIDTH 64
`define INSTR_WIDTH 32
`define REG_ADDR_WIDTH 5
`define PC_RESET_VALUE 64'h00000000 // Standard PC reset value
`define NOP_INSTRUCTION 32'h00000013 // addi x0, x0, 0

`endif


--- File: rtl/common/control_signals_defines.svh ---
// rtl/common/control_signals_defines.svh
`ifndef CONTROL_SIGNALS_DEFINES_SVH
`define CONTROL_SIGNALS_DEFINES_SVH

// Selector for ALU Operand A
typedef enum logic [1:0] {
    ALU_A_SRC_RS1,   // Select RS1 data
    ALU_A_SRC_PC,    // Select PC
    ALU_A_SRC_ZERO   // Select constant Zero (for LUI: 0 + Imm)
    // ALU_A_SRC_FWD // Will be handled by forwarding logic, this selects the *original* source
} alu_a_src_sel_e;

// Selector for PC Target Address source in Execute stage
typedef enum logic [0:0] { // Only two main sources for now
    PC_TARGET_SRC_PC_PLUS_IMM, // Target = PC + Immediate (for Branch, JAL)
    PC_TARGET_SRC_ALU_JALR     // Target = (ALU_Result from RS1+Imm) & ~1 (for JALR)
} pc_target_src_sel_e;

`endif // CONTROL_SIGNALS_DEFINES_SVH


--- File: rtl/common/alu_defines.svh ---
// rtl/common/alu_defines.svh
`ifndef ALU_DEFINES_SVH
`define ALU_DEFINES_SVH

`define ALU_CONTROL_WIDTH 4 // Needs 4 bits for ~10 operations

// Unified ALU Control Signals
// R-Type / I-Type Arithmetic
`define ALU_OP_ADD  4'b0000 // Addition
`define ALU_OP_SUB  4'b0001 // Subtraction
`define ALU_OP_SLL  4'b0010 // Shift Left Logical
`define ALU_OP_SLT  4'b0011 // Set Less Than (Signed)
`define ALU_OP_SLTU 4'b0100 // Set Less Than (Unsigned)
`define ALU_OP_XOR  4'b0101 // XOR
`define ALU_OP_SRL  4'b0110 // Shift Right Logical
`define ALU_OP_SRA  4'b0111 // Shift Right Arithmetic
`define ALU_OP_OR   4'b1000 // OR
`define ALU_OP_AND  4'b1001 // AND

// Potentially other operations for specific instructions if needed, e.g., pass Operand B
// `define ALU_OP_PASS_B 4'b1010 // Pass operand_b directly (e.g., for LUI if srcA is 0)
// For LUI, it's rd = imm. If ALU is used, srcA=0, srcB=imm, op=ADD. So ALU_OP_ADD works.
// For AUIPC, it's rd = pc + imm. srcA=PC, srcB=imm, op=ADD. So ALU_OP_ADD works.

`endif // ALU_DEFINES_SVH


--- File: rtl/pipeline.sv ---
// rtl/pipeline.sv
`default_nettype none
`timescale 1ns/1ps

`include "common/pipeline_types.svh" // Includes all other necessary common files

module pipeline (
    input  logic clk,
    input  logic rst_n,

    // Optional debug outputs
    output logic [`DATA_WIDTH-1:0] debug_pc_f,
    output logic [`INSTR_WIDTH-1:0] debug_instr_f,
    output logic                   debug_reg_write_wb,
    output logic [`REG_ADDR_WIDTH-1:0] debug_rd_addr_wb,
    output logic [`DATA_WIDTH-1:0] debug_result_w
);

    // Pipeline stage data registers (latches between stages)
    // _q holds the current (stable) output of the register for this cycle
    // _d holds the input to the register, to be latched on the next clock edge
    if_id_data_t    if_id_data_q, if_id_data_d;
    id_ex_data_t    id_ex_data_q, id_ex_data_d;
    ex_mem_data_t   ex_mem_data_q, ex_mem_data_d;
    mem_wb_data_t   mem_wb_data_q, mem_wb_data_d;

    // Data coming out of the combinational stages
    if_id_data_t    if_id_data_from_fetch;
    id_ex_data_t    id_ex_data_from_decode;
    ex_mem_data_t   ex_mem_data_from_execute;
    mem_wb_data_t   mem_wb_data_from_memory;
    rf_write_data_t rf_write_data_from_wb; // Final data for Register File

    // Signals for PC update and Hazard Unit
    logic                   pc_src_ex_o;
    logic [`DATA_WIDTH-1:0] pc_target_ex_o;
    hazard_control_t        hazard_ctrl;

    // Extracted signals from Decode for Hazard Unit (rs1_addr_d, rs2_addr_d on diagram)
    logic [`REG_ADDR_WIDTH-1:0] rs1_addr_from_decode;
    logic [`REG_ADDR_WIDTH-1:0] rs2_addr_from_decode;


    // Pipeline Stage Instantiation
    fetch u_fetch (
        .clk                (clk),
        .rst_n              (rst_n),
        .stall_f_i          (hazard_ctrl.stall_f),
        .pc_src_e_i         (pc_src_ex_o),          // From Execute stage of previous cycle
        .pc_target_e_i      (pc_target_ex_o),       // From Execute stage of previous cycle
        .if_id_data_o       (if_id_data_from_fetch)
    );

    decode u_decode (
        .clk                (clk),
        .rst_n              (rst_n),
        .if_id_data_i       (if_id_data_q),         // Data from IF/ID latch
        .writeback_data_i   (rf_write_data_from_wb),// Data from Writeback stage
        .id_ex_data_o       (id_ex_data_from_decode),
        .rs1_addr_d_o       (rs1_addr_from_decode), // For Hazard Unit
        .rs2_addr_d_o       (rs2_addr_from_decode)  // For Hazard Unit
    );

    execute u_execute (
        // .clk             (clk), // Combinational
        // .rst_n           (rst_n),// Combinational
        .id_ex_data_i       (id_ex_data_q),         // Data from ID/EX latch
        .forward_data_mem_i (ex_mem_data_q.alu_result), // Data from EX/MEM latch (ALUResultM on diagram)
                                                        // If ex_mem_data_q was a load, its read_data is not ready yet for this path.
                                                        // P&H diagram implies ALUResultM for this path.
        .forward_data_wb_i  (rf_write_data_from_wb.result_to_rf), // Data from Writeback stage (ResultW)
        .forward_a_e_i      (hazard_ctrl.forward_a_e),
        .forward_b_e_i      (hazard_ctrl.forward_b_e),
        .ex_mem_data_o      (ex_mem_data_from_execute),
        .pc_src_o           (pc_src_ex_o),          // To Fetch and Hazard Unit
        .pc_target_addr_o   (pc_target_ex_o)        // To Fetch
    );

    memory_stage u_memory_stage (
        .clk                (clk),
        .rst_n              (rst_n),
        .ex_mem_data_i      (ex_mem_data_q),        // Data from EX/MEM latch
        .mem_wb_data_o      (mem_wb_data_from_memory)
    );

    writeback_stage u_writeback_stage (
        .mem_wb_data_i      (mem_wb_data_q),        // Data from MEM/WB latch
        .rf_write_data_o    (rf_write_data_from_wb)
    );

    pipeline_control u_pipeline_control (
        // Data needed by Hazard Unit.
        // These are the STABLE outputs of the pipeline registers (_q values)
        // or directly from instruction fields for the current ID stage.
        .if_id_data_i       (if_id_data_q),     // For rs1/rs2 addresses of instruction in ID
        .id_ex_data_i       (id_ex_data_q),     // For RdE, RegWriteE, ResultSrcE, Rs1E, Rs2E
        .ex_mem_data_i      (ex_mem_data_q),    // For RdM, RegWriteM
        .mem_wb_data_i      (mem_wb_data_q),    // For RdW, RegWriteW
        .pc_src_from_ex_i   (pc_src_ex_o),      // From Execute stage's output
        .hazard_ctrl_o      (hazard_ctrl)
    );


    // Logic for pipeline registers
    // IF/ID Register Logic
    always_comb begin
        if (hazard_ctrl.flush_d) begin
            if_id_data_d = NOP_IF_ID_DATA;
        end else if (hazard_ctrl.stall_d) begin // Stall_D means IF/ID holds its value
            if_id_data_d = if_id_data_q;
        end else begin
            if_id_data_d = if_id_data_from_fetch;
        end
    end
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            if_id_data_q <= NOP_IF_ID_DATA;
        end else begin
            if_id_data_q <= if_id_data_d;
        end
    end

    // ID/EX Register Logic
    always_comb begin
        if (hazard_ctrl.flush_e) begin // Flush_E (from load-use or branch) clears ID/EX
            id_ex_data_d = NOP_ID_EX_DATA;
        end else begin // No stall_e in this P&H version, Hazard unit stalls earlier stages
            id_ex_data_d = id_ex_data_from_decode;
        end
    end
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            id_ex_data_q <= NOP_ID_EX_DATA;
        end else begin
            id_ex_data_q <= id_ex_data_d;
        end
    end

    // EX/MEM Register Logic (no explicit flush/stall inputs from P&H diagram for this reg)
    // Flushes/stalls propagate by NOPing data in earlier stages.
    assign ex_mem_data_d = ex_mem_data_from_execute;
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            ex_mem_data_q <= NOP_EX_MEM_DATA;
        end else begin
            ex_mem_data_q <= ex_mem_data_d;
        end
    end

    // MEM/WB Register Logic (no explicit flush/stall inputs)
    assign mem_wb_data_d = mem_wb_data_from_memory;
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            mem_wb_data_q <= NOP_MEM_WB_DATA;
        end else begin
            mem_wb_data_q <= mem_wb_data_d;
        end
    end

    // Debug outputs
    assign debug_pc_f         = if_id_data_from_fetch.pc; // PC from current fetch output
    assign debug_instr_f      = if_id_data_from_fetch.instr;
    assign debug_reg_write_wb = rf_write_data_from_wb.reg_write_en;
    assign debug_rd_addr_wb   = rf_write_data_from_wb.rd_addr;
    assign debug_result_w     = rf_write_data_from_wb.result_to_rf;

endmodule


