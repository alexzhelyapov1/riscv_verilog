--- File: tests/CMakeLists.txt ---
add_custom_target(tests_full)
add_subdirectory(unit)


--- File: tests/unit/execute_tb.sv ---
// tests/unit/execute_tb.sv

`include "common/defines.svh"
`include "common/alu_defines.svh"
`include "common/control_signals_defines.svh"

module execute_tb (
    input  logic clk,
    input  logic rst_n,

    // Inputs to control Execute stage behavior (from a virtual ID/EX)
    input  logic       i_reg_write_e,
    input  logic [1:0] i_result_src_e,
    input  logic       i_mem_write_e,
    input  logic       i_jump_e,
    input  logic       i_branch_e,
    input  logic       i_alu_src_e,
    input  logic [`ALU_CONTROL_WIDTH-1:0] i_alu_control_e,
    input  logic [2:0] i_funct3_e,
    input  alu_a_src_sel_e i_op_a_sel_e,
    input  pc_target_src_sel_e i_pc_target_src_sel_e,

    input  logic [`DATA_WIDTH-1:0]  i_pc_e,
    input  logic [`DATA_WIDTH-1:0]  i_pc_plus_4_e,
    input  logic [`DATA_WIDTH-1:0]  i_rs1_data_e,
    input  logic [`DATA_WIDTH-1:0]  i_rs2_data_e,
    input  logic [`DATA_WIDTH-1:0]  i_imm_ext_e,
    input  logic [`REG_ADDR_WIDTH-1:0] i_rd_addr_e,

    // Outputs from Execute stage (to observe, these go to EX/MEM)
    output logic       o_reg_write_m,
    output logic [1:0] o_result_src_m,
    output logic       o_mem_write_m,
    output logic [`DATA_WIDTH-1:0] o_alu_result_m,
    output logic [`DATA_WIDTH-1:0] o_rs2_data_m,
    output logic [`REG_ADDR_WIDTH-1:0] o_rd_addr_m,
    output logic [`DATA_WIDTH-1:0] o_pc_plus_4_m,
    output logic [2:0] o_funct3_m,

    // Outputs that affect PC
    output logic       o_pc_src_e,
    output logic [`DATA_WIDTH-1:0] o_pc_target_addr_e
);

    // Instantiate Execute stage
    execute u_execute (
        .clk            (clk), // clk/rst_n not used by execute.sv currently, but good to have for future
        .rst_n          (rst_n),

        .reg_write_e_i  (i_reg_write_e),
        .result_src_e_i (i_result_src_e),
        .mem_write_e_i  (i_mem_write_e),
        .jump_e_i       (i_jump_e),
        .branch_e_i     (i_branch_e),
        .alu_src_e_i    (i_alu_src_e),
        .alu_control_e_i(i_alu_control_e),
        .funct3_e_i     (i_funct3_e),
        .op_a_sel_e_i   (i_op_a_sel_e),
        .pc_target_src_sel_e_i (i_pc_target_src_sel_e),
        .pc_e_i         (i_pc_e),
        .pc_plus_4_e_i  (i_pc_plus_4_e),
        .rs1_data_e_i   (i_rs1_data_e),
        .rs2_data_e_i   (i_rs2_data_e),
        .imm_ext_e_i    (i_imm_ext_e),
        .rd_addr_e_i    (i_rd_addr_e),

        .reg_write_m_o  (o_reg_write_m),
        .result_src_m_o (o_result_src_m),
        .mem_write_m_o  (o_mem_write_m),
        .alu_result_m_o (o_alu_result_m),
        .rs2_data_m_o   (o_rs2_data_m),
        .rd_addr_m_o    (o_rd_addr_m),
        .pc_plus_4_m_o  (o_pc_plus_4_m),
        .funct3_m_o     (o_funct3_m),
        .pc_src_e_o     (o_pc_src_e),
        .pc_target_addr_e_o (o_pc_target_addr_e)
    );

endmodule


--- File: tests/unit/decode_tb.sv ---
// tests/unit/decode_tb.sv
`include "common/defines.svh"
`include "common/alu_defines.svh"          // For ALU_CONTROL_WIDTH
`include "common/control_signals_defines.svh" // For alu_a_src_sel_e, pc_target_src_sel_e

module decode_tb (
    input  logic clk,
    input  logic rst_n,

    // Inputs to control the test environment
    // To IF/ID register
    input  logic                       i_if_id_stall_d, // Stall for if_id register
    input  logic                       i_if_id_flush_d, // Flush for if_id register
    input  logic [`INSTR_WIDTH-1:0]    i_instr_f,       // Instruction from a virtual "fetch"
    input  logic [`DATA_WIDTH-1:0]     i_pc_f,          // PC from a virtual "fetch"
    input  logic [`DATA_WIDTH-1:0]     i_pc_plus_4_f,   // PC+4 from a virtual "fetch"

    // To Register File (for initialization during test, and Writeback simulation)
    input  logic                       i_wb_write_en,
    input  logic [`REG_ADDR_WIDTH-1:0] i_wb_rd_addr,
    input  logic [`DATA_WIDTH-1:0]     i_wb_rd_data,

    // Outputs from Decode stage (to observe)
    // Control Signals
    output logic       o_reg_write_d,
    output logic [1:0] o_result_src_d,
    output logic       o_mem_write_d,
    output logic       o_jump_d,
    output logic       o_branch_d,
    output logic       o_alu_src_d, // Selects ALU Operand B
    output logic [`ALU_CONTROL_WIDTH-1:0] o_alu_control_d,
    output logic [2:0] o_funct3_d,
    output alu_a_src_sel_e o_op_a_sel_d,
    output pc_target_src_sel_e o_pc_target_src_sel_d,

    // Data
    output logic [`DATA_WIDTH-1:0]  o_pc_d,
    output logic [`DATA_WIDTH-1:0]  o_pc_plus_4_d,
    output logic [`DATA_WIDTH-1:0]  o_rs1_data_d,
    output logic [`DATA_WIDTH-1:0]  o_rs2_data_d,
    output logic [`DATA_WIDTH-1:0]  o_imm_ext_d,

    // Register addresses
    output logic [`REG_ADDR_WIDTH-1:0] o_rs1_addr_d,
    output logic [`REG_ADDR_WIDTH-1:0] o_rs2_addr_d,
    output logic [`REG_ADDR_WIDTH-1:0] o_rd_addr_d,

    // Output from IF/ID for sanity check
    output logic [`INSTR_WIDTH-1:0]    o_instr_id,
    output logic [`DATA_WIDTH-1:0]     o_pc_id,
    output logic [`DATA_WIDTH-1:0]     o_pc_plus_4_id
);

    // Signals between IF/ID and Decode
    logic [`INSTR_WIDTH-1:0]    instr_id_val;
    logic [`DATA_WIDTH-1:0]     pc_id_val;
    logic [`DATA_WIDTH-1:0]     pc_plus_4_id_val;

    // IF/ID Register instance
    if_id_register u_if_id_reg (
        .clk            (clk),
        .rst_n          (rst_n),
        .stall_d        (i_if_id_stall_d),
        .flush_d        (i_if_id_flush_d),
        .instr_f_i      (i_instr_f),
        .pc_f_i         (i_pc_f),
        .pc_plus_4_f_i  (i_pc_plus_4_f),
        .instr_id_o     (instr_id_val),
        .pc_id_o        (pc_id_val),
        .pc_plus_4_id_o (pc_plus_4_id_val)
    );

    // Decode Stage instance
    decode u_decode (
        .clk                (clk),
        .rst_n              (rst_n),
        .instr_id_i         (instr_id_val),
        .pc_id_i            (pc_id_val),
        .pc_plus_4_id_i     (pc_plus_4_id_val),
        .rd_write_en_wb_i   (i_wb_write_en),
        .rd_addr_wb_i       (i_wb_rd_addr),
        .rd_data_wb_i       (i_wb_rd_data),

        .reg_write_d_o      (o_reg_write_d),
        .result_src_d_o     (o_result_src_d),
        .mem_write_d_o      (o_mem_write_d),
        .jump_d_o           (o_jump_d),
        .branch_d_o         (o_branch_d),
        .alu_src_d_o        (o_alu_src_d),
        .alu_control_d_o    (o_alu_control_d),
        .funct3_d_o         (o_funct3_d),
        .op_a_sel_d_o       (o_op_a_sel_d),
        .pc_target_src_sel_d_o (o_pc_target_src_sel_d),

        .pc_d_o             (o_pc_d),
        .pc_plus_4_d_o      (o_pc_plus_4_d),
        .rs1_data_d_o       (o_rs1_data_d),
        .rs2_data_d_o       (o_rs2_data_d),
        .imm_ext_d_o        (o_imm_ext_d),
        .rs1_addr_d_o       (o_rs1_addr_d),
        .rs2_addr_d_o       (o_rs2_addr_d),
        .rd_addr_d_o        (o_rd_addr_d)
    );

    // Assign IF/ID outputs for observation
    assign o_instr_id     = instr_id_val;
    assign o_pc_id        = pc_id_val;
    assign o_pc_plus_4_id = pc_plus_4_id_val;

endmodule


--- File: tests/unit/fetch_tb.cpp ---
#include "Vfetch_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>

// Ð’ defines.svh INSTR_WIDTH = 32, DATA_WIDTH = 64
const uint32_t NOP_INSTRUCTION = 0x00000013;

vluint64_t sim_time = 0;

void tick(Vfetch_tb* dut, VerilatedVcdC* tfp) {
    dut->clk = 0;
    dut->eval();
    if (tfp) tfp->dump(sim_time);
    sim_time++;

    dut->clk = 1;
    dut->eval();
    if (tfp) tfp->dump(sim_time);
    sim_time++;
}

void reset_dut(Vfetch_tb* dut, VerilatedVcdC* tfp) {
    dut->rst_n = 0;
    // Initialize inputs to known safe values during reset
    dut->i_stall_f = 0;
    dut->i_pc_src_e = 0;
    dut->i_pc_target_e = 0;
    dut->i_stall_d = 0;
    dut->i_flush_d = 0;
    for (int i = 0; i < 5; ++i) { // Hold reset for a few cycles
        tick(dut, tfp);
    }
    dut->rst_n = 1;
    tick(dut, tfp); // One tick out of reset
    std::cout << "DUT Reset" << std::endl;
}


int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vfetch_tb* top = new Vfetch_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_fetch.vcd");

    std::cout << "Starting Fetch Stage Testbench" << std::endl;

    reset_dut(top, tfp);

    // Test Case 1: Basic sequential fetch
    std::cout << "Test Case 1: Sequential Fetch" << std::endl;
    top->i_stall_f = 0;
    top->i_pc_src_e = 0;
    top->i_pc_target_e = 0; // Don't care
    top->i_stall_d = 0;
    top->i_flush_d = 0;

    // Cycle 1: PC=0, Fetch instr @0. IF/ID gets this after this cycle.
    tick(top, tfp);
    std::cout << "  PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected after reset and first tick: PC_F=0. IF/ID output still from reset state or previous garbage before first valid data.
    // After PC=0 is fetched, on the NEXT rising edge, IF/ID will latch PC=0 and Instr @0.

    // Cycle 2: PC=0 latched into IF/ID. Fetch stage moves to PC=4.
    tick(top, tfp);
    std::cout << "  PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=4. IF/ID PC=0, Instr = mem[0] (0x00100093)

    // Cycle 3: PC=4 latched into IF/ID. Fetch stage moves to PC=8.
    tick(top, tfp);
    std::cout << "  PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=8. IF/ID PC=4, Instr = mem[1] (0x00200113)


    // Test Case 2: Stall Fetch (StallF)
    std::cout << "\nTest Case 2: Stall Fetch (stall_f)" << std::endl;
    top->i_stall_f = 1; // Stall PC update
    top->i_stall_d = 0; // IF/ID register loads normally
    // PC_F was 8. It should remain 8. Instr_F will be from PC=8.
    // IF/ID will latch current Instr_F and PC_F+4.
    // Previous IF/ID instr was mem[1] (from PC=4).
    tick(top, tfp); // PC=8 (stalled), instr_f = mem[8/4=2]. IF/ID gets (instr @ PC=8, PC=8+4)
    std::cout << "  StallF=1. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=8. IF/ID PC=8, Instr = mem[2] (0x00308193)

    tick(top, tfp); // PC=8 (still stalled), instr_f = mem[8/4=2]. IF/ID re-latches same values.
    std::cout << "  StallF=1. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=8. IF/ID PC=8, Instr = mem[2]

    top->i_stall_f = 0; // Release stall_f


    // Test Case 3: Stall Decode (StallD)
    std::cout << "\nTest Case 3: Stall Decode (stall_d)" << std::endl;
    // PC_F was 8. Now stall_f=0, so PC will advance to 12. instr_f = mem[12/4=3].
    // IF/ID was (PC=8, instr=mem[2]). Now stall_d=1, so IF/ID holds its value.
    top->i_stall_d = 1;
    tick(top, tfp);
    std::cout << "  StallD=1. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=12 (0xC). IF/ID PC=8, Instr = mem[2] (holds previous)

    // PC_F advances to 16. instr_f = mem[16/4=4].
    // IF/ID still holds (PC=8, instr=mem[2]).
    tick(top, tfp);
    std::cout << "  StallD=1. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=16 (0x10). IF/ID PC=8, Instr = mem[2]

    top->i_stall_d = 0; // Release stall_d


    // Test Case 4: Flush Decode (FlushD)
    std::cout << "\nTest Case 4: Flush Decode (flush_d)" << std::endl;
    // PC_F was 16. Now stall_d=0, PC advances to 20. instr_f = mem[20/4=5].
    // IF/ID was (PC=8, instr=mem[2]). Now flush_d=1. IF/ID should be NOP.
    top->i_flush_d = 1;
    tick(top, tfp);
    std::cout << "  FlushD=1. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=20 (0x14). IF/ID PC=0, Instr = NOP (0x13)

    top->i_flush_d = 0; // Release flush_d
    tick(top, tfp); // PC_F advances to 24. IF/ID gets (instr @ PC=20, PC=20+4)
    std::cout << "  FlushD=0. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=24 (0x18). IF/ID PC=20, Instr = mem[5]

    // Test Case 5: Branch Taken (pc_src_e)
    std::cout << "\nTest Case 5: Branch Taken" << std::endl;
    top->i_pc_src_e = 1;
    top->i_pc_target_e = 0x100; // Jump to address 0x100
    // PC_F was 24. Next PC should be 0x100. instr_f will be mem[0x100/4].
    // IF/ID was (PC=20, instr=mem[5]). IF/ID gets (instr @ PC=0x100, PC=0x100+4)
    tick(top, tfp);
    std::cout << "  Branch. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=0x100. IF/ID PC=0x100, Instr = mem[0x100/4] (which is NOP by default init)

    top->i_pc_src_e = 0; // Next cycle, no branch
    tick(top, tfp); // PC_F advances to 0x104. IF/ID gets (instr @ PC=0x100, PC=0x100+4)
    std::cout << "  After Branch. PC_F: 0x" << std::hex << top->o_current_pc_f
              << " -> IF/ID PC: 0x" << top->o_pc_id
              << " Instr: 0x" << top->o_instr_id << std::dec << std::endl;
    // Expected: PC_F=0x104. IF/ID PC=0x100, Instr = mem[0x100/4]


    std::cout << "\nFetch Stage Testbench Finished." << std::endl;

    if (tfp) tfp->close();
    delete top;
    return 0;
}


--- File: tests/unit/alu.cpp ---
// tests/unit/alu.cpp
#include "Valu.h" // Verilator generated header for alu module
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cassert>
#include <cstdint>
#include <string>
#include <vector>
#include <bitset>

// New ALU Control Opcodes (from alu_defines.svh)
const uint8_t ALU_OP_ADD  = 0b0000;
const uint8_t ALU_OP_SUB  = 0b0001;
const uint8_t ALU_OP_SLL  = 0b0010;
const uint8_t ALU_OP_SLT  = 0b0011;
const uint8_t ALU_OP_SLTU = 0b0100;
const uint8_t ALU_OP_XOR  = 0b0101;
const uint8_t ALU_OP_SRL  = 0b0110;
const uint8_t ALU_OP_SRA  = 0b0111;
const uint8_t ALU_OP_OR   = 0b1000;
const uint8_t ALU_OP_AND  = 0b1001;
// const uint8_t ALU_OP_PASS_B = 0b1010; // If added

vluint64_t sim_time = 0;

// Verilator simulation time function (if not using sc_core::sc_time_stamp)
double sc_time_stamp() {
    return sim_time;
}

void eval_alu(Valu* alu_core, VerilatedVcdC* tfp) {
    alu_core->eval();
    if (tfp) tfp->dump(sim_time);
}

struct AluTestCase {
    uint64_t a, b;
    uint8_t alu_control_val; // Changed from alu_op_sel and alu_mod
    uint64_t expected_res;
    bool expected_zero;
    std::string name;
};

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Valu* top = new Valu; // Name of the Verilog module is 'alu', Verilator prepends 'V'

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_alu.vcd");

    std::cout << "Starting Unified ALU Testbench (RV64)" << std::endl;

    AluTestCase tests[] = {
        // ADD tests
        {5, 10, ALU_OP_ADD, 15, false, "ADD 5+10"},
        {0xFFFFFFFFFFFFFFFFULL, 1, ALU_OP_ADD, 0, true, "ADD -1+1 (wrap)"},
        {0x7FFFFFFFFFFFFFFFULL, 1, ALU_OP_ADD, 0x8000000000000000ULL, false, "ADD MAX_POS+1 (signed ovf)"},

        // SUB tests
        {10, 5, ALU_OP_SUB, 5, false, "SUB 10-5"},
        {5, 10, ALU_OP_SUB, (uint64_t)-5, false, "SUB 5-10"},
        {0x8000000000000000ULL, 1, ALU_OP_SUB, 0x7FFFFFFFFFFFFFFFULL, false, "SUB MIN_NEG-1 (signed ovf)"},
        {10, 10, ALU_OP_SUB, 0, true, "SUB 10-10 (zero)"},

        // Logical tests
        {0xF0F0F0F0F0F0F0F0ULL, 0x0F0F0F0F0F0F0F0FULL, ALU_OP_AND, 0x00ULL, true, "AND all zeros"},
        {0xF0F0F0F0F0F0F0F0ULL, 0xFFFFFFFFFFFFFFFFULL, ALU_OP_AND, 0xF0F0F0F0F0F0F0F0ULL, false, "AND with FFs"},
        {0xF0F0F0F0F0F0F0F0ULL, 0x0F0F0F0F0F0F0F0FULL, ALU_OP_OR,  0xFFFFFFFFFFFFFFFFULL, false, "OR"},
        {0xFF00FF00FF00FF00ULL, 0x00FFFF00FFFF00FFULL, ALU_OP_XOR, 0xFFFF000000FFFFFFULL, false, "XOR"},

        // SLT / SLTU tests
        {5, 10, ALU_OP_SLT, 1, false, "SLT 5<10 (signed)"},
        {10, 5, ALU_OP_SLT, 0, true, "SLT 10<5 (signed)"},
        {(uint64_t)-5, 2, ALU_OP_SLT, 1, false, "SLT -5<2 (signed)"},
        {2, (uint64_t)-5, ALU_OP_SLT, 0, true, "SLT 2<-5 (signed)"},
        {(uint64_t)-10, (uint64_t)-5, ALU_OP_SLT, 1, false, "SLT -10<-5 (signed)"},

        {5, 10, ALU_OP_SLTU, 1, false, "SLTU 5<10 (unsigned)"},
        {10, 5, ALU_OP_SLTU, 0, true, "SLTU 10<5 (unsigned)"},
        {(uint64_t)-5, 2, ALU_OP_SLTU, 0, true, "SLTU large_val<2 (unsigned, -5 is large positive)"}, // -5ULL is large positive
        {2, (uint64_t)-5, ALU_OP_SLTU, 1, false, "SLTU 2<large_val (unsigned)"},

        // Shift tests
        {0x1ULL, 3, ALU_OP_SLL, 0x8ULL, false, "SLL 1<<3 (shamt=3)"},
        {0xABCDEF0123456789ULL, 64, ALU_OP_SLL, 0xABCDEF0123456789ULL, false, "SLL by 64 (actual shamt=0)"}, // operand_b[5:0] is 0
        {0xABCDEF0123456789ULL, 0, ALU_OP_SLL, 0xABCDEF0123456789ULL, false, "SLL by 0"},

        {0xF00000000000000FULL, 4, ALU_OP_SRL, 0x0F00000000000000ULL, false, "SRL positive val"},
        {0x8000000000000000ULL, 1, ALU_OP_SRL, 0x4000000000000000ULL, false, "SRL MSB set val"},

        {0x8000000000000000ULL, 1, ALU_OP_SRA, 0xC000000000000000ULL, false, "SRA negative val"},
        {0x4000000000000000ULL, 1, ALU_OP_SRA, 0x2000000000000000ULL, false, "SRA positive val"},
        {0xFFFFFFFFFFFFFFF0ULL, 4, ALU_OP_SRA, 0xFFFFFFFFFFFFFFFFULL, false, "SRA -16 >> 4 = -1"}

        // Test for PASS_B if added
        // {123, 456, ALU_OP_PASS_B, 456, false, "PASS_B"}
    };

    int num_tests = sizeof(tests) / sizeof(AluTestCase);
    int passed_tests = 0;

    for (int i = 0; i < num_tests; ++i) {
        AluTestCase& t = tests[i];

        top->operand_a = t.a;
        top->operand_b = t.b;
        top->alu_control = t.alu_control_val; // Use the new unified control signal

        eval_alu(top, tfp);
        sim_time++; // Increment simulation time for VCD

        bool pass = (top->result == t.expected_res) &&
                    (top->zero_flag == t.expected_zero);

        if (pass) {
            passed_tests++;
        } else {
            std::cout << "FAIL Test: " << t.name << std::endl;
            std::cout << "  Input: A=0x" << std::hex << t.a << ", B=0x" << t.b
                      << ", ALUControl=0b" << std::bitset<4>(t.alu_control_val) << std::dec << std::endl;
            std::cout << "  Got  : Res=0x" << std::hex << top->result << ", Zero=" << (int)top->zero_flag << std::dec << std::endl;
            std::cout << "  Exp  : Res=0x" << std::hex << t.expected_res << ", Zero=" << (int)t.expected_zero << std::dec << std::endl;
        }
        assert(pass); // Stop on first failure for easier debugging
    }

    std::cout << "\nUnified ALU Testbench Finished. Passed " << passed_tests << "/" << num_tests << " tests." << std::endl;

    if (tfp) tfp->close();
    delete top;
    exit( (passed_tests == num_tests) ? EXIT_SUCCESS : EXIT_FAILURE );
}


--- File: tests/unit/execute_tb.cpp ---
// tests/unit/execute_tb.cpp
#include "Vexecute_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <string>
#include <map>
#include <bitset>

// C++ equivalents of enums/defines
// From common/alu_defines.svh
const int ALU_CONTROL_WIDTH_CPP = 4; // Renamed to avoid conflict if alu_defines.svh was accidentally included
const uint8_t ALU_OP_ADD_CPP  = 0b0000;
const uint8_t ALU_OP_SUB_CPP  = 0b0001;
const uint8_t ALU_OP_SLT_CPP  = 0b0011;
const uint8_t ALU_OP_SLTU_CPP = 0b0100;
// ... add other ALU_OPs as needed for tests

// From common/control_signals_defines.svh
enum AluASrcSelCppTb {
    ALU_A_SRC_RS1_TB,
    ALU_A_SRC_PC_TB,
    ALU_A_SRC_ZERO_TB
};

enum PcTargetSrcSelCppTb {
    PC_TARGET_SRC_PC_PLUS_IMM_TB,
    PC_TARGET_SRC_ALU_JALR_TB
};

// From common/riscv_opcodes.svh (funct3 codes)
const uint8_t FUNCT3_BEQ_CPP  = 0b000;
const uint8_t FUNCT3_BNE_CPP  = 0b001;
const uint8_t FUNCT3_BLT_CPP  = 0b100;
const uint8_t FUNCT3_BGE_CPP  = 0b101;
const uint8_t FUNCT3_BLTU_CPP = 0b110;
const uint8_t FUNCT3_BGEU_CPP = 0b111;


vluint64_t sim_time_execute = 0; // Separate sim_time to avoid conflict if linked with other VCDs

void tick_execute(Vexecute_tb* dut, VerilatedVcdC* tfp) {
    dut->clk = 0; // execute stage is combinational, but testbench needs clk for VCD
    dut->eval();
    if (tfp) tfp->dump(sim_time_execute);
    sim_time_execute++;
    dut->clk = 1;
    dut->eval();
    if (tfp) tfp->dump(sim_time_execute);
    sim_time_execute++;
}

struct ExecuteTestCase {
    std::string name;
    // Inputs to Execute Stage
    bool        reg_write_e;
    uint8_t     result_src_e;
    bool        mem_write_e;
    bool        jump_e;
    bool        branch_e;
    bool        alu_src_e; // OpB sel
    uint8_t     alu_control_e;
    uint8_t     funct3_e;
    AluASrcSelCppTb op_a_sel_e;
    PcTargetSrcSelCppTb pc_target_src_sel_e;
    uint64_t    pc_e;
    uint64_t    pc_plus_4_e;
    uint64_t    rs1_data_e;
    uint64_t    rs2_data_e;
    uint64_t    imm_ext_e;
    uint8_t     rd_addr_e;

    // Expected Outputs (to EX/MEM)
    bool        exp_reg_write_m;
    uint8_t     exp_result_src_m;
    bool        exp_mem_write_m;
    uint64_t    exp_alu_result_m;
    uint64_t    exp_rs2_data_m; // Data to store
    uint8_t     exp_rd_addr_m;
    uint64_t    exp_pc_plus_4_m;
    uint8_t     exp_funct3_m;

    // Expected Outputs for PC update
    bool        exp_pc_src_e;
    uint64_t    exp_pc_target_addr_e;
};

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vexecute_tb* top = new Vexecute_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("tb_execute.vcd");

    std::cout << "Starting Execute Stage Testbench" << std::endl;
    top->rst_n = 1; // Execute stage is mostly combinational, reset not critical for logic but good for init

    std::vector<ExecuteTestCase> test_cases = {
        { // ADD R-Type: x3 = x1 (10) + x2 (20)
            "ADD R-Type",
            true, 0b00, false, false, false, false, ALU_OP_ADD_CPP, 0, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB,
            0x100, 0x104, 10, 20, 0, 3, // Inputs
            true, 0b00, false, 30, 20, 3, 0x104, 0, // Expected EX/MEM outputs
            false, 0x100 + 0 // Expected PC update (no branch/jump)
        },
        { // ADDI: x1 = x2 (5) + 15
            "ADDI I-Type",
            true, 0b00, false, false, false, true, ALU_OP_ADD_CPP, FUNCT3_BEQ_CPP /*funct3 for addi*/, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB,
            0x200, 0x204, 5, 100/*rs2_data not used*/, 15, 1,
            true, 0b00, false, 20, 100, 1, 0x204, FUNCT3_BEQ_CPP,
            false, 0x200 + 15
        },
        { // LUI: x5 = 0xABCD0000
            "LUI U-Type",
            true, 0b00, false, false, false, true, ALU_OP_ADD_CPP, 0, ALU_A_SRC_ZERO_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB,
            0x300, 0x304, 0/*rs1_data not used*/, 0/*rs2_data not used*/, 0xFFFFFFFFABCD0000ULL, 5,
            true, 0b00, false, 0xFFFFFFFFABCD0000ULL, 0, 5, 0x304, 0,
            false, 0x300 + 0xFFFFFFFFABCD0000ULL // Default target if not jump/branch
        },
        { // AUIPC: x1 = PC(0x400) + 0x12300000
            "AUIPC U-Type",
            true, 0b00, false, false, false, true, ALU_OP_ADD_CPP, 0, ALU_A_SRC_PC_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB,
            0x400, 0x404, 0/*rs1 not used*/, 0/*rs2 not used*/, 0x12300000ULL, 1,
            true, 0b00, false, 0x400 + 0x12300000ULL, 0, 1, 0x404, 0,
            false, 0x400 + 0x12300000ULL
        },
        { // BEQ taken: pc=0x100, rs1=10, rs2=10, imm=0x20. Target=0x120
            "BEQ Branch Taken",
            false, 0b00, false, false, true, false, ALU_OP_SUB_CPP, FUNCT3_BEQ_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB,
            0x100, 0x104, 10, 10, 0x20, 0/*rd not written*/,
            false, 0b00, false, 0/*ALU res*/, 10/*rs2_data*/, 0, 0x104, FUNCT3_BEQ_CPP,
            true, 0x100 + 0x20
        },
        { // BNE not taken: pc=0x100, rs1=10, rs2=10, imm=0x20. Target=PC+4
            "BNE Branch Not Taken",
            false, 0b00, false, false, true, false, ALU_OP_SUB_CPP, FUNCT3_BNE_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB,
            0x100, 0x104, 10, 10, 0x20, 0,
            false, 0b00, false, 0, 10, 0, 0x104, FUNCT3_BNE_CPP,
            false, 0x100 + 0x20 // pc_target_addr still calculated
        },
        { // JALR: rd=x1, rs1=x2(0x1000), imm=0x80. Target=(0x1000+0x80)&~1 = 0x1080. rd=PC+4
            "JALR Jump",
            true, 0b10/*PC+4*/, false, true, false, true, ALU_OP_ADD_CPP, FUNCT3_BEQ_CPP/*funct3 for jalr*/, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_ALU_JALR_TB,
            0x500, 0x504, 0x1000, 0/*rs2 not used*/, 0x80, 1,
            true, 0b10, false, 0x1080/*ALURes*/, 0, 1, 0x504, FUNCT3_BEQ_CPP,
            true, (0x1000 + 0x80) & ~1ULL
        },
        // Add more cases: LW, SW, other branches, JAL
    };

    int passed_count = 0;
    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name << std::endl;

        // Apply inputs
        top->i_reg_write_e = tc.reg_write_e;
        top->i_result_src_e = tc.result_src_e;
        top->i_mem_write_e = tc.mem_write_e;
        top->i_jump_e = tc.jump_e;
        top->i_branch_e = tc.branch_e;
        top->i_alu_src_e = tc.alu_src_e;
        top->i_alu_control_e = tc.alu_control_e;
        top->i_funct3_e = tc.funct3_e;
        top->i_op_a_sel_e = static_cast<uint8_t>(tc.op_a_sel_e);
        top->i_pc_target_src_sel_e = static_cast<uint8_t>(tc.pc_target_src_sel_e);
        top->i_pc_e = tc.pc_e;
        top->i_pc_plus_4_e = tc.pc_plus_4_e;
        top->i_rs1_data_e = tc.rs1_data_e;
        top->i_rs2_data_e = tc.rs2_data_e;
        top->i_imm_ext_e = tc.imm_ext_e;
        top->i_rd_addr_e = tc.rd_addr_e;

        tick_execute(top, tfp); // Evaluate combinational logic

        bool current_pass = true;
        // Check EX/MEM outputs
        if(top->o_reg_write_m != tc.exp_reg_write_m) {std::cout << "  FAIL: o_reg_write_m. Exp=" << tc.exp_reg_write_m << " Got=" << (int)top->o_reg_write_m << std::endl; current_pass=false;}
        if(top->o_result_src_m != tc.exp_result_src_m) {std::cout << "  FAIL: o_result_src_m. Exp=" << (int)tc.exp_result_src_m << " Got=" << (int)top->o_result_src_m << std::endl; current_pass=false;}
        if(top->o_mem_write_m != tc.exp_mem_write_m) {std::cout << "  FAIL: o_mem_write_m. Exp=" << tc.exp_mem_write_m << " Got=" << (int)top->o_mem_write_m << std::endl; current_pass=false;}
        if(top->o_alu_result_m != tc.exp_alu_result_m) {std::cout << "  FAIL: o_alu_result_m. Exp=0x" << std::hex << tc.exp_alu_result_m << " Got=0x" << top->o_alu_result_m << std::dec << std::endl; current_pass=false;}
        if(top->o_rs2_data_m != tc.exp_rs2_data_m) {std::cout << "  FAIL: o_rs2_data_m. Exp=0x" << std::hex << tc.exp_rs2_data_m << " Got=0x" << top->o_rs2_data_m << std::dec << std::endl; current_pass=false;}
        if(top->o_rd_addr_m != tc.exp_rd_addr_m) {std::cout << "  FAIL: o_rd_addr_m. Exp=" << (int)tc.exp_rd_addr_m << " Got=" << (int)top->o_rd_addr_m << std::endl; current_pass=false;}
        if(top->o_pc_plus_4_m != tc.exp_pc_plus_4_m) {std::cout << "  FAIL: o_pc_plus_4_m. Exp=0x" << std::hex << tc.exp_pc_plus_4_m << " Got=0x" << top->o_pc_plus_4_m << std::dec << std::endl; current_pass=false;}
        if(top->o_funct3_m != tc.exp_funct3_m) {std::cout << "  FAIL: o_funct3_m. Exp=" << (int)tc.exp_funct3_m << " Got=" << (int)top->o_funct3_m << std::endl; current_pass=false;}

        // Check PC update outputs
        if(top->o_pc_src_e != tc.exp_pc_src_e) {std::cout << "  FAIL: o_pc_src_e. Exp=" << tc.exp_pc_src_e << " Got=" << (int)top->o_pc_src_e << std::endl; current_pass=false;}
        if(top->o_pc_target_addr_e != tc.exp_pc_target_addr_e) {std::cout << "  FAIL: o_pc_target_addr_e. Exp=0x" << std::hex << tc.exp_pc_target_addr_e << " Got=0x" << top->o_pc_target_addr_e << std::dec << std::endl; current_pass=false;}

        if (current_pass) {
            std::cout << "  PASS" << std::endl;
            passed_count++;
        } else {
            std::cout << "  FAILED" << std::endl;
        }
    }

    std::cout << "\nExecute Stage Testbench Finished. Passed " << passed_count << "/" << test_cases.size() << " tests." << std::endl;

    if (tfp) tfp->close();
    delete top;
    return (passed_count == test_cases.size()) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/CMakeLists.txt ---
set(RTL_INCLUDE_PATH ${CMAKE_SOURCE_DIR}/rtl)

function(add_verilator_test module_name)
    set(OBJ_DIR ${CMAKE_CURRENT_BINARY_DIR}/obj_dir_${module_name})
    set(CPP_TESTBENCH_FILE ${CMAKE_CURRENT_SOURCE_DIR}/${module_name}.cpp)

    set(RTL_SOURCES "")
    foreach(rtl_file ${ARGN})
        list(APPEND RTL_SOURCES "${rtl_file}")
    endforeach()

    add_custom_target(build-unit-test-${module_name} ALL
        COMMAND ${CMAKE_COMMAND} -E make_directory ${OBJ_DIR}
        COMMAND ${PROJECT_VERILATOR_EXECUTABLE}
                -Wall --Wno-fatal --cc --exe --build --trace
                --top-module ${module_name}
                -I${RTL_INCLUDE_PATH}
                ${RTL_SOURCES}
                ${CPP_TESTBENCH_FILE}
                --Mdir "${OBJ_DIR}"
                -CFLAGS "-std=c++17 -Wall"
        DEPENDS ${RTL_SOURCES} ${CPP_TESTBENCH_FILE}
        COMMENT "Verilating and Building executable for ${module_name}"
        VERBATIM
        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    )

    add_custom_target(run-unit-test-${module_name}
        COMMAND "${OBJ_DIR}/V${module_name}"
        DEPENDS "build-unit-test-${module_name}"
        WORKING_DIRECTORY ${OBJ_DIR}
        COMMENT "Running Verilated test for ${module_name}"
        VERBATIM
    )

    if(TARGET tests_full)
        add_dependencies(tests_full run-unit-test-${module_name})
    endif()
endfunction()


add_verilator_test(
    alu
    ${CMAKE_SOURCE_DIR}/rtl/core/alu.sv
)


add_verilator_test(
    fetch_tb
    ${CMAKE_SOURCE_DIR}/rtl/core/fetch.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/instruction_memory.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/if_id_register.sv
    ${CMAKE_SOURCE_DIR}/tests/unit/fetch_tb.sv
)

add_verilator_test(
    decode_tb
    ${CMAKE_SOURCE_DIR}/rtl/core/decode.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/control_unit.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/register_file.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/immediate_generator.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/if_id_register.sv
    ${CMAKE_SOURCE_DIR}/tests/unit/decode_tb.sv
)

add_verilator_test(
    execute_tb # Top Verilog testbench module and .cpp file name
    # Source files needed
    ${CMAKE_SOURCE_DIR}/rtl/core/execute.sv
    ${CMAKE_SOURCE_DIR}/rtl/core/alu.sv         # execute instantiates alu
    # common defines are included via -I${RTL_INCLUDE_PATH}
    ${CMAKE_SOURCE_DIR}/tests/unit/execute_tb.sv # The Verilog testbench wrapper
)


--- File: tests/unit/decode_tb.cpp ---
// tests/unit/decode_tb.cpp
#include "Vdecode_tb.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <vector>
#include <string>
#include <map>
#include <bitset>
#include <optional>

// MANUALLY DEFINED C++ CONSTANTS (mirroring .svh files)

// From common/alu_defines.svh
const int ALU_CONTROL_WIDTH_CPP = 4;
const uint8_t ALU_OP_ADD_CPP  = 0b0000;
const uint8_t ALU_OP_SUB_CPP  = 0b0001;
const uint8_t ALU_OP_SLL_CPP  = 0b0010;
const uint8_t ALU_OP_SLT_CPP  = 0b0011;
const uint8_t ALU_OP_SLTU_CPP = 0b0100;
const uint8_t ALU_OP_XOR_CPP  = 0b0101;
const uint8_t ALU_OP_SRL_CPP  = 0b0110;
const uint8_t ALU_OP_SRA_CPP  = 0b0111;
const uint8_t ALU_OP_OR_CPP   = 0b1000;
const uint8_t ALU_OP_AND_CPP  = 0b1001;

// From common/control_signals_defines.svh
enum AluASrcSelCppTb { // Renamed to avoid potential conflicts if enums are also in Verilator headers
    ALU_A_SRC_RS1_TB,
    ALU_A_SRC_PC_TB,
    ALU_A_SRC_ZERO_TB
};

enum PcTargetSrcSelCppTb {
    PC_TARGET_SRC_PC_PLUS_IMM_TB,
    PC_TARGET_SRC_ALU_JALR_TB
};

// From common/riscv_opcodes.svh
// Opcodes
const uint8_t OPCODE_LUI_CPP        = 0b0110111;
const uint8_t OPCODE_AUIPC_CPP      = 0b0010111;
const uint8_t OPCODE_JAL_CPP        = 0b1101111;
const uint8_t OPCODE_JALR_CPP       = 0b1100111;
const uint8_t OPCODE_BRANCH_CPP     = 0b1100011;
const uint8_t OPCODE_LOAD_CPP       = 0b0000011;
const uint8_t OPCODE_STORE_CPP      = 0b0100011;
const uint8_t OPCODE_OP_IMM_CPP   = 0b0010011;
const uint8_t OPCODE_OP_CPP         = 0b0110011;

// Funct3 for OP_IMM & OP (examples)
const uint8_t FUNCT3_ADDI_CPP       = 0b000;
const uint8_t FUNCT3_SLLI_CPP       = 0b001;
const uint8_t FUNCT3_SLTI_CPP       = 0b010;
const uint8_t FUNCT3_SLTIU_CPP      = 0b011;
const uint8_t FUNCT3_XORI_CPP       = 0b100;
const uint8_t FUNCT3_SRLI_SRAI_CPP  = 0b101;
const uint8_t FUNCT3_ORI_CPP        = 0b110;
const uint8_t FUNCT3_ANDI_CPP       = 0b111;
// Funct3 for BRANCH (examples)
const uint8_t FUNCT3_BEQ_CPP        = 0b000;


const uint32_t NOP_INSTRUCTION = 0x00000013; // addi x0, x0, 0

vluint64_t sim_time = 0; // Changed from sim_time_decode to avoid conflicts if other TBs use sim_time

void tick(Vdecode_tb* dut, VerilatedVcdC* tfp) {
    dut->clk = 0;
    dut->eval();
    if (tfp) tfp->dump(sim_time);
    sim_time++;
    dut->clk = 1;
    dut->eval();
    if (tfp) tfp->dump(sim_time);
    sim_time++;
}

void reset_dut(Vdecode_tb* dut, VerilatedVcdC* tfp) {
    dut->rst_n = 0;
    dut->i_if_id_stall_d = 0;
    dut->i_if_id_flush_d = 0;
    dut->i_instr_f = NOP_INSTRUCTION;
    dut->i_pc_f = 0;
    dut->i_pc_plus_4_f = 4;
    dut->i_wb_write_en = 0;
    dut->i_wb_rd_addr = 0;
    dut->i_wb_rd_data = 0;
    for (int i = 0; i < 5; ++i) tick(dut, tfp); // Hold reset for a few cycles
    dut->rst_n = 1;
    tick(dut, tfp); // One tick out of reset
}

void set_reg(Vdecode_tb* dut, VerilatedVcdC* tfp, uint8_t reg_addr, uint64_t data) {
    if (reg_addr == 0) return; // Cannot write to x0
    dut->i_wb_write_en = 1;
    dut->i_wb_rd_addr = reg_addr;
    dut->i_wb_rd_data = data;
    // Write occurs on posedge clk within this tick
    tick(dut, tfp);
    dut->i_wb_write_en = 0;
    // It's good practice to let signals propagate after write_en goes low,
    // though for this specific RF design, the next tick in the main loop will handle negedge read.
}

uint8_t get_opcode_cpp(uint32_t instr) { return instr & 0x7F; }
uint8_t get_rd_cpp(uint32_t instr) { return (instr >> 7) & 0x1F; }
uint8_t get_funct3_cpp(uint32_t instr) { return (instr >> 12) & 0x07; }
uint8_t get_rs1_cpp(uint32_t instr) { return (instr >> 15) & 0x1F; }
uint8_t get_rs2_cpp(uint32_t instr) { return (instr >> 20) & 0x1F; }

struct ExpectedControls {
    bool        reg_write;
    uint8_t     result_src;
    bool        mem_write;
    bool        jump;
    bool        branch;
    bool        alu_src_b; // For Operand B
    uint8_t     alu_control;
    AluASrcSelCppTb op_a_sel;
    PcTargetSrcSelCppTb pc_target_sel;
};

struct DecodeTestCase {
    std::string name;
    uint32_t    instruction;
    uint64_t    pc_val;
    std::map<uint8_t, uint64_t> initial_regs;
    ExpectedControls controls;
    std::optional<uint64_t> expected_rs1_data;
    std::optional<uint64_t> expected_rs2_data;
    std::optional<uint64_t> expected_imm_ext;
};


int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vdecode_tb* top = new Vdecode_tb;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace(tfp, 99); // Trace 99 levels of hierarchy
    tfp->open("tb_decode.vcd");

    std::cout << "Starting Decode Stage Testbench (Comprehensive)" << std::endl;

    std::vector<DecodeTestCase> test_cases = {
        // NOP
        {
            "NOP (addi x0,x0,0)", NOP_INSTRUCTION, 0x0, {},
            {true, 0b00, false, false, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            0, std::nullopt, 0 // rs1 is x0, so data is 0. rs2 not used by ADDI. imm is 0.
        },
        // R-Type
        {
            "ADD x3,x1,x2", 0x002081B3, 0x100, {{1,10},{2,20}}, // x1=10, x2=20 => x3=30
            {true, 0b00, false, false, false, false, ALU_OP_ADD_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            10, 20, std::nullopt // rs1=10, rs2=20. No imm.
        },
        {
            "SUB x4,x1,x0", 0x40008233, 0x104, {{1,50}},      // x1=50, x0=0 => x4=50
            {true, 0b00, false, false, false, false, ALU_OP_SUB_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            50, 0, std::nullopt // rs1=50, rs2 (x0) = 0. No imm.
        },
         {
            "SLL x5,x1,x2 (shamt=5)", 0x002092B3, 0x108, {{1,0x1},{2,0x5}},
            {true, 0b00, false, false, false, false, ALU_OP_SLL_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            0x1, 0x5, std::nullopt // rs1=1, rs2=5 (shamt). No imm.
        },
        // I-Type Arithmetic
        {
            "ADDI x1,x2,-10", 0xFF610093, 0x200, {{2,100}},   // x2=100, imm=-10 => x1=90
            {true, 0b00, false, false, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            100, std::nullopt, 0xFFFFFFFFFFFFFFF6ULL // rs1=100. rs2 not used. imm = -10.
        },
        {
            "SLLI x8,x1,5", 0x00509413, 0x220, {{1,0x2}},    // x1=2, shamt=5 => x8=64 (0x40)
            {true, 0b00, false, false, false, true, ALU_OP_SLL_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            0x2, std::nullopt, 0x5 // rs1=2. rs2 not used for SLLI. imm_ext is shamt=5.
        },
        {
            "SRAI x10,x1,2", 0x4020D513, 0x228, {{1,0xFFFFFFFFFFFFFFFCULL}}, // x1=-4, shamt=2 => x10=-1
            {true, 0b00, false, false, false, true, ALU_OP_SRA_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            0xFFFFFFFFFFFFFFFCULL, std::nullopt, 0x2 // rs1=-4. rs2 not used for SRAI. imm_ext is shamt=2.
        },
        // U-Type
        {
            "LUI x5,0xABCD0", 0xABCD02B7, 0x300, {}, // imm=0xABCD0 => x5=0xABCD0000 (sign ext if MSB of imm is 1)
            {true, 0b00, false, false, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_ZERO_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            std::nullopt, std::nullopt, 0xFFFFFFFFABCD0000ULL // rs1 not used (OpA is ZERO). rs2 not used. imm is U-type.
        },
        {
            "AUIPC x6,0x1", 0x00001317, 0x304, {},   // pc=0x304, imm=0x1 => x6=0x304 + 0x1000 = 0x1304
            {true, 0b00, false, false, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_PC_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            std::nullopt, std::nullopt, 0x1000ULL // rs1 not used (OpA is PC). rs2 not used. imm is U-type.
        },
        // Load
        {
            "LW x7,12(x1)", 0x00C0A383, 0x400, {{1,0x1000}}, // x1=0x1000, offset=12. rd=x7
            {true, 0b01, false, false, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            0x1000, std::nullopt, 0xC // rs1=0x1000 (base addr). rs2 not used. imm=offset.
        },
        // Store - Corrected test case as per previous discussion
        {
            "SW x7,16(x5)", 0x0110A823, 0x404, {{5,0x2000},{7,0xDEADBEEF}}, // rs1=x5 (base), rs2=x7 (data)
            {false,0b00, true, false, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            0x2000, 0xDEADBEEF, 0x10 // rs1_data_d is from x5 (base), rs2_data_d is from x7 (data to store). imm=offset.
        },
        // Branch
        {
            "BEQ x1,x0,+8 (taken)", 0x00008463, 0x500, {{1,0}}, // x1=0, x0=0. offset=8. Target=0x508
            {false,0b00, false, false, true, false, ALU_OP_SUB_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            0, 0, 0x8 // rs1 (x1)=0, rs2 (x0)=0. imm=offset.
        },
        // Jumps
        {
            "JAL x1,+16", 0x010000EF, 0x600, {}, // rd=x1 (PC+4). Target=PC+16=0x610
            {true, 0b10, false, true, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_PC_TB, PC_TARGET_SRC_PC_PLUS_IMM_TB},
            std::nullopt, std::nullopt, 0x10 // rs1 not used (OpA is PC). rs2 not used. imm=J-offset.
        },
        {
            "JALR x1,x2,32", 0x020100E7, 0x604, {{2,0x1000}}, // rd=x1 (PC+4). Target=(x2+32)&~1 = (0x1000+0x20)&~1 = 0x1020
            {true, 0b10, false, true, false, true, ALU_OP_ADD_CPP, ALU_A_SRC_RS1_TB, PC_TARGET_SRC_ALU_JALR_TB},
            0x1000, std::nullopt, 0x20 // rs1 (x2)=0x1000. rs2 not used. imm=I-offset.
        }
    };

    int passed_count = 0;
    for (const auto& tc : test_cases) {
        std::cout << "\nRunning Test: " << tc.name << std::endl;
        std::cout << "  Instruction: 0x" << std::hex << tc.instruction << ", PC: 0x" << tc.pc_val << std::dec << std::endl;

        reset_dut(top, tfp);

        // Initialize registers based on the test case
        for(const auto& reg_pair : tc.initial_regs) {
            set_reg(top, tfp, reg_pair.first, reg_pair.second);
        }

        // Set up inputs for the IF/ID register
        top->i_instr_f = tc.instruction;
        top->i_pc_f = tc.pc_val;
        top->i_pc_plus_4_f = tc.pc_val + 4;
        top->i_if_id_stall_d = 0;
        top->i_if_id_flush_d = 0;

        // --- Clock Cycle 1 ---
        // Posedge: IF/ID register latches i_instr_f, i_pc_f, i_pc_plus_4_f.
        //          Outputs of IF/ID (instr_id_val, pc_id_val, pc_plus_4_id_val) update.
        //          These values propagate to the Decode stage.
        //          In decode.sv, rs1_addr_instr and rs2_addr_instr update based on new instr_id_val.
        // Negedge (conceptually at the end of clk=0 period of this tick):
        //          Register file rs1_data_o/rs2_data_o are NOT yet updated with data for *this* instruction,
        //          as their read addresses (rs1_addr_i, rs2_addr_i) only just got updated.
        //          They would reflect data for addresses present *before* this instruction was latched.
        tick(top, tfp);
        // For debugging:
        // std::cout << "  After Tick 1 (IF/ID latch): " << std::endl;
        // std::cout << "    o_instr_id: 0x" << std::hex << top->o_instr_id << std::dec << std::endl;
        // std::cout << "    o_rs1_addr_d: " << (int)top->o_rs1_addr_d << ", o_rs2_addr_d: " << (int)top->o_rs2_addr_d << std::endl;

        // --- Clock Cycle 2 ---
        // Negedge (at the start of clk=0 period of this tick):
        //          Register file now performs read using rs1_addr_i and rs2_addr_i that were set
        //          by the current instruction (latched in IF/ID in the previous cycle).
        //          rs1_data_o and rs2_data_o outputs of register_file update with correct data.
        // Posedge: Decode stage's combinational logic (control_unit, immediate_generator)
        //          processes the now-stable rs1_data_o, rs2_data_o, and other inputs.
        //          All outputs of the Decode stage (o_rs1_data_d, o_control_signals, etc.) become stable.
        tick(top, tfp);
        // For debugging:
        // std::cout << "  After Tick 2 (Decode process): " << std::endl;
        // std::cout << "    o_rs1_data_d: 0x" << std::hex << top->o_rs1_data_d << std::dec << std::endl;
        // std::cout << "    o_rs2_data_d: 0x" << std::hex << top->o_rs2_data_d << std::dec << std::endl;


        // Now perform checks on the stable outputs of the Decode stage
        bool current_pass = true;
        uint8_t instr_opcode = get_opcode_cpp(tc.instruction);
        uint8_t instr_rd  = get_rd_cpp(tc.instruction);
        uint8_t instr_rs1 = get_rs1_cpp(tc.instruction);
        uint8_t instr_rs2 = get_rs2_cpp(tc.instruction);
        uint8_t instr_funct3 = get_funct3_cpp(tc.instruction);

        // Check Control Signals
        if(top->o_reg_write_d != tc.controls.reg_write) {std::cout << "  FAIL: RegWrite_D. Exp=" << tc.controls.reg_write << " Got=" << (int)top->o_reg_write_d << std::endl; current_pass=false;}
        if(top->o_result_src_d != tc.controls.result_src) {std::cout << "  FAIL: ResultSrc_D. Exp=" << (int)tc.controls.result_src << " Got=" << (int)top->o_result_src_d << std::endl; current_pass=false;}
        if(top->o_mem_write_d != tc.controls.mem_write) {std::cout << "  FAIL: MemWrite_D. Exp=" << tc.controls.mem_write << " Got=" << (int)top->o_mem_write_d << std::endl; current_pass=false;}
        if(top->o_jump_d != tc.controls.jump) {std::cout << "  FAIL: Jump_D. Exp=" << tc.controls.jump << " Got=" << (int)top->o_jump_d << std::endl; current_pass=false;}
        if(top->o_branch_d != tc.controls.branch) {std::cout << "  FAIL: Branch_D. Exp=" << tc.controls.branch << " Got=" << (int)top->o_branch_d << std::endl; current_pass=false;}
        if(top->o_alu_src_d != tc.controls.alu_src_b) {std::cout << "  FAIL: AluSrc_B_D (alu_src_d). Exp=" << tc.controls.alu_src_b << " Got=" << (int)top->o_alu_src_d << std::endl; current_pass=false;}
        if(top->o_alu_control_d != tc.controls.alu_control) {std::cout << "  FAIL: AluControl_D. Exp=0b" << std::bitset<ALU_CONTROL_WIDTH_CPP>(tc.controls.alu_control) << " Got=0b" << std::bitset<ALU_CONTROL_WIDTH_CPP>(top->o_alu_control_d) << std::endl; current_pass=false;}
        if(top->o_op_a_sel_d != static_cast<uint8_t>(tc.controls.op_a_sel)) {std::cout << "  FAIL: OpASel_D. Exp=" << (int)tc.controls.op_a_sel << " Got=" << (int)top->o_op_a_sel_d << std::endl; current_pass=false;}
        if(top->o_pc_target_src_sel_d != static_cast<uint8_t>(tc.controls.pc_target_sel)) {std::cout << "  FAIL: PcTargetSel_D. Exp=" << (int)tc.controls.pc_target_sel << " Got=" << (int)top->o_pc_target_src_sel_d << std::endl; current_pass=false;}
        if(top->o_funct3_d != instr_funct3) {std::cout << "  FAIL: Funct3_D. Exp=0b" << std::bitset<3>(instr_funct3) << " Got=0b" << std::bitset<3>(top->o_funct3_d) << std::endl; current_pass=false;}

        // Check PC values (latched from IF/ID)
        if(top->o_pc_d != tc.pc_val) {std::cout << "  FAIL: PC_D. Exp=0x" << std::hex << tc.pc_val << " Got=0x" << top->o_pc_d << std::dec << std::endl; current_pass=false;}
        if(top->o_pc_plus_4_d != (tc.pc_val + 4)) {std::cout << "  FAIL: PCPlus4_D. Exp=0x" << std::hex << (tc.pc_val + 4) << " Got=0x" << top->o_pc_plus_4_d << std::dec << std::endl; current_pass=false;}

        // Check Register Addresses (extracted from instruction)
        if(top->o_rd_addr_d != instr_rd) {std::cout << "  FAIL: RdAddr_D. Exp=" << (int)instr_rd << " Got=" << (int)top->o_rd_addr_d << std::endl; current_pass=false;}
        if(top->o_rs1_addr_d != instr_rs1) {std::cout << "  FAIL: Rs1Addr_D. Exp=" << (int)instr_rs1 << " Got=" << (int)top->o_rs1_addr_d << std::endl; current_pass=false;}
        if(top->o_rs2_addr_d != instr_rs2) {std::cout << "  FAIL: Rs2Addr_D. Exp=" << (int)instr_rs2 << " Got=" << (int)top->o_rs2_addr_d << std::endl; current_pass=false;}

        // Check rs1_data_d
        if (tc.expected_rs1_data.has_value()) {
            uint64_t expected_val_rs1 = (instr_rs1 == 0) ? 0 : tc.expected_rs1_data.value();
            if (top->o_rs1_data_d != expected_val_rs1) {
                std::cout << "  FAIL: Rs1Data_D. Exp=0x" << std::hex << expected_val_rs1 << " Got=0x" << top->o_rs1_data_d << std::dec << std::endl;
                current_pass = false;
            }
        }
        // Check rs2_data_d
        if (tc.expected_rs2_data.has_value()) {
            uint64_t expected_val_rs2 = (instr_rs2 == 0 && instr_opcode != OPCODE_STORE_CPP) ? 0 : tc.expected_rs2_data.value();
             // For STORE, rs2_data_d is the data to be stored, read from register rs2.
             // It should be tc.expected_rs2_data.value() even if rs2 is x0 (though storing x0 is unusual).
             // For non-STORE instructions, if rs2 is x0, data should be 0.
            if (instr_opcode == OPCODE_STORE_CPP) { // Ensure store takes the direct expected value
                expected_val_rs2 = tc.expected_rs2_data.value();
            }


            if (top->o_rs2_data_d != expected_val_rs2) {
                std::cout << "  FAIL: Rs2Data_D. Exp=0x" << std::hex << expected_val_rs2 << " Got=0x" << top->o_rs2_data_d << " (Instr rs2: " << (int)instr_rs2 << ")" << std::dec << std::endl;
                current_pass = false;
            }
        }
        // Check imm_ext_d
        if (tc.expected_imm_ext.has_value()) {
            if (top->o_imm_ext_d != tc.expected_imm_ext.value()) {
                std::cout << "  FAIL: ImmExt_D. Exp=0x" << std::hex << tc.expected_imm_ext.value() << " Got=0x" << top->o_imm_ext_d << std::dec << std::endl;
                current_pass = false;
            }
        }

        if (current_pass) {
            std::cout << "  PASS" << std::endl;
            passed_count++;
        } else {
            std::cout << "  FAILED" << std::endl;
        }
    }

    std::cout << "\nDecode Stage Testbench Finished. Passed " << passed_count << "/" << test_cases.size() << " test cases." << std::endl;
    if (tfp) tfp->close();
    delete top;
    return (passed_count == test_cases.size()) ? EXIT_SUCCESS : EXIT_FAILURE;
}


--- File: tests/unit/fetch_tb.sv ---
`include "common/defines.svh"

module fetch_tb (
    input  logic clk,
    input  logic rst_n,

    // Inputs to control fetch stage behavior
    input  logic                       i_stall_f,
    input  logic                       i_pc_src_e,
    input  logic [`DATA_WIDTH-1:0]     i_pc_target_e,
    input  logic                       i_stall_d,
    input  logic                       i_flush_d,

    // Outputs from IF/ID register (to observe)
    output logic [`INSTR_WIDTH-1:0]    o_instr_id,
    output logic [`DATA_WIDTH-1:0]     o_pc_plus_4_id,
    output logic [`DATA_WIDTH-1:0]     o_pc_id,
    output logic [`DATA_WIDTH-1:0]     o_current_pc_f // For observing PC in fetch stage itself
);

    logic [`INSTR_WIDTH-1:0]    instr_f_val;
    logic [`DATA_WIDTH-1:0]     pc_plus_4_f_val;
    logic [`DATA_WIDTH-1:0]     pc_f_val;

    fetch u_fetch (
        .clk            (clk),
        .rst_n          (rst_n),
        .stall_f        (i_stall_f),
        .pc_src_e       (i_pc_src_e),
        .pc_target_e    (i_pc_target_e),
        .instr_f_o      (instr_f_val),
        .pc_plus_4_f_o  (pc_plus_4_f_val),
        .pc_f_o         (pc_f_val)
    );

    if_id_register u_if_id_register (
        .clk            (clk),
        .rst_n          (rst_n),
        .stall_d        (i_stall_d),
        .flush_d        (i_flush_d),
        .instr_f_i      (instr_f_val),
        .pc_plus_4_f_i  (pc_plus_4_f_val),
        .pc_f_i         (pc_f_val),
        .instr_id_o     (o_instr_id),
        .pc_plus_4_id_o (o_pc_plus_4_id),
        .pc_id_o        (o_pc_id)
    );

    assign o_current_pc_f = pc_f_val;

endmodule


